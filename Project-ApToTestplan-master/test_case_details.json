{
    "bundlemgr_1D_scale_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Lacp counters",
                "Procedure": "The test verifies that the counters increase when LACP short is configured, specifically in an ISIS/IPv4 environment. \n\nThis test is triggered by verifying whether counters increase with LACP short configuration.",
                "Pass/Fail Criteria": "Bundle bringup with lacp verification is performed.\nLacp period short consistency verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "One member in one bundle for all interfaces",
                "Procedure": "To run this test, remove the base interface configuration from each router and then move each interface to a separate bundle for all interfaces. The test verifies that members of these bundles can be administratively shut down or enabled and still allow traffic to flow through the bundle. It also checks that traffic configurations for ISIS, IPv4, and IPv6 protocols function correctly.\n\nThis test is triggered by the removal of base interface configuration from each router in preparation for moving interfaces to separate bundles for all interfaces on routers.",
                "Pass/Fail Criteria": "Isis routes verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nBundle bringup with lacp verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove all members to one bundle",
                "Procedure": "When adding or removing all members from a bundle, up to a weighted limit of 64, the test checks for two key scenarios. It verifies that adding or removing bundle members allows traffic to flow through the bundle while only one bundle is active on each side. The test also confirms that bundle members can be added or removed with uninterrupted traffic flow.\n\nThis test is triggered by verifying Bundle members can be added/removed and traffic flows through bundle, Verify Traffic Configuration: ISIS/IPv4/IPv6.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ndevices: \"['R2']\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nBundle ether verification is performed.\nActive bundle status verification is performed.\nIpv4 ipv6 ping verification is performed.\nIsis neighbors verification is performed.\nIsis routes verification is performed.\nTraffic stats verification is performed.\nAcl verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTraffic loss duration verification is performed.\nInterface accounting verification is performed.\nBundle qos verify verification is performed.\nGlobal id verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L3scale interface accounting",
                "Procedure": "The test verifies that a large number of L3 Bundle sub-interfaces can be configured on an XR router, specifically checking that up to 8,000 sub-interfaces are able to scale correctly when changing the input file's configuration numbers. It also tests data traffic over IPv4 and IPv6 on these configured sub-interfaces.\n\nThis test is triggered by verifying various configurations for L3 Bundle sub-interfaces, including those designed for ASR9K systems with 8k interfaces and others with a limit of 1024 sub-interfaces.",
                "Pass/Fail Criteria": "Show interfaces summary verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L3scale interface accounting hqos",
                "Procedure": "The test verifies the ability to configure a large number of L3 bundle sub-interfaces with HQOS enabled on an XR router. The test checks that 1024 bundle l3 sub-interfaces can be configured, and also that up to 8,000 interfaces can be scaled by changing numbers in the input file. Data traffic is verified for both IPv4 and IPv6 protocols on the configured sub-interfaces.\n\nThis test is triggered by a change in the number of L3 Bundle sub-interfaces being scaled on the router.",
                "Pass/Fail Criteria": "Show interfaces summary verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bundlemgr_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Bundle bringup",
                "Procedure": "The test_bundle_bringup tests verify the state and traffic flow of a bundle that is not using LACP. It checks for several things, including verifying traffic statistics, interface statistics, and itself as part of every high-availability (HA) test case. This test is triggered by an ISIS/IPv4 traffic configuration.",
                "Pass/Fail Criteria": "Traffic stats verification is performed.\nBundle brief verification is performed.\nIpv4 ipv6 ping verification is performed.\nIsis neighbors verification is performed.\nIsis routes verification is performed.\nInterface accounting verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle bringup with lacp",
                "Procedure": "The test_bundle_bringup_with_lacp test bundles the state and traffic flow, verifying several key aspects. It checks for accurate traffic statistics, correct interface stats, and runs as a prerequisite for all HA (High Availability) tests. This test is triggered by the configuration of ISIS/IPv4 Traffic.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle ether verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify traffic",
                "Procedure": "The test_verify_traffic test verifies that traffic is flowing.\n\nThis test is triggered by verifying that a traffic flow has been initiated.",
                "Pass/Fail Criteria": "Traffic stats verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp counters",
                "Procedure": "This test verifies that Lacp counter increments when Lacp short is configured for an ISIS/IPv4 connection. It checks if the counters increase in this specific configuration scenario.\n\nThis test is triggered by a configuration of ISIS/IPv4 with Lacp short enabled.",
                "Pass/Fail Criteria": "Bundle bringup with lacp verification is performed.\nLacp period short consistency verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp super fast",
                "Procedure": "The test, known as test_lacp_super_fast, verifies that a specific configuration has an effect on system behavior. It checks whether certain counters increase when the LACP (Link Aggregation Control Protocol) period is set to 100 milliseconds in conjunction with ISIS/IPv4 routing protocol.\n\nThis test is triggered by configuring ISIS/IPv4 and setting the Lacp period to 100 milliseconds.",
                "Pass/Fail Criteria": "Lacp period short consistency verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Clear lacp counters",
                "Procedure": "The test_clear_lacp_counters test verifies whether the counters are correctly updated after they have been cleared. It also assumes that ISIS/IPv4 with clear LACP counters configuration is in place.\n\nThis test is triggered by a scenario where ISIS/IPv4 with clear LACP counters configuration is set up.",
                "Pass/Fail Criteria": "Bundle bringup with lacp verification is performed.\nLacp period default consistency verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Max active links",
                "Procedure": "When attempting to add a new member beyond the maximum allowed active links in an ISIS/IPv4 LACP configuration, the active link count should not be increased. This test is triggered by adding a member beyond the max active link threshold.\n\n(Rewritten trigger sentence)",
                "Pass/Fail Criteria": "Bundle ether verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Min active links",
                "Procedure": "When the minimum active link threshold for an ISIS/IPv4 LACP configuration is set, this test removes a member from the bundle and checks that it stops distributing. This test verifies removing a member from bundle when minimum active link threshold is configured makes the bundle to stop distributing.",
                "Pass/Fail Criteria": "Lacp bundle ether verification is performed.\nIpv4 ipv6 ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp modes",
                "Procedure": "The test case for LACP (Link Aggregation Control Protocol) modes verifies that the interface is operating in both active and passive modes. The test checks for the correct display of interface statistics with different LACP modes: it should show 'Active' when the mode is set to 1 and 'Passive' when the mode is set 2.\n\nThis test is triggered by setting the LACP mode to either 1 (Active) or 2 (Passive).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"active\" and \"passive\"",
                "Pass/Fail Criteria": "Lacp bundle ether verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle min active bandwidth threshold",
                "Procedure": "When verifying the bundle state, it's essential to ensure that the distribution functionality is working correctly when the interface bandwidth (bw) exceeds its minimum threshold. This test case checks three main aspects: first, it confirms that the bundle state transitions to a distributing mode after configuring the minimum active bandwidth; second, it verifies the traffic statistics; and third, it involves over-subscribing the interface to see if traffic is correctly dropped. The configuration for this test includes ISIS and IPv6 traffic.\n\nThis test is triggered by specifying an interface bandwidth above its minimum threshold in the ISIS/IPv6 Traffic configuration.",
                "Pass/Fail Criteria": "Bundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp hot standby",
                "Procedure": "When verifying LACP's hot standby functionality, the test checks for two key conditions. First, it ensures that only a number of links equal to the configured maximum-active value are in an active state. Second, it verifies that any additional links are indeed in a hot standby state. Furthermore, when adjusting the priority of certain ports, the test confirms that they can move from standby to active mode as needed.\n\nThis test is triggered by ISIS/IPv6 traffic.",
                "Pass/Fail Criteria": "Bundle ether verification is performed.\nLacp bundle ether verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp packet capture",
                "Procedure": "To determine if lacp packets are being properly captured, verify that when running in active mode and with port activity enabled on a bundle interface, the command \"show lacp packet-capture decoded <interface>\" successfully captures and displays lacp packets. Additionally, confirm that the packets captured at each end of the link only match (IN/OUT) as expected, and ensure that the traffic configuration is set to ISIS/IPv4/IPv6. This test is triggered by a bundle with LACP active mode and members with port activity active.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nLacp packet capture verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp non revertive",
                "Procedure": "To verify lacp non-revertive, only the number of links up to the configured maximum-active number should be in an active state, while the other links should be in a hot standby state. In addition, traffic should still flow as expected. This test is triggered by IS-IS/IPv6 traffic configuration.",
                "Pass/Fail Criteria": "Bundle ether verification is performed.\nLacp bundle ether verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp system id",
                "Procedure": "The test case is designed to verify that the LACP (Link Aggregation Control Protocol) system ID settings are correct. This includes verifying the system ID using the \"show lacp system-id\" command and ensuring that traffic flows as expected, all within an ISIS/IPv6 network.\n\nThis test is triggered by: The configuration of ISIS/IPv6 traffic on a network device with LACP enabled.",
                "Pass/Fail Criteria": "Bundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp repeatative mode change with short and long periods",
                "Procedure": "To verify lacp mode changes repeatedly, both with extended and brief intervals, we must ensure that the LACP state accurately reflects these changes. Moreover, we should confirm that traffic continues to flow uninterrupted during this process. The test environment involves an IS-IS/IPv6 configuration.\n\nThis test is triggered by a change in LACP mode that occurs repeatedly, both over long and short periods of time.",
                "Pass/Fail Criteria": "Bundle mode flags verification is performed.\nLacp period short consistency verification is performed.\nTraffic stats verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mtu add and delete",
                "Procedure": "The purpose of this test is to verify that the maximum transmission unit (MTU) configuration on a bundle interface functions as expected, including a ping check with a size option and the Don't Fragment bit set. It also tests traffic flow with non-default MTU settings and ensures that these settings revert to their original state after a commit rollback operation. The test assumes an MTU config has been established on the bundle.\n\nThis test is triggered by configuring an MTU setting on a bundle interface.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nInterface detail verification is performed.\nTraffic stats verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle wait while",
                "Procedure": "The test verifies that bundle wait while timer values match the configuration, and that changing the system's priority causes a delay in associating with the bundle from the link UP timestamp.\n\nThis test is triggered by configuring the bundle wait-while timer to any value between 0 and 2000 milliseconds and setting the system's priority such that it triggers the bundle wait-while timer.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Show tech bundles",
                "Procedure": "This test verifies that performing \"show tech bundles\" from the CLI does not cause a crash or core dump and keeps all members of a specified bundle in a down state, with configuration parameters including the name of the bundle and IS-IS (Intermediate System to Intermediate System). This test is triggered by the presence of specific keywords in the input.",
                "Pass/Fail Criteria": "Perform healthcheck verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp fallback",
                "Procedure": "The LACP Fallback feature allows an active LACP interface to establish a Link Aggregation Group (LAG) port-channel before the port-channel receives the Link Aggregation and Control Protocol (LACP) protocol data units (PDU) from its peer. With this feature configured, the router enables the server to bring up the LAG even without receiving any LACP PDUs from the server, keeping one port active. This allows the server to establish a connection to a PXE server over one Ethernet port, download a boot image, and then continue the booting process. When the server's boot process is complete, it fully forms an LACP port-channel.\n\nThis test is triggered by configuring LACP Fallback with a timeout of 5 seconds on the UUT, removing the bundle ID from members on the peer router, verifying that the link goes down due to lack of LACP PDUs, waiting for the fallback timeout, and then checking if the bundle comes up with pseudo-LACP.",
                "Pass/Fail Criteria": "Bundle ether verification is performed.\nBundle infra fallback verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove members with one commit on uut",
                "Procedure": "Bundle members can be added or removed, and traffic still flows through the bundle, even if only one side is currently in use. This test verifies that adding or removing bundle members with a single commit does not disrupt traffic when it's flowing on only one side of the bundle, which is configured to run ISIS over IPv4 and IPv6 networks. \n\nTrigger sentence: This test is triggered by testing the addition and removal of bundle members with a single commit while traffic flows through the bundle on only one side.",
                "Pass/Fail Criteria": "Multicast traffic verification is performed.\nBundle bringup verification is performed.\nAcl verification is performed.\nTraffic verification is performed.\nTraffic stats verification is performed.\nIsis neighbors verification is performed.\nIsis routes verification is performed.\nBundle bringup with lacp verification is performed.\nNetflow traffic verification is performed.\nBundle qos verify verification is performed.\nTraffic loss duration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Multitimes members add remove",
                "Procedure": "The test_multitimes_members_add_remove checks how a network device handles adding and removing multiple members from a bundle while traffic flows only on one side of the bundle, verifying that it can handle ASIC errors and configure traffic settings for both IPv4 and IPv6 IS-IS routing protocols. This test is triggered by the need to verify the robustness of bundle member management under high traffic conditions.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Multi members add remove same commit",
                "Procedure": "The test_multi_members_add_remove_same_commit checks how the add/remove bundle members function with one commit while traffic only flows on one side of the bundle. It verifies that bundle members can be added or removed within a single commit without disrupting traffic flow, and also tests traffic configuration for ISIS/IPv4/IPv6 networks. This test is triggered by removing bundle members and adding them in the same commit.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Interface breakout",
                "Procedure": "The test interface breakout function tests the traffic after removing an active breakout interface and then doing a rollback commit. This verifies that traffic flows correctly post-removal of one breakout interface, followed by application of a rollback commit to restore the previous configuration, as well as checking on bundle status.\n\nThis test is triggered by removing the active breakout interface configuration and then performing a rollback commit.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove one member with traffic",
                "Procedure": "This test verifies that when a single bundle member is removed from an ISIS configuration with IPv4 and IPv6 traffic enabled, there is no significant traffic loss.\n\nThis test is triggered by the removal of one bundle member in an ISIS configuration with both IPv4 and IPv6 enabled.",
                "Pass/Fail Criteria": "Lc shell pending delete obj verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nBundle qos verify verification is performed.\nGlobal id verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove member by bundle id on peer",
                "Procedure": "This test checks the impact of removing a single bundle member from a peer router on traffic and configurations, verifying that there is no significant loss of traffic when the removal is done without specifying a bundle ID in the CLI commands. The configuration used for this test includes ISIS with both IPv4 and IPv6 traffic enabled. This test is triggered by the removal of a member ID on a peer router.",
                "Pass/Fail Criteria": "Add remove one member with traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove member by no interface on uut",
                "Procedure": "This test verifies that there's no traffic loss when a single bundle member is added or removed from a router's configuration through the command line interface. To trigger this test, This test is triggered by running the CLI command \"no interface <bundle-member-name>\" on the Universal Test Unit (UUT) router with ISIS/IPv4/IPv6 enabled and configured.",
                "Pass/Fail Criteria": "Add remove one member with traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove member by no interface on peer",
                "Procedure": "A test that adds or removes a bundle member by CLI without an interface on a peer verifies several things, including verifying the loss of traffic when a single bundle member is removed from a peer router via the CLI. To remove a bundle member, use the command \"no interface <bundle-member-name>\". This test is triggered by configuring ISIS/IPv4/IPv6 traffic.",
                "Pass/Fail Criteria": "Add remove one member with traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove members with one commit on peer",
                "Procedure": "A test is designed to add or remove bundle members with a single commit, ensuring that traffic continues to flow only on one side of the bundle. The test verifies two key aspects: first, it checks whether adding or removing bundle members allows traffic to pass through the bundle as expected; second, it confirms that the configuration supports both IPv4 and IPv6 traffic types over ISIS networks. This test is triggered by a specific scenario where traffic flows only on one side of the bundle.\n\nRewritten trigger sentence:\nThis test is triggered by a scenario where traffic flows only on one side of the bundle.",
                "Pass/Fail Criteria": "Add remove members with one commit on uut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Swap bundle with traffic",
                "Procedure": "The test_swap_bundle_members_with_traffic is designed to verify that bundle members can be swapped with each other without disrupting traffic flow. This test involves swapping the bundle members while traffic continues to flow, ensuring that both IPv4 and IPv6 traffic configurations remain unaffected by the change.\n\nThis test is triggered by traffic configuration changes in ISIS/IPv4/IPv6 settings.",
                "Pass/Fail Criteria": "Add remove members with one commit on uut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Remove and addition of passive bundle member",
                "Procedure": "This test is triggered by verifying that removing and re-adding a Passive member to a bundle works as expected, even when the maximum active link threshold is configured. The test checks that this operation does not cause any issues despite having the maximum link threshold set in place.",
                "Pass/Fail Criteria": "Bundle ether verification is performed.\nAcl verification is performed.\nTraffic verification is performed.\nBundle bringup with lacp verification is performed.\nBundle bringup verification is performed.\nGlobal id verification is performed.\nTraffic loss duration verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shut no shut one member sequential on uut",
                "Procedure": "On a UUT device with multiple lacp bundles, select one random bundle and sequentially shut down all its members except for one. As long as there's still some traffic flowing, that last member will remain active. When the test is triggered by shutting one of the remaining members of a bundle, it confirms that each member can be individually shut or no-shut while maintaining traffic flow within the bundle, which verifies both functionality and traffic configuration under ISIS/IPv4/IPv6 protocols.",
                "Pass/Fail Criteria": "Multicast traffic verification is performed.\nAcl verification is performed.\nBundle member packet stats verification is performed.\nBundle qos verify verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nGlobal id verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shut no shut one member sequential on peers",
                "Procedure": "Randomly select a lacp bundle on each peer device. Shut all but one member of that bundle, allowing traffic to continue flowing while the rest are disabled. Then un-shut them one by one in sequence. This test is triggered by verifying that bundle members can be shut or left operational without disrupting traffic flow through the bundle, as well as confirming that the traffic configuration for ISIS/IPv4 and IPv6 is functioning correctly.",
                "Pass/Fail Criteria": "Shut no shut one member sequential on uut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "One bundle with one member on each side of uut",
                "Procedure": "To test uut device functionality, select one random bundle on each side of the device and a single member from that bundle. Shut down all other bundle members and physical interfaces while allowing traffic to flow through the selected member on each side, then un-shut all previously shut-down interfaces.\n\nThis test is triggered by verifying that bundle members can be shut or no-shut and that traffic flows correctly through them, as well as confirming proper configuration of ISIS/IPv4/IPv6 traffic.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic stats verification is performed.\nActive bundle status verification is performed.\nIpv4 ipv6 ping verification is performed.\nIsis neighbors verification is performed.\nIsis routes verification is performed.\nAcl verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nInterface accounting verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Config max line rate one bundle with one member on each side of uut",
                "Procedure": "To verify the maximum line rate of a UUT, pick one bundle from each side and choose one member from that bundle on both sides. Shut down all other bundle members and physical interfaces to isolate the selected member, then verify that traffic flows through it at full line rate. This test is triggered by selecting a configuration with ISIS/IPv4/IPv6 Traffic.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "One member in one bundle for all interfaces",
                "Procedure": "When testing a network, it's necessary to remove the base interface configuration and then move each interface into its own unique bundle for all routers. This process verifies two key aspects of bundle functionality: first, that individual members can be shut down or no-shut down without affecting traffic flow through the bundle; second, that traffic configuration works correctly for a variety of protocols, including ISIS, IPv4, and IPv6.\n\nThis test is triggered by the removal of base interface configurations from all routers.",
                "Pass/Fail Criteria": "Isis routes verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nBundle bringup with lacp verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove all members to one bundle",
                "Procedure": "Adding or removing all bundle members up to a maximum of 64 is tested by adding and removing bundle members while traffic only flows through one bundle on each side. This test verifies that bundle members can be added and removed, allowing traffic to flow through the bundle, as well as verifying that the traffic configuration for ISIS/IPv4/IPv6 works correctly. This test is triggered by a configuration that adds or removes all bundle members.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ndevices: \"['R2']\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nBundle ether verification is performed.\nActive bundle status verification is performed.\nIpv4 ipv6 ping verification is performed.\nIsis neighbors verification is performed.\nIsis routes verification is performed.\nTraffic stats verification is performed.\nAcl verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTraffic loss duration verification is performed.\nInterface accounting verification is performed.\nBundle qos verify verification is performed.\nGlobal id verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp with bundle member inherit option",
                "Procedure": "When a bundle has LACP enabled in active mode and its members have port activity inheritance enabled, this test checks the bundle's basic properties along with LACP and traffic configuration. It verifies that the 'show bundle' output displays port activity inheritance for bundle members, checks the member state using 'show lacp bundle-ether<>', ensures the bundle meets basic LACP and traffic requirements, and confirms the traffic configuration is correct.\n\nThis test is triggered by a bundle with LACP in active mode and its members having port activity inheritance enabled.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nBundle ether verification is performed.\nLacp bundle ether verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap bundle interface with traffic",
                "Procedure": "A test for verifying the functionality of a flap bundle interface with ongoing traffic is as follows. The test checks two main aspects: first, it ensures that bundle members can be dynamically added or removed while traffic continues to flow uninterrupted through the bundle; second, it verifies that different types of traffic configurations, including ISIS (IS-IS), IPv4, and IPv6, function correctly within this bundle structure.\n\nThis test is triggered by the specific scenario where a flap bundle interface must operate simultaneously with ongoing traffic flows.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap members with traffic",
                "Procedure": "The test, which is triggered by the addition or removal of members from a flap bundle during normal traffic flow, verifies two main aspects. Firstly, it checks that bundle members can indeed be added or removed while traffic continues to pass through the bundle unimpeded. Secondly, it confirms that the traffic configuration functions correctly under these conditions, specifically with ISIS and both IPv4 and IPv6 protocols in place.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap members with traffic on peers",
                "Procedure": "The test involves adding and removing bundle members from a peer while traffic is flowing. It checks to see if this process affects the flow of traffic, verifying that bundle members can indeed be added or removed without disrupting the network. This test is triggered by a configuration with ISIS traffic on either IPv4 or IPv6 networks.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shut noshut bundle with traffic",
                "Procedure": "The test shuts and unshuts bundle interfaces to verify that traffic is flowing. It checks two main points: first, that the bundle members are properly shutting and unshutting; second, that data is being transmitted through the interfaces under both IS-IS/IPv4 and IPv6 configurations.\n\nThis test is triggered by Traffic Configuration: ISIS/IPv4/IPv6",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nBundle qos verify verification is performed.\nNoshut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shut noshut bundle with traffic on peers",
                "Procedure": "When shutting and then unshutting peer bundle interfaces, verify that traffic is indeed flowing between routers. This test verifies two main scenarios: first, it checks that a bundle can be shut down and then brought back online without disrupting traffic flow; second, it ensures that once the bundle is restored, traffic resumes as expected. \n\nThis test is triggered by ISIS/IPv4/IPv6 traffic configurations.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle and member shut noshut",
                "Procedure": "This test checks that a bundle comes online after a flap and a member comes online after a flap, both on the Under Test (UUT) node and the peer node. We're not testing convergence here. The test verifies that the 'show bundle' command displays the expected output for the specified <bundle>, and it uses an ISIS/IPv4/IPv6 traffic configuration.\n\nThis test is triggered by: Verify show bundle <bundle> output Configuration: ISIS/IPv4/IPv6 Traffic",
                "Pass/Fail Criteria": "Bundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add subinterface on bundle check aib process crash",
                "Procedure": "The CFD (Configuration Fault Detection) CSCwd05142 requires a new feature, where a sub-interface is added to the bundle and monitored for any process crashes. This test verifies two main aspects: firstly, it checks the output of the show bundle command on a specified bundle, and secondly, it confirms that the show context display is correct. The configuration being tested includes ISIS/IPv4/IPv6 traffic. This test is triggered by adding new sub-interfaces to bundles in a single commit.",
                "Pass/Fail Criteria": "Context verification is performed.\nBundle ether verification is performed.\nSet unicast source verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Change bundle id on members",
                "Procedure": "To test a change in the bundle ID for members, we check that moving members from one bundle to another results in an operational bundle with flowing traffic. The test also verifies traffic stats are correctly configured.\n\nThis test is triggered by changes to the bundle ID configuration for members under ISIS/IPv4/IPV6 traffic scenarios.",
                "Pass/Fail Criteria": "Pid verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nIpv4 ipv6 ping verification is performed.\nTraffic stats verification is performed.\nAcl verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nGlobal id verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "One member l3 l2 bundle and add other lc member",
                "Procedure": "A Layer 3 bundle is created with one member and one Layer 2 bundle sub-interface with the default encapsulation. The test verifies that Layer 2 traffic flows normally over this configuration. When a member is added or removed from another Line Card, the Layer 2 traffic is still functional.\n\nThis test is triggered by adding or removing a member from an LC other than the one in the L3 bundle.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nIsis neighbors verification is performed.\nIsis routes verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "One member l3 l2 bundle and add remove member",
                "Procedure": "A L3 bundle is brought up with one member and an L2 bundle sub-interface is created with the default encapsulation. L2 traffic flows normally, but when members are added or removed from the bundle, the flow of L2 traffic remains unaffected by these changes.\n\nThis test is triggered by verifying L2 traffic behavior on a bundle after adding or removing members.",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nIsis routes verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nBundle brief verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lc reload traffic verification on unaffected lc",
                "Procedure": "This test verifies that when a line card (LC) is reloaded in a slot where no members of bundles BE1 and BE5 are present, there is no loss of data traffic for those bundles. To accomplish this, the following steps are taken: check whether the unit under test has a modular LC with sufficient links to peer routers; if not, skip the test; identify the LCx being reloaded; shut down its links for BE1 and BE5; restart traffic; reload LC-x; wait for it to come online; once it's up, stop traffic; measure traffic loss, which should be zero; and finally restore the shutdown links.\n\nThis test is triggered by a change to a line card that does not have active members of bundles BE1 and BE5.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Simultaneous noshut on bundle and physical interfaces",
                "Procedure": "The test simultaneously shut off and then unshut a bundle, as well as all its physical interfaces, multiple times. It also checked the status of these interfaces to ensure they were up and functioning properly, and verified that traffic was still flowing through them.\n\nThis test is triggered by ISIS/IPv4/IPv6 Traffic configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vlan id change",
                "Procedure": "This test verifies that a change to the VLAN ID on both the Under Test (UUT) and Peer Equipment (PEER) devices results in an operational bundle with continuous traffic flow, utilizing configurations including ISIS routing protocol, IPv6 addressing, and IPv4 addressing.\n\nThis test is triggered by changing the VLAN ID on both the UUT and PEER.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nAcl verification is performed.\nBundle bringup with lacp verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vlan id negative test",
                "Procedure": "The test verifies that changing the VLAN ID on a device under test (UUT) has no impact on the operation of a bundle, such as causing a loss of traffic. This test is triggered by setting the VLAN ID on the UUT to an invalid value, while leaving all other configuration settings unchanged.",
                "Pass/Fail Criteria": "Vlan id change verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bulk removal of vlans",
                "Procedure": "The bulk removal of VLANs is tested to ensure that all VLANs are removed from a bundle in a single commit. The test also verifies that the bundle remains operational and traffic continues to flow after the removal.\n\nThis test is triggered by the configuration of ISIS, IPv6, and IPv4 traffic.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Convert bundle to physical",
                "Procedure": "This test is triggered by taking a bundle member out of the bundle, assigning an IP address to both the UUT and the peer, verifying that the bundle brings up successfully with IS-IS enabled on all protocols (IPv6 and IPv4), and then observing network traffic.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nCef prefix verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Static and allocated mac address",
                "Procedure": "This test verifies that a MAC address can be configured on a bundle, that the new MAC address appears in the output of certain commands, and that the bundle remains operational and allows traffic to flow. It also checks that basic bundle functions are working correctly. To trigger this test, verify that it is triggered by configuring a static MAC address on a bundle.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nInterface detail verification is performed.\nBundle ether verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove all bundle ip addresses on uut",
                "Procedure": "The test \"test_add_remove_all_bundle_ip_addresses_on_uut\" involves adding and removing all bundle IP addresses, both IPv4 and IPv6, while maintaining a steady stream of traffic. It checks two main aspects: first, that the addition or removal of Bundle addresses for IPv4 and IPv6 does not disrupt the flow of traffic; second, that traffic configured to use ISIS/IPv4/IPv6 protocols can continue to flow through bundles despite these changes.\n\nThis test is triggered by verifying the configuration of traffic.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nBundle qos verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove all bundle ip addresses on peers",
                "Procedure": "When adding or removing all bundle IP addresses (both IPv4 and IPv6), we should still allow traffic to flow. This test verifies that we can add and remove Bundle ipv4/ipv6 addresses while traffic continues to flow through the bundles, as well as check whether traffic configurations for ISIS, IPv4, and IPv6 work properly. \n\nThis test is triggered by traffic flows with bundle IP addresses being added or removed.",
                "Pass/Fail Criteria": "Add remove all bundle ip addresses on uut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove members when bundle shut",
                "Procedure": "When the bundle is in a shutdown state, this test checks that bundle member addition and deletion are still possible. It specifically looks at how these operations behave during this time, verifying that they complete successfully. This test is triggered by the presence of a bundle that is set to be shut down, with instructions to add and remove members from it.",
                "Pass/Fail Criteria": "Bundle ether verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove member l2 bundle",
                "Procedure": "The test for adding or removing a bundle member on an L2 bundle verifies that the following conditions are met when performing such operations: bringing up the L2 Bundle and performing add/remove bundle member operation, as well as verifying traffic checks. The configuration involves bringing up the L2 Bundle and routed interface BVI, creating an L2 bridge-domain in the UUT, setting a static MAC on the BVI interface, and using an LACP short timer.\n\nThis test is triggered by initiating an L2 bundle add/remove bundle member operation.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nGlobal id verification is performed.\nIsis neighbors verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nBundle hashing range verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp timeout and transition",
                "Procedure": "The test aims to validate two new fields in the output of the 'show lacp counter bundle-ether<id>' command. The configuration involves removing and adding a bundle member on a peer node, causing LACP timeouts and transitions. Initially, a single bundle (BE3) is considered on the UUT, and its initial LACP transition value is recorded. One member is then removed from BE3 on the peer node, and the system waits for three consecutive LACP misses to occur, or 90 seconds to pass (three times the default 30-second interval). The router's timestamp and the CLI output of 'show lacp counter Bundle-Ether3' are taken, including two new fields: the increased LACP Transition value and the Last LACP Transition time in Ephoc format. This time is converted back to a router timestamp and compared with the initial timestamp; if they match and the timeout transition has increased, further testing proceeds. A removed member is added back to BE3 on the peer node, causing another change in the LACP transition value and timeout. The process is repeated with multiple members. Standard bundle ping and traffic checks are also performed before closing out the test.\n\nThis test is triggered by a configuration that involves removing and adding members from a bundle, which causes LACP timeouts and transitions to occur on the system under test.",
                "Pass/Fail Criteria": "Ucs reachability verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lacp timeout and transition telemetry gnmi client",
                "Procedure": "The testcase aims to validate two new fields in the output of 'show lacp counter bundle-ether<id>' by using a GNMI client and streaming data from the router. Configuration involves removing and adding bundle members on the peer node. To test this, we start with one Bundle (BE3) on the UUT and take note of its initial LACP transition value. We then remove one member from BE3 on the peer node and wait for three consecutive LACP misses to occur (default interval is 30 seconds), recording the router timestamp during this time. With a GNMI connection in ONCE mode, we collect two new fields: LACP Transition, which should increase from its initial value, and Last LACP Transition, displayed in Ephoc time format. We convert the Ephoc time to the router's timestamp and compare it with our recorded value; if they match and the transition has increased as expected, we proceed. Next, we add the removed member back to BE3 and repeat this process for another member. Standard bundle ping and traffic checks are also performed during this testing.\n\nThis test is triggered by configuring a Bundle member to be removed and added on the peer node.",
                "Pass/Fail Criteria": "Bundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Interface microflap",
                "Procedure": "The Microflap test aims to simulate micro flaps using a debug shell script. This test is triggered by having bundles and traffic running on the UUT, with one Bundle (BE3) and one of its members active. To perform the test, start by considering the specified member; then, initiate continuous member flapping for a defined number of iterations while simultaneously verifying the bundle and member states. Once the required iterations have been completed, stop the traffic, restart it, and confirm that there is no packet loss.",
                "Pass/Fail Criteria": "Ucs reachability verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove one member with traffic over line rate",
                "Procedure": "This test is triggered by adding and removing one bundle member to measure the resulting impact on traffic.\n\nThe test verifies that there's a significant traffic loss when just one bundle member is taken out of commission, which suggests a problem with the configuration, specifically in this case ISIS/IPv4/IPv6.",
                "Pass/Fail Criteria": "Add remove one member with traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shut no shut one member sequential with line rate",
                "Procedure": "On a device with multiple LACP bundles, randomly select one of them. Disable all its members in sequence while still allowing traffic to flow, leaving at least one active member intact. Then re-enable the members one by one. This test is triggered by verifying that bundle members can be shut or no-shut without disrupting traffic and ensuring network configurations are set for ISIS, IPv4, and IPv6 traffic.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ndevices: \"['R1']\" and \"['R2']\" and \"['R3']\"",
                "Pass/Fail Criteria": "Shut no shut one member sequential on uut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2bundle multicast traffic linerate 100ms",
                "Procedure": "A test is performed to verify the following conditions: A Layer 2 bundle main interface is brought up with a Bridge-Verticle Interface (BVI). The LACP short timer is configured to be 100 milliseconds. Line rate traffic, which can be passed from an input file, is kept constant. Next, the test verifies that Layer 2 multicast traffic functions correctly for a given duration when using a Layer 2 VPN Bridged Domain. Additionally, it checks that there are no bundle or member flap occurrences and that there are no LACP flaps on bundle members. After this, the configuration is restored to its original state, followed by standard verification and closure procedures. This test is triggered by creating a Layer 2 bundle with line rate traffic and configuring an LACP timer of 100 milliseconds.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp traffic with bundles",
                "Procedure": "The test case verifies two key aspects of a network device's configuration. First, it checks that Multiprotocol Label Switching (MPLS) label distribution protocol (LDPS) bindings are established between the Under Test (UUT) and its peers. Second, it ensures that MPLS traffic is properly handled through interface accounting and load balancing using bundles. The test assumes a network configuration based on IS-IS with IPv4 traffic.\n\nThis test is triggered by an IS-IS/IPv4 traffic scenario configuration.",
                "Pass/Fail Criteria": "Mpls ldp neighbor brief verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp shut no shut with bundles",
                "Procedure": "This test case verifies that MPLS LDP bindings are established correctly between the Unit Under Test (UUT) and its peers, and that it can forward MPLS traffic through interface accounting and across bundles, all while using an IS-IS/IPv4 configuration.\n\nThis test is triggered by a specific set of configuration settings.",
                "Pass/Fail Criteria": "Mpls ldp neighbor brief verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls static with single label",
                "Procedure": "MPLS static configuration is verified with one label traffic by setting up a network between PEER1, UUT, and PEER2. The setup involves configuring MPLS static between these three devices to allow traffic to flow across them. This test case requires the configuration of mpls-ipv4 headers.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls to ip",
                "Procedure": "MPLS to IP conversion is verified through a test case that configures MPLS static routing on PEER1 with the option to pop the incoming label. The test then verifies that MPLS traffic flows from TGEN to PEER1 and is later converted to IP. \n\nThis test is triggered by a configuration involving mpls-ipv4 headers.",
                "Pass/Fail Criteria": "Mpls static with single label verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Xcare bundle",
                "Procedure": "Running the Xcare bundle triggers a series of tests, which verify three key aspects: NSF (Non-Stop Forwarding) functionality with Xcare Triggers enabled, correct operation of the bundle interfaces, and proper traffic configuration, including both IPv4 and IPv6 protocols over an ISIS network.\n\nThis test is triggered by running the Xcare bundle.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nscenario: \"BundleApBase.get_xcare_testcases(Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Commit rollback replace",
                "Procedure": "This text describes a test that involves committing, replacing, and rolling back configuration settings in a system that supports Network Service Function (NSF) chaining. The test verifies three key aspects: NSF operation with commit and rollback replace, the behavior of bundle interfaces, and network traffic patterns under different configurations. The test is applied to systems configured for ISIS routing over IPv4 and IPv6 networks. This test is triggered by committing a replace operation and then rolling back to verify the correct functionality of all involved components.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Remove bundle rollback",
                "Procedure": "This test is triggered by verifying that an NSF (Non-Stop Forwarding) configuration, including commit and rollback operations, works correctly for a bundle interface under various traffic conditions using both IPv4 and IPv6 protocols.\n\nCommit a commit replace and rollback config. This test verifies the following: - Verify NSF with commit/rollback replace - Verify Bundle Interfaces - Verify Traffic  Configuration: ISIS/IPv4/IPv6 Traffic",
                "Pass/Fail Criteria": "Commit rollback replace verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Unconfig config bundle interfaces on uut",
                "Procedure": "The test test_unconfig_config_bundle_interfaces_on_uut involves disabling and re-enabling configuration on a unit under test (UUT) while traffic continues to flow. This includes verifying that network state failover (NSF) occurs correctly when the configuration is changed, checking that bundle interfaces are up and functioning with all members after repeated configuration changes, and ensuring that traffic flows properly for protocols such as ISIS/IPv4/IPv6.\n\nThis test is triggered by the unconfig_config_bundle_interfaces_on_uut test.",
                "Pass/Fail Criteria": "Cef prefix verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Unconfig config bundle interfaces on peers",
                "Procedure": "Unconfig and config all bundles on peers while traffic flows. The test verifies that Neighbor Synchronization Function (NSF) works properly during the process, bundle interfaces remain up with all members even after multiple unconfig/config operations, and traffic remains configured correctly for both ISIS, IPv4, and IPv6.\n\nThis test is triggered by the configuration change event when the system is in NSF-capable state.",
                "Pass/Fail Criteria": "Unconfig config bundle interfaces on uut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process triggers",
                "Procedure": "When you restart or crash the bundlemgr process, it should be automatically re-started and data transfer should continue uninterrupted. The test also checks that traffic stats and interface stats are being recorded correctly. This test is triggered by restarting or crashing the bundlemgr processes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"BundleApBase.process_names('test_process_triggers/processes', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Router reload",
                "Procedure": "When a router is reloaded, it should be able to recover its previous state while maintaining normal traffic flow. This test does a complete router reload, checks the interface states before and after the reload, and verifies that traffic flows are uninterrupted. This test is triggered by ISIS/IPv4 configuration changes.",
                "Pass/Fail Criteria": "Show interfaces summary verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nDpa objects global verification is performed.\nGlobal id verification is performed.\nInterface brief verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Issu system upgrade",
                "Procedure": "The test of ISSU operation verifies that the Bundlemembers are in the correct status before and after the trigger, and also includes ISSU verification and traffic verification. It is configured with ISIS/IPv4 traffic, common setup configurations, a mention of issu_image_path in the input file, which should contain the ISO and all required RPMs, and the types of RPMs should match those of the build image.\n\nThis test is triggered by verifying that the Bundlemembers are in the correct status before the ISSU trigger.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Fabric card reload sequentially",
                "Procedure": "During the sequential fabric card reload, verification of bundles and traffic flows is checked after each reload to ensure everything remains functional. Fabric cards are reloaded one at a time while verifying that bundles are still active and traffic flows properly throughout the process.\n\nThis test is triggered by ISIS/IPv4 Traffic configuration.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lc reload with bundle configured",
                "Procedure": "This test verifies that when a reload is triggered for each line card, the bundle comes up correctly and traffic flows as expected. It does this by reloading each line card, verifying that the bundle brings up successfully, and checking to see if traffic is flowing. The configuration used in this test includes OSPF and both IPv4 and IPv6 traffic.\n\nThis test is triggered by the test_lc_reload_with_bundle_configured test case.",
                "Pass/Fail Criteria": "Show interfaces summary verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nInterface brief verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Master sc reload with bundle configured",
                "Procedure": "This test checks that a reload of the master switch controller works correctly, including bringing up bundles and allowing traffic to flow between routers configured with OSPF, IPv6, and IPv4 protocols. This test is triggered by reloading the Master SC on the router while it's running a bundle configuration.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Slave sc reload with bundle configured",
                "Procedure": "This test verifies the functionality of reloading a slave switch controller on a router, bringing up a bundle, and sending traffic while using an OSPF/IPv6/IPv4 configuration. This test is triggered by the presence of specific configuration settings.\n\nNote: I removed unnecessary words like 'test' from the beginning of the paragraph to make it sound more natural.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rp reload with bundle configured",
                "Procedure": "This test verifies that a router with only one Route Processor (RP) can reload its active RP, successfully brings up a bundle, and maintains network traffic while running OSPF and IPv4/IPv6 protocols. This test is triggered by the configuration of the OSPF/IPv6/IPv4 traffic on the router.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Standby rp reload with bundle configured",
                "Procedure": "This test is triggered by a test named \"test_standby_rp_reload_with_bundle_configured\". The test stands as a verification process for three main aspects: first, it reloads the Standby Router Port on a router; second, it checks to ensure that the bundle brings up properly; and third, it verifies that traffic can flow through the system. The configuration used in this test includes OSPF, IPv6, and IPv4 protocols.\n\nTrigger sentence:\nThis test is triggered by a test named \"test_standby_rp_reload_with_bundle_configured\".",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpa reload with bundle configured",
                "Procedure": "The test verifies that a router can reload its MPA card, properly configure a bundle, and maintain traffic functionality while using various network protocols such as OSPF, IPv6, and IPv4. This test is triggered by the specific scenario in which the MPA card needs to be reloaded with a bundle configured on the router.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpa shut noshut with bundle configured",
                "Procedure": "The test for a multi-path access (MPA) card with a configured bundle involves shutting down the Noshut MPA Card, verifying that the bundle brings up correctly, and checking if traffic flows properly over OSPF/IPv6/IPv4 connections.\n\nThis test is triggered by having an MPA card on the router and a bundle configuration in place.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle bringup with rpfo",
                "Procedure": "This test is triggered by a configuration of ISIS/IPv6/IPv4 traffic. It verifies the functionality of bundle bringup and that routing policy forwarding options are performed correctly in this specific scenario.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nAcl verification is performed.\nGlobal id verification is performed.\nEthernet hardware status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lc reload with hqos",
                "Procedure": "The test verifies consideration for data traffic in bundles and physical links by shutting down all links on LC-x, restarting traffic, reloading LC-x, waiting for it to come up, measuring zero traffic loss, and restoring the shutdown links. This test is triggered by the condition that LC-x does not have any active members of BE1 and BE5.",
                "Pass/Fail Criteria": "Lc reload traffic verification on unaffected lc verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under ospf",
                "Procedure": "Configuring bundles under OSPF ensures that traffic flows smoothly across all bundles. The verification process checks two key aspects: first, it confirms that the bundle interfaces are functioning properly and that all members are active; second, it verifies that traffic is being transmitted according to the specified configuration, which includes OSPF for both IPv4 and IPv6 networks.\n\nThis test is triggered by the need to verify Bundle Interfaces are up with all members.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nOspf neighbors verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap bundle under ospf",
                "Procedure": "The test_bundle_under_ospf_shut_no_shut verifies that configuration bundles under OSPF are functioning correctly. It ensures that traffic flows on all bundles by shutting down and then re-enabling them. This involves verifying two key aspects: first, that the bundle interfaces have come up with all members participating in the bundle; second, that traffic is flowing as expected through the configured routes for both IPv4 and IPv6 OSPF traffic.\n\nThis test is triggered by a change to OSPF routing configuration or interface status.",
                "Pass/Fail Criteria": "Bundle under ospf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Remove bundle interfaces under ospf",
                "Procedure": "This test removes bundle interfaces under OSPF, configures bundles under OSPF, verifies that traffic flows on all physical interfaces, and then reverts the changes. It checks two conditions: first, that bundle interfaces are up with all members; second, that traffic configurations for OSPF/IPv4 and OSPF/IPv6 are correctly implemented.\n\nTrigger sentence:\nThis test is triggered by removing bundle interfaces under OSPF.",
                "Pass/Fail Criteria": "Bundle under ospf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Unconfig reconfig ip with bundle under ospf",
                "Procedure": "Configuring bundles under OSPF, this test ensures that traffic flows through all bundles after unconfiguring and reconfiguring L3. It checks for several key conditions, including the status of bundle interfaces and the presence of all members, as well as verifying successful transmission of OSPF/IPv4/IPv6 traffic.\n\nThis test is triggered by configuring bundles under OSPF.",
                "Pass/Fail Criteria": "Bundle under ospf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shut no shut bundle and physical interfaces serial",
                "Procedure": "The test for shutting down bundle and physical interfaces serial configurations involves several steps. The test first configures bundles under OSPF and checks that traffic flows on all unshut interfaces, then shuts down all shut interfaces and verifies the flow of traffic again. This test is triggered by verifying that bundle interfaces are up with all members, as well as checking traffic configuration for OSPF, IPv4, and IPv6 protocols.",
                "Pass/Fail Criteria": "Bundle under ospf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Assign ip to bundle members and revert",
                "Procedure": "Config bundles under OSPF and verify that the traffic flows on all bundle members with IP addresses. The test also checks that bundle interfaces are up and functioning for all members, and that IPv4 and IPv6 traffic is properly configured.\n\nThis test is triggered by verifying OSPF/IPv4/IPv6 traffic configuration.",
                "Pass/Fail Criteria": "Bundle under ospf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with bgp",
                "Procedure": "The test test_bundle_with_bgp verifies that traffic flows correctly, with a configuration that includes both IPv4 and IPv6 routes using the Border Gateway Protocol (BGP). \n\nThis test is triggered by verifying that traffic flows.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nIsis neighbors verification is performed.\nBgp sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under bgp local shut physical and bundle",
                "Procedure": "The test, \"test_bundle_under_bgp_local_shut_physical_and_bundle\", checks that traffic continues to flow through a bundle when the physical connection is shut down. It specifically tests whether the configuration, which includes both IPv4 and IPv6 BGP protocols, still allows traffic to pass through. This test is triggered by verifying that traffic flows continue as expected.\n\nRewritten trigger sentence: \nThis test verifies that traffic continues to flow under specific conditions.",
                "Pass/Fail Criteria": "Bundle with bgp verification is performed.\nIsis neighbors verification is performed.\nBgp sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under bgp local shut bundles",
                "Procedure": "BGP is configured to handle both IPv4 and IPv6 traffic flows when a bundle is shut down.\n\nThis test is triggered by the event of an interface becoming administratively shut down.",
                "Pass/Fail Criteria": "Bundle with bgp verification is performed.\nIsis neighbors verification is performed.\nBgp sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under bgp remote shut physical and bundle",
                "Procedure": "This paragraph cannot be written without more text to rework. The provided snippet is just a single line and does not contain enough information to create a cohesive, sentence-long paragraph. However, assuming that the missing lines from the test (such as \"This test is triggered by\") could provide necessary context for creating such a paragraph, we can only assume what the text might look like with additional details.\n\nFor the purpose of this exercise, let's focus on providing a clear trigger statement based on the given snippet. Given that, the rewritten trigger line would be:\n\nThis test verifies traffic flows over BGP/v4 and v6 configurations when there are issues with physical connectivity.",
                "Pass/Fail Criteria": "Bundle under bgp local shut physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under bgp remote shut bundles",
                "Procedure": "This test is triggered by traffic flowing between two bundles configured under BGP remote shutdown. It checks that the traffic can flow correctly through the network, verifying that configuration for BGP version four and six traffic is set up properly. \n\nThe trigger sentence was rewritten as follows:\n\n This test is triggered by traffic flowing between two bundles configured under BGP remote shutdown.",
                "Pass/Fail Criteria": "Bundle under bgp local shut bundles verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under bgp local shut bundle members",
                "Procedure": "The test_bundle_under_bgp_local_shut_bundle_members test verifies that traffic flows normally by checking the configuration of BGP for both v4 and v6 protocols. \n\nThis test is triggered when all members in a bundle are shut down under BGP local.",
                "Pass/Fail Criteria": "Bundle under bgp local shut physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under bgp remote shut bundle members",
                "Procedure": "The test verifies that traffic continues to flow when a bundle member is shut down remotely. This test is triggered by the configuration of BGP on IPv4 and IPv6 interfaces.",
                "Pass/Fail Criteria": "Bundle under bgp local shut physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under bgp local delete bundle members",
                "Procedure": "This test is triggered by a bundle under BGP local delete bundle members.\n\nA bundle under BGP configuration for IPv4 and IPv6 traffic verification involves checking that traffic flows as expected, ensuring the correctness of network configurations.",
                "Pass/Fail Criteria": "Bundle under bgp local shut physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under bgp remote delete bundle members",
                "Procedure": "The test_bundle_under_bgp_remote_delete_bundle_members test verifies that traffic flows properly after configuration changes to a BGP setup involving both v4 and v6 addresses.\n\nThis test is triggered by the creation of a bundle members under the remote delete condition.",
                "Pass/Fail Criteria": "Bundle under bgp local shut physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlans",
                "Procedure": "To configure bundle VLAN scaling and verify traffic flow, you should check the following. This test verifies that traffic stats are correct, interface stats are accurate, and configuration is set up correctly for ISIS/IPv4 traffic. \nThis test is triggered by a request to configure bundle vlan scale and verify traffic flow.",
                "Pass/Fail Criteria": "Cef and get max path interface list verification is performed.\nBundle bringup verification is performed.\nIsis neighbors verification is performed.\nIsis adjacency count verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan shut noshut peer",
                "Procedure": "The test_bundle_vlan_shut_noshut_peer test involves configuring a VLAN scale, inducing a flap on the peer's side, and verifying that traffic continues to flow. It checks two key aspects: first, it verifies the traffic statistics to ensure there are no issues with data exchange; second, it examines interface statistics to gauge any potential problems in the connection. This test is triggered by configuring ISIS/IPv4 traffic.",
                "Pass/Fail Criteria": "Bundle vlans verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan shut noshut uut",
                "Procedure": "To configure bundle VLAN scaling, a flap is performed on the UUT's side to simulate real-world conditions, and then traffic flow is verified. The test also checks for proper traffic statistics and interface statistics. This test is triggered by the configuration of ISIS/IPv4 traffic.",
                "Pass/Fail Criteria": "Bundle vlan shut noshut peer verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan bulk removal peer",
                "Procedure": "The test for removing a bundle VLAN in bulk configures the bundle VLAN scale, performs a bulk unconfiguration of VLANs on the peer side, and then verifies that there's no disruption to traffic flow. The test also checks that traffic stats and interface stats are unaffected by this change. This test is triggered by an ISIS/IPv4 traffic configuration scenario.",
                "Pass/Fail Criteria": "Bundle vlans verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan bulk removal uut",
                "Procedure": "The test \"test_bundle_vlan_bulk_removal_uut\" involves configuring a bundle VLAN scale, performing a bulk VLAN unconfiguration on the UUT side, and verifying that traffic flow is maintained. This is done to verify two key aspects: first, that traffic statistics are accurate; second, that interface statistics are correct. The test's configuration includes running ISIS/IPv4 traffic.\n\nThis test is triggered by the need to validate the removal of multiple VLANs from a bundle on the Under Test (UUT) device.",
                "Pass/Fail Criteria": "Bundle vlan bulk removal peer verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan and physical unconfig config peers",
                "Procedure": "Unconfigure bundles, then configure them back on their peers, verifying that traffic flows as expected. This test is triggered by a configuration change involving ISIS and IPv4 traffic.",
                "Pass/Fail Criteria": "Bundle vlans verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan and physical unconfig config uut",
                "Procedure": "To ensure proper network functionality, this process involves unconfiguring bundles, reconfiguring them on peer devices, and verifying that traffic flows as expected. The verification process includes checking for accurate traffic statistics and interface status data. This test is triggered by the configuration of ISIS and IPv4 traffic.",
                "Pass/Fail Criteria": "Bundle vlan and physical unconfig config peers verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan and physical unconfig rollback peers",
                "Procedure": "The test, \"test_bundle_vlan_and_physical_unconfig_rollback_peers\", involves unconfiguring bundles, rolling back changes, and verifying traffic flow. It aims to verify two key aspects: the accuracy of traffic statistics and interface statistics. The configuration for this test includes IS-IS and IPv4 traffic. This test is triggered by verifying that Traffic Stats and Interfaces Stats are accurate.",
                "Pass/Fail Criteria": "Bundle vlan and physical unconfig config peers verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan and physical unconfig rollback uut",
                "Procedure": "The test Bundle VLAN and Physical Unconfig Rollback UUT unconfigures bundles, rolls back configurations, and verifies traffic flow. The test verifies that traffic statistics are accurate and interface statistics are correct after the rollback. It is configured with IPv4 traffic using ISIS.\n\nThis test is triggered by verifying that a bundle's VLAN configuration has been properly rolled back to its original state, which in turn causes any associated physical interfaces to also be restored to their previous configurations.",
                "Pass/Fail Criteria": "Bundle vlan and physical unconfig config peers verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan swap encap id",
                "Procedure": "To configure bundle VLAN scaling, swap VLAN IDs among the VLANs, and confirm that traffic flows, this test must first verify traffic statistics and interface statistics. The configuration used for this test includes ISIS/IPv4 traffic. This test is triggered by the event of configuring bundle vlan scale, performing swapping of vlan id among the vlans and verifying traffic flow.",
                "Pass/Fail Criteria": "Bundle vlans verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan change encap id",
                "Procedure": "To configure bundle VLAN scale, perform a change in VLAN IDs across Vlans, and verify traffic flow, run this test. The test is triggered by configuring IS-IS/IPv4 traffic.\n\nThis test verifies the following:\n- Verify Traffic Stats\n- Verify Interfaces Stats \n\nConfiguration: ISIS/IPv4 Traffic",
                "Pass/Fail Criteria": "Bundle vlan swap encap id verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle vlan process triggers",
                "Procedure": "Restarting or crashing the bundle manager processes allows us to verify that they are successfully restarted and that network traffic continues to flow normally. We also need to ensure that this process is effective in triggering a response, as indicated by the following conditions: verifying the accuracy of traffic statistics and interface status. This test is triggered by configuration settings for ISIS/IPv4 traffic.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"BundleApBase.process_names('test_bundle_vlans/test_bundle_vlan_process_triggers/processes', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nBundle vlans verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Max mtu profile config per npu",
                "Procedure": "The test Max MTU Profile Config Per NPU is used to configure MTU profiles in Bundle sub interfaces to supported scale and verify ping check. It verifies that the maximum number of supported MTU profiles can be configured on a bundle sub interface, which requires different MTU configurations on each bundle sub interface per Network Processing Unit (NPU). This test is triggered by verifying that the maximum supported number of MTU profile can be configured or not on a bundle sub interfaces.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Bundle with bfd",
                "Procedure": "To configure bundles with BFD and verify traffic flow, this test verifies two key aspects: verifying traffic stats to ensure that data is being transmitted correctly, and verifying interface stats to check the performance of each network interface. The configuration for this test involves setting up OSPFv4 and OSPFv6 traffic.\n\nThis test is triggered by configuring bundles with BFD in order to verify their traffic flow.",
                "Pass/Fail Criteria": "Bfd session summary verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with remove add bfd",
                "Procedure": "To configure bundles with BFD and verify traffic flow, including the removal and addition of BFD. The test checks for two specific things: verifying traffic statistics and verifying interface statistics. This test is triggered by an OSPFv4/v6 traffic configuration.",
                "Pass/Fail Criteria": "Bfd session summary verification is performed.\nBundle bringup verification is performed.\nBundle with bfd verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with bfd and flapping interfaces",
                "Procedure": "A network is configured with a bundle that includes interfaces with BFD enabled, then verified to ensure that traffic flows correctly after adding or removing BFD. The test checks for proper functionality by verifying traffic and interface statistics. This test is triggered by configuring OSPFv4 or v6 routing on the network, along with traffic generation between bundle member links.",
                "Pass/Fail Criteria": "Bundle with bfd verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with bfd remove add bundle members",
                "Procedure": "The test checks configuration of bundles with BFD and verifies traffic flow by adding and removing bundle members. It involves verifying traffic statistics and interface statistics. The configuration used for this test includes OSPFv4 and OSPFv6 traffic.\n\nThis test is triggered by the presence of OSPFv4 and OSPFv6 traffic in the configuration.",
                "Pass/Fail Criteria": "Bundle with bfd verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with bfd remove add bundle ip",
                "Procedure": "The test involves configuring bundles that use BFD and verifying how traffic flows through them, specifically by removing and adding IP addresses. It checks two key aspects: the traffic statistics and the interface statistics. The configuration required for this test includes OSPFv4 and OSPFv6 traffic.\n\nThis test is triggered by the removal and addition of an IP address to a bundle that uses BFD.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle with bfd verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with bfd change and revert bundle ip",
                "Procedure": "This paragraph is not provided. Please provide the original text, and I'll be happy to assist you in rewriting it into a single natural-sounding paragraph with the rewritten trigger sentence at the end.\n\nHowever, based on your description, here's an example of what the result might look like:\n\nThe test involves configuring bundles with BFD (Bidirectional Forwarding Detection) enabled and then verifying that traffic flows as expected when the bundle IP address is changed or reverted. The test aims to verify two key aspects: Traffic Stats and Interface Stats. OSPFv4/v6 traffic will be used in this configuration.\n\nAnd here's the rewritten trigger sentence:\nThis test is triggered by configuring bundles with BFD (Bidirectional Forwarding Detection) enabled and then verifying that traffic flows as expected when the bundle IP address is changed or reverted.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nBundle with bfd verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under static routing",
                "Procedure": "The test_bundle_under_static_routing test configures bundles under static routing and verifies that traffic flows through all of them. It includes two main verification points: first, verifying that bundle interfaces are up and operational on all devices; second, confirming that the configured OSPF protocol with IPv4 and IPv6 traffic is functioning as expected.\n\nThis test is triggered by configuration changes that affect traffic flow within bundles under static routing conditions.",
                "Pass/Fail Criteria": "Ipv4 ipv6 ping static verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under static routing remove add static",
                "Procedure": "Bundles are configured with static routing, and traffic flow is verified with both remove and add static routing. The verification process checks for correct traffic statistics and interface statistics. This test is triggered by the configuration of OSPF IPv4 and IPv6 traffic.",
                "Pass/Fail Criteria": "Ipv4 ipv6 ping static verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under static routing unconfig reconfig ip uut",
                "Procedure": "The test_bundle_under_static_routing_unconfig_reconfig_ip_uut configuration bundle is tested under static routing conditions. The test verifies that all bundle interfaces are up and functioning, with all member links operational, and that traffic flows through the bundles correctly when the L3 (Layer 3) unconfiguration and reconfiguration procedures are executed. This test is triggered by the need to confirm OSPF/IPv4/IPv6 traffic routing under static routing conditions.",
                "Pass/Fail Criteria": "Ipv4 ipv6 ping static verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under static routing unconfig reconfig ip peer",
                "Procedure": "Config bundles under static routing and verify that the traffic flows on all bundles with unconfigured or reconfigured L3 settings. This verification includes checking that bundle interfaces are operational with all their members, and that the specified network traffic configurations - specifically those for OSPF, IPv4, and IPv6 - are properly set up. This test is triggered by the creation of a test bundle under static routing with unconfig/reconfig L3 peer.",
                "Pass/Fail Criteria": "Bundle under static routing unconfig reconfig ip uut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle under static routing next hop negative testing",
                "Procedure": "Configuration of bundle interfaces with incorrect next-hop IP addresses under static routing is being tested. The test checks that all bundle interfaces have their members up and are passing traffic, and that the configuration uses OSPF and both IPv4 and IPv6 protocols. This test is triggered by configurations containing bundles under static routing but with an inaccurate next hop IP.",
                "Pass/Fail Criteria": "Ipv4 ipv6 ping static verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 l3 subifs add delete l2 l3 subinterfaces in one commit",
                "Procedure": "A test to configure multiple sub-interfaces at different layers of the OSI model simultaneously in a single commit, verify that all bundle interfaces are up and functioning properly, ensure that traffic is flowing correctly between network devices using IPv4 and IPv6 protocols over an Ethernet link with ISIS routing protocol enabled.\n\nThis test is triggered by verifying Bundle Interfaces are up with all members.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nIpv4 ipv6 ping verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 l3 subifs add l2 l3 subinterfaces while bundle down",
                "Procedure": "When testing a bundle that includes L2 and L3 subinterfaces, verify that the bundle interfaces come up with all members even when the affected bundle is down. Verify that traffic configuration settings for Ethernet, ISIS, IPv4, and IPv6 are present. This test is triggered by the command \"test_bundle_with_l2_l3_subifs_add_l2_l3_subinterfaces_while_bundle_down\".",
                "Pass/Fail Criteria": "Bundle with l2 l3 subifs add delete l2 l3 subinterfaces in one commit verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 l3 subifs shut noshut members",
                "Procedure": "The test involves bundling interfaces with L2 and L3 sub-interfaces, shutting down some members of the bundle while leaving others active, and then reversing this process. This test is triggered by verifying that all members of the bundle are up with their respective interfaces configured properly, as well as testing traffic configuration for Ethernet, ISIS, IPv4, and IPv6 protocols.",
                "Pass/Fail Criteria": "Bundle with l2 l3 subifs add delete l2 l3 subinterfaces in one commit verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 l3 subifs process triggers",
                "Procedure": "To test the processing of bundles with L2 and L3 sub-interfaces, restart or crash the processes associated with these sub-interfaces, then verify that they are restarted and traffic continues to flow. This is triggered by a test that verifies two key areas: it checks traffic statistics and interface statistics. The configuration for this test includes Ethernet, ISIS, IPv4, and IPv6 traffic.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"BundleApBase.process_names('test_bundle_with_l2_l3_subifs/processes', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nBundle bringup verification is performed.\nBundle bringup with lacp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs shut noshut bundle with traffic",
                "Procedure": "A bundle with two subinterfaces is shut down, then unshut to allow traffic to flow. It should be possible to shut down one of the subinterfaces in this bundle while keeping the other active, so long as traffic configuration allows for it.\n\nThis test is triggered by verifying that a bundle member can operate normally despite changes to its traffic configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs shut noshut members",
                "Procedure": "This test bundles two Layer 2 subinterfaces together with shut and no-shut members, verifying that bundle interfaces come up with all members online and that the traffic configuration is set to support Layer 2 traffic.\n\nThis test is triggered by bundling two Layer 2 subinterfaces together with shut and no-shut members.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs scale process triggers",
                "Procedure": "When you restart or cause the bundlemgr processes to crash, they should automatically recover and start working again. Once this happens, check that traffic is flowing as expected. Also, verify that the \"Verify Traffic Stats\" and \"Verify Interfaces Stats\" functions are still available. This test is triggered by restarting/crashing the bundlemgr processes in a scenario with L2 subinterfaces configured for traffic.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"BundleApBase.process_names('test_bundle_with_L2_subifs_scale/processes', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs scale add remove one member with traffic",
                "Procedure": "A test checks the impact of adding and removing a single bundle member on traffic loss. It measures if there's any decrease in traffic when a single bundle member is taken out from the configuration that uses Layer 2 traffic.\n\nThis test is triggered by changing the L2 Traffic configuration to include or exclude a single bundle member, then measuring the resulting traffic loss.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs scale add remove member by bundle id on peer",
                "Procedure": "When a single bundle member is removed from the peer router, this test checks that there is traffic loss and verifies that the CLI shows no bundle ID.\n\nThis test is triggered by the removal of a single bundle member on a peer router with an L2 traffic configuration.",
                "Pass/Fail Criteria": "Bundle with l2 subifs scale add remove one member with traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs scale add remove member by no interface on uut",
                "Procedure": "When attempting to add or remove a bundle member through the CLI without an interface, a UUT's functionality is tested under certain conditions. This test verifies that traffic loss occurs when a single bundle member is removed on the router. To achieve this, a no interface command is issued for the specific bundle-member name using the CLI. The testing is performed with L2 Traffic configuration. This test is triggered by issuing a \"no interface <bundle-member-name>\" CLI command to remove a single bundle member from the UUT router.",
                "Pass/Fail Criteria": "Bundle with l2 subifs scale add remove one member with traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs scale add remove member by no interface on peer",
                "Procedure": "A test that adds and removes a bundle member via the CLI without using the \"no interface\" command on a peer device verifies the following: it causes a traffic loss when a single bundle member is removed from a peer router, which can be confirmed by issuing the no interface <bundle-member-name> cli command. The test environment includes L2 Traffic.\n\nThis test is triggered by the removal of a single bundle member using the CLI on a peer device.",
                "Pass/Fail Criteria": "Bundle with l2 subifs scale add remove one member with traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs scale lc reload with bundle configured",
                "Procedure": "Configure Bundle Reload each Local Control (LC) to verify that it reloads correctly, brings up the bundle, and allows traffic to pass through.\n\nThis test is triggered by configuring a bundle with Layer 2 traffic.",
                "Pass/Fail Criteria": "Show interfaces summary verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs scale bundle bringup with rpfo",
                "Procedure": "This test performs a bundle bring-up verification with RPFO functionality by sending L2 traffic through it.\n\nTriggered when an L2 traffic configuration is set.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle with l2 subifs scale commit rollback replace",
                "Procedure": "The test 'test_commit_rollback_replace' checks that committing, replacing, and rolling back configuration results in the expected behavior, specifically verifying that the Network Service Function (NSF) operates as intended with the commit/rollback replace process, that bundle interfaces are functioning correctly, and that traffic is flowing as it should. This test is triggered by a config that involves L2 traffic.",
                "Pass/Fail Criteria": "Bundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L3scale interface accounting",
                "Procedure": "The test verifies that a large number of L3 Bundle sub-interfaces can be configured on an XR router. This configuration involves setting up 1024 bundle l3 sub-interfaces on the router and verifying that data traffic, both IPv4 and IPv6, flows correctly over these interfaces. In addition to this base case, the test also checks that it is possible to configure up to 8k bundle l3 sub-interfaces if the configuration file contains specific changes.\n\nThis test is triggered by the creation of a configuration for L3 Bundle sub-interfaces with either 1024 or 8k interfaces, depending on the values specified in the input file.",
                "Pass/Fail Criteria": "Show interfaces summary verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L3scale interface accounting hqos",
                "Procedure": "The test verifies that a large number of L3 bundle sub-interfaces can be configured on an XR router with HQOS enabled, including up to 8k sub-interfaces if specified in the input file, and checks data traffic for both IPv4 and IPv6 on these interfaces.\n\nThis test is triggered by verifying that 1024 bundle l3 sub-interfaces are able to configure on a given XR router with HQOS enabled.",
                "Pass/Fail Criteria": "Show interfaces summary verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Config fwd viable on bundle",
                "Procedure": "The test checks the forwarding viable attribute on a bundle member link under default conditions after configuring and deconfiguring CLI forwarding-unviable under the bundle member for each iteration. It verifies that the default state is to allow forwarding, then configures the bundle member as unforwarding-viable, checks that it has been successfully set to not allow forwarding, unconfigures the bundle member as unforwarding-viable, and finally confirms that it reverts back to its original setting allowing forwarding. This test is triggered by configuring the forwarding-unviable attribute under a bundle member link.",
                "Pass/Fail Criteria": "Forwarding viable verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Config fwd viable on physical",
                "Procedure": "The test checks the forwarding viable attribute on a physical link after various configuration changes. It verifies that the default state is \"Forwarding Viable\" in three different scenarios: initially, after setting and then unsetting the \"forwarding-unviable\" configuration under the physical link. The test assumes a configuration of \"forwarding-unviable\" under the physical link.\n\nThis test is triggered by applying the 'forwarding-unviable' configuration under a physical link.",
                "Pass/Fail Criteria": "Forwarding viable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Fwd viable process restart",
                "Procedure": "To perform this test, you must first configure forwarding-unviable on one of the bundle members, then restart or crash the bundlemgr related processes. After triggering the issue, verify that the forwarding viable attribute is not set and check the traffic stats as well as interface stats to confirm that traffic is being forwarded incorrectly.\n\nThis test is triggered by configuring forwarding-unviable on a bundle member interface, restarting or crashing the associated bundlemgr processes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"BundleApBase.process_names('test_fwd_viable_process_restart/processes', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nForwarding viable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Fwd viable router reload",
                "Procedure": "When a forwarding-unviable configuration is applied to only one member of a bundle through the CLI, this situation triggers a router reload. The entire router is then reloaded and its state verified both before and after the reload process to ensure traffic flows as expected, while interface states are compared for any discrepancies following system restart.\n\nThis test is triggered by applying a forwarding-unviable configuration via the CLI to one member of a bundle.",
                "Pass/Fail Criteria": "Forwarding viable verification is performed.\nShow interfaces summary verification is performed.\nBundle bringup verification is performed.\nInterface brief verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Fwd viable rpfo",
                "Procedure": "Tests are run to verify that a router can perform route processor fault tolerance operations when forwarding is not viable. The system is set up so that forwarding is disabled on one of its links, then checks if RPFO works as expected by comparing interface states before and after the system is reloaded. This test is triggered by the presence of ISIS/IPv4 traffic in the configuration.",
                "Pass/Fail Criteria": "Forwarding viable verification is performed.\nTraffic verification is performed.\nTraffic loss duration verification is performed.\nBundle bringup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Fwd viable with bundle flap",
                "Procedure": "A test checks the forwarding viable attribute on a bundle member link in three scenarios: by default, after configuration and post-deconfiguration of CLI forwarding-unviable under the bundle member, and during bundle flapping. The test verifies that the Forwarding Viable state attribute is correctly set in each scenario. This test is triggered by configure forwarding-unviable under bundle member.",
                "Pass/Fail Criteria": "Forwarding viable verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Fwd viable with member flap",
                "Procedure": "A test is performed to check the forwarding viable attribute on a bundle member link under default conditions, after configuring and deconfiguring CLI forwarding-unviable under the bundle member and inducing a flap on the member interface.\n\nThis test is triggered by configuration of \"forwarding-unviable\" under the bundle member.",
                "Pass/Fail Criteria": "Forwarding viable verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Fwd viable with member add remove",
                "Procedure": "A test checks the forwarding viable attribute on a bundle member link. It verifies this by first configuring forwarding as unavailable for the bundle member, then checking that the forwarding viable state attribute is correct. The interface is then flapped and checked again. After that, the forwarding configuration is removed from the bundle member, and the forwarding viable state attribute is checked once more to ensure it remains accurate. This test is triggered by a CLI command that sets forwarding as unviable under a bundle member.",
                "Pass/Fail Criteria": "Forwarding viable verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Config fwd viable on all members",
                "Procedure": "When configuring a bundle, this test ensures that the forwarding-viable attribute is set to 'unviable' for all its members and then checks that it reverts back to being viable. It does this by first setting the attribute to 'unviable', verifying that the 'Forwarding Viable state' attribute is indeed 'false', unconfiguring the attribute, and finally checking again that the 'Forwarding Viable state' attribute has returned to its original value of 'true'. This test is triggered by configuring forwarding-unviable under all members of a given bundle.",
                "Pass/Fail Criteria": "Bundle ether verification is performed.\nTraffic verification is performed.\nForwarding viable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale member flap",
                "Procedure": "The EFP scale member flap test verifies that a 40k bundle sub-interface scales correctly with multiple flap members on both the Under Test (UUT) and its peer. This involves checking the member state post-flap, ensuring that the bundle status is correct, and verifying the interface summary. \n\nThis test is triggered by: Configuration of 40k bundle sub-interfaces with scaled flap members.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale member remove add",
                "Procedure": "The test, \"test_efp_scale_member_remove_add,\" is used to verify that a device can correctly add and remove members from its scale feature. The test checks three key aspects of this process: the state of each member after being added or removed, the status of the bundle, and a summary of the interface configuration. This test is triggered by the presence of a 40k bundle with sub-interfaces that support scaling and can have members dynamically added and removed.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale bundle flap",
                "Procedure": "The test checks the bundle flap on the Undergoing Testing (UUT) unit, verifying several key aspects, including the member state post bundle flap, checking the bundle status, and confirming the interface summary. It relies on a specific configuration that involves 40k bundle sub-interfaces scaling and bundle flap functionality.\n\nThis test is triggered by configuration that involves 40k bundle sub-interfaces scaling and bundle flap functionality.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale bundle remove add",
                "Procedure": "The EFP (Ethernet Flow Point) Scale Bundle Remove Add test is used to validate the functionality of the bundle remove add feature on the Under Test (UUT). This test involves verifying three key aspects: member state post bundle remove add, checking the bundle status, and confirming that the interface summary is accurate. The configuration for this test includes 40k bundle sub-interfaces scaled up and the removal/addition of bundles.\n\nThis test is triggered by activating the EFP Scale Bundle Remove Add feature in the device's configuration with a specific scale factor and sub-interface count.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale router reload",
                "Procedure": "The test for reloading the EFP scale router checks that it can handle 40,000 L2 bundle sub-interfaces, verifies the status of those bundles, and ensures the interface summary is correct. The configuration involves a large number of bundle sub-interfaces at this scale.\n\nThis test is triggered by the need to verify the router's performance under heavy load, specifically with 40k L2 bundle sub-interfaces enabled.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale lc reload",
                "Procedure": "The test checks the Local Controller (LC) reload with a large number of Layer 2 bundle sub-interfaces, specifically 40,000. It verifies three key aspects: first, that the LC can successfully reload while these bundle sub-interfaces are present; second, that the bundle status is correctly maintained after the reload; and third, that the interface summary accurately reflects the state of all interfaces.\n\nThis test is triggered by a Configuration with 40k bundle sub-interfaces scaled.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale rpfo",
                "Procedure": "The test checks the functionality of RPFO with 40,000 Layer 2 bundle sub-interfaces by verifying that the bundle status is correct and the interface summary matches the expected values. The configuration used for this test involves scaling the number of bundle sub-interfaces to 40,000.\n\nThis test is triggered by a configuration change involving 40k bundle sub-interfaces scale.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale process restart",
                "Procedure": "The test for the EFP scale process restart involves performing multiple process restarts. It also checks the bundle status and verifies the interface summary. The configuration for this test includes a 40k bundle with sub-interfaces scaled.\n\nThis test is triggered by 40k bundle sub-interfaces scaling.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"BundleApBase.process_names('40k_efp_scale/processes_name', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale member shut add",
                "Procedure": "This paragraph checks for issues related to adding a member in a shutdown state within a specific type of network bundle. It verifies three key aspects: first, that members can be added successfully even when the system is shut down; second, that the status of the affected bundle remains unchanged; and third, that the interface summary reflects these changes correctly. This test is triggered by configuration related to member addition in shutdown state.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale no l2vpn",
                "Procedure": "The test checks for the removal and addition of L2VPN configuration. It verifies that the entire L2VPN configuration is removed, then rolled back to its previous state, checks the bundle status, confirms the interface summary, and ensures the l2vpn xconnect status is correct.\n\nThis test is triggered by the removal and addition of L2VPN config.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale no int be",
                "Procedure": "When this test is triggered, it removes and adds the entire bundle configuration. The test then checks that all the necessary actions have been performed, including removing the complete bundle configuration, rolling back the configuration to its previous state, checking the status of the bundle, and verifying a summary of the interfaces.\n\nThis test is triggered by: the user selecting the \"test_efp_scale_no_int_be\" option.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale add more than 40k per bundle",
                "Procedure": "This paragraph checks the 40,000 upper limit of L2 bundle sub-interfaces per bundle. It verifies that removing the entire bundle configuration, rolling back to the previous configuration, checking the bundle's status, and verifying the interface summary all work correctly. The test is triggered by any changes that add more than 40,000 kbps to a bundle's bandwidth.",
                "Pass/Fail Criteria": "L2scaled efp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale single tag member flap",
                "Procedure": "This test checks whether a single tag is displayed as a member of a bundle with scaled sub-interfaces, triggers when there is a change in the state of one of the member sub-interfaces. The test verifies that the member's post-flap state is recorded correctly, that the status of the 40k bundle is reported accurately, and that the interface summary reflects the change in the peer device.",
                "Pass/Fail Criteria": "L2scaled efp single tag verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale single tag member remove add",
                "Procedure": "The test for removing and adding a single tag member to the Universal Test Unit (UUT) checks several key functions. It verifies that after removing and adding a member, the post-remove and post-add state of the system is correct. Additionally, it checks the bundle status and ensures the interface summary is accurate. This test is triggered by the configuration of 40k bundle sub-interfaces scaled to remove and add members.",
                "Pass/Fail Criteria": "L2scaled efp single tag verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale single tag bundle flap",
                "Procedure": "This paragraph appears to be incomplete. However, based on the provided information, here is a rewritten version of the paragraph:\n\nThe UUT has been configured with 40K bundle sub-interfaces scaling and a bundle flap setting. This test verifies that the following components are functioning as expected: member state post bundle flap, check bundle status, and verify interface summary.\n\nThis test is triggered by a configuration where the UUT has 40k bundle sub-interfaces scale and a bundle flap set.",
                "Pass/Fail Criteria": "L2scaled efp single tag verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale single tag bundle remove add",
                "Procedure": "The test, which is triggered by this test being executed when a specific configuration is present, checks the functionality of the bundle remove add on the Unit Under Test (UUT) with a 40k bundle sub-interfaces scale.\n\nThis test is triggered by the presence of a 40k bundle sub-interfaces scale in the configuration.",
                "Pass/Fail Criteria": "L2scaled efp single tag verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale single tag process restart",
                "Procedure": "This test is triggered by a configuration change that involves scaling up to 40,000 bundle sub-interfaces. The test itself performs various process restarts in order to verify several key aspects of the system's behavior, including checking the status of bundles and validating the interface summary.\n\nNote: I removed the \"test_\" prefix from the original text as it is likely a test case or scenario name and not intended for inclusion in the rewritten paragraph.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"BundleApBase.process_names('40k_efp_scale_single_tag/processes_name', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "L2scaled efp single tag verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale single tag member shut add",
                "Procedure": "The test checks for member addition in a shutdown state within a 40k bundle sub-interface bundle. It also verifies the bundle's status and interface summary after adding members in this state.\n\nThis test is triggered by configuration involving member addition in shutdown state.",
                "Pass/Fail Criteria": "L2scaled efp single tag verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale single tag no l2vpn",
                "Procedure": "The test checks the removal and addition of L2VPN configuration. It verifies several aspects, including removing the entire L2VPN configuration, rolling back to a previous state by restoring the last saved configuration, checking the bundle status, summarizing interface information, and verifying the status of L2VPN cross-connections.\n\nThis test is triggered by testing the removal and addition of L2VPN configuration.",
                "Pass/Fail Criteria": "L2scaled efp single tag verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Efp scale single tag no int be",
                "Procedure": "This test checks that removing and adding a complete bundle configuration works correctly. It verifies several things happen in this process: the complete bundle config is removed, the rollback config for the last one is preserved, the bundle status is checked, and the interface summary is verified. Configuration: remove and add complete bundle config.\n\nThis test is triggered by removing and adding a complete bundle configuration.",
                "Pass/Fail Criteria": "L2scaled efp single tag verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L3scale with router reload",
                "Procedure": "This test verifies the ability to configure and manage large numbers of Layer 3 bundle sub-interfaces on an XR router, including verifying that up to 30,000 interfaces can be configured based on a given PID, and that changes to these configurations are properly applied when reloading the router.\n\nTriggered by this test is the verification that it can handle configuration changes in an input file containing numbers up to 30k.",
                "Pass/Fail Criteria": "L3 scale traffic verification is performed.\nShow interfaces summary verification is performed.\nInterface brief verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L3scale with lc reload",
                "Procedure": "The test verifies that an L3 Bundle sub-interface scale class is able to configure up to 30k or 8k bundle l3 sub-interfaces on a given XR router based on the PID, and that it can handle changes in the number of interfaces in the input file. It also checks that the configured sub-interfaces remain intact after an LC reload.\n\nThis test is triggered by verifying specific configurations for L3 Bundle sub-interfaces with 8k/30k settings.",
                "Pass/Fail Criteria": "L3 scale traffic verification is performed.\nShow interfaces summary verification is performed.\nInterface brief verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bundlemgr_ap_l2.py": {
        "test_cases": [
            {
                "Test Case Name": "Bundle basic verification",
                "Procedure": "This test verifies the basic bundle information and that it has an IS-IS neighbor configuration.\n\nTriggered by the 'test_bundle_basic_verification' bundle.",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nBundle ether verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle l2 with local xconnect",
                "Procedure": "The test \"test_bundle_l2_with_local_xconnect\" is designed to verify several key aspects of an L2VPN setup. Specifically, it checks that the local XConnect configuration is working correctly, that data is being transmitted successfully over the connection, and that the interface statistics for the XConnect members are accurate.\n\nThis test is triggered by a specific L2VPN XConnect configuration.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle l2 with vpls known unicast",
                "Procedure": "The test \"test_bundle_l2_with_vpls_known_unicast\" verifies several aspects of a configuration, including verifying the bridge domain status, checking that traffic is flowing correctly, and examining interface statistics as well as bridge-domain statistics. The test assumes a configuration with a bridge domain.\n\nThis test is triggered by the presence of a configuration containing a bridge domain.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nL2vpn bridge domain bd name detail verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle l2 with unknown unicast",
                "Procedure": "This test verifies that a bridge domain is properly configured and functioning by checking its status, allowing traffic to flow through it, and ensuring that interface statistics and bridge-domain statistics are accurate.\n\nThis test is triggered by the configuration of a bridge domain.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nL2vpn bridge domain bd name detail verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle l2 with multicast",
                "Procedure": "This test checks that a bridge domain is correctly configured. It verifies whether the bridge domain status, traffic flow, and interface statistics are as expected. The configuration for this test includes setting up a bridge domain.\n\nThis test is triggered by the 'test_bundle_l2_with_multicast' command.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nL2vpn bridge domain bd name detail verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle l2 with broadcast",
                "Procedure": "This test verifies that a bridge domain is functioning correctly by checking its status, sending traffic to test it's being forwarded, and examining the statistics for the interfaces and bridge domain.\n\nThis test is triggered by a configuration change.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nL2vpn bridge domain bd name detail verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle l2 with vpls bvi",
                "Procedure": "The test for a bundle of L2 connections to a VPLS network running in bridged mode verifies that the bridge domain functions correctly, including traffic flow and interface statistics.\n\nThis test is triggered by the configuration of a bridge-domain.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nL2vpn bridge domain bd name detail verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle l2 with vpws",
                "Procedure": "This test verifies that an L2VPN XConnect is set up correctly, including verifying traffic flow and interface statistics for its member connections.\n\nThis test is triggered by the configuration of a new L2VPN XConnect.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Member flap",
                "Procedure": "The test verifies that when there is only one member of a bundle in a traffic flow, the system correctly handles this configuration. The test involves using existing bundles and traffic flows to simulate this scenario.\n\nThis test is triggered by requiring exactly one member to be part of the bundle while also having active traffic flows involved.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Remove last member",
                "Procedure": "This test verifies that the removal of a member from a bundle does not cause any bugs, specifically CSCvw64829 and CSCvw47234. It is triggered by verifying that the configuration, which includes using existing bundles and traffic flows, can be reapplied after removing all bundle members and re-adding them without issue.\n\nTriggers: This test verifies bug #CSCvw64829 and bug #CSCvw47234 when removing a member from a bundle causes problems with existing configurations.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic loss duration verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "upgrade_downgrade_bundle_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Upgrade downgrade",
                "Procedure": "There is no configuration for this installation to be upgraded or downgraded.\n\nThis test is triggered by the need to install an upgrade or downgrade without any specific configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nupgrade_info: \"get_matrix.get_matrix_data(tc_name='test_upgrade_downgrade')\"\niteration: \"get_iterations()\"",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            }
        ]
    },
    "bng_ipoe_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Cnbng nal association",
                "Procedure": "The test for CP-UP Association (P0 TC) verifies the connection status after breaking connectivity to CP, restoring it, and configuring NAL configurations. It checks that the CP-UP association is UP before breaking the connection, which then goes down but remains associated within 3 heartbeats. The connection is restored, and the association is checked again to confirm it's UP. To simulate a loss of association, the test triggers the release of the association from the UP state. This involves removing the cnbng-nal configuration from the UP interface and reconfiguring it. Various configurations are applied during this process, including applying an ACL on the Mgmt Interface, removing it, unconfiguring cnBNG-NAL, and configuring it again.\n\nThis test is triggered by a series of configuration changes to the Management Interface.",
                "Pass/Fail Criteria": "Cp up association verification is performed.\ncnbng-nal association status CLI on UP verification is performed.\nshow peers CLI on CP verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Userplane offline",
                "Procedure": "The test of moving the user plane to offline mode in control plane (P0 TC) involves several steps. First, configure the control plane with a user-plane configuration, then configure the user plane with cnbng-nal configuration. Next, put the user plane into offline mode, removing its configuration from the control plane. The process is then reversed by reconfiguring the user plane in the control plane. Additionally, remove the cnbng-nal configuration from the user plane and reconfigure it.\n\nThis test is triggered by attempting to move the user-plane to OFFLINE mode in CP while a valid cnbng-nal configuration exists for the user-plane.",
                "Pass/Fail Criteria": "Cp up association verification is performed.\ncnbng-nal association status CLI on UP verification is performed.\nshow peers CLI on CP verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Teacat cnbng nal show cmds after csco supp group remove",
                "Procedure": "The test case checks whether CNBNG-NAL show commands function correctly after a Cisco-support group is removed from the user plane configuration. This test is triggered by removing the Cisco-support group from the user plane configuration, with the objective of verifying that the CNBNG-NAL show commands operate as expected.",
                "Pass/Fail Criteria": "cnbng-nal show commands work verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe default vrf",
                "Procedure": "The test covers the bring-up and bring-down of dual-stack subscriber sessions over a default VRF, specifically for IPoE connections. The test is triggered by running this method in a configuration where the input file specifies one or both of the following modes: \"radius\" or \"dynamic-template\". In this scenario, the test will simulate various methods of IPv4 address allocation through RADIUS using either Cisco AVPs or IETF attributes. It also covers several ways to configure CPE WAN interface IPv6 addresses, including IANA-managed addresses allocated through RADIUS or local dynamic templates. Additionally, it performs DHCPv6 prefix delegation and assigns various attributes from the RADIUS server in the access-accept message. The test runs bidirectional traffic for both IPv4 and IPv6 over IPoE connections, with the source address set to either the CPE WAN or LAN IPv6 addresses. Finally, the test verifies subscriber session and service accounting after bringing down the sessions.\n\nThis test is triggered by running this method in a configuration where the input file specifies one or both of the following modes: \"radius\" or \"dynamic-template\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration('configuration_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe non default vrf",
                "Procedure": "IPoE dual-stack subscriber sessions are brought up and brought down in non-default VRF (CNBNG and PBNG), as part of the test. This method takes in a list named configuration_mode, which includes \"radius\" and \"dynamic-template\", specified in an input file under 'testcase_configuration'. The test covers various methods of IPv4 address allocation, including through radius using cisco AVP \"addr-pool\", IETF AVP \"Framed-pool\", and addres+I3s pool referred locally in dynamic-template by cnBNG CP. It also covers different methods of CPE WAN interface IPv6 address configuration, such as IANA - Through radius using \"Stateful-IPv6-Address-Pool\" attribute or cisco avp \"stateful-ipv6-address-pool\", and IANA - Through dhcpv6 address pool referred locally in dynamic-template or server profile by cnBNG CP. Additionally, it performs DHCPv6 PD (only one prefix) over IPoE, covers various methods of prefix delegation through radius using attributes like \"Delegated-IPv6-Prefix\" and Delegated-IPv6-Prefix-Pool, and assigns attributes from radius in access-accept such as cisco avp \"primary-dns\" or \"Ascend-Client-Primary-DNS\". The test also runs bidirectional ipv4 traffic, runs bidirectional ipv6 traffic with source as CPE WAN IPv6 address and CPE LAN IPv6 address (derived from delegated prefix), brings down subscriber sessions, and verifies subscriber session and service accounting. The configuration for this test includes a dual stack IPoE subscriber in default VRF, spirent creating an IPoE client, traffic stream with ipv4 and ipv6 bidirectional traffic, and a radius user profile.\n\nThis test is triggered by the presence of \"radius\" or \"dynamic-template\" in the configuration_mode list specified under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration('configuration_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe subscriber interface packet verification",
                "Procedure": "The test involves sending subscriber interface input/output packets to bundle/Pwhe subinterface input/output packets (PBNG) to check for correct functionality. It tests the bring-up and bring-down of IPoE dual-stack subscriber sessions in non-default VRF, as specified in the input file under 'testcase_configuration'. The test runs bidirectional IPv6 traffic on a dual-stack IPoE subscriber in default VRF, created using a Spirent device generating an IPoE client. It verifies the subscriber and bundle subinterface input and output packets, as well as the subscriber session and service accounting. This test is triggered by running an ipv4 and ipv6 bidirectional traffic stream on a radius user profile configured with a dual stack IPoE subscriber in default VRF.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSubscriber and bundle subinterface input and output packets verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfd ipoe dhcp cos cscvv63713 cscwa39229",
                "Procedure": "When testing DHCP inner and outer cos values for CFD CSCvv63713 and CSCwa39229, it's essential to verify that the correct class of service (CoS) is applied to unicast packets over a pseudowire headend. This test is triggered by bringing up an IPv4 subscriber with specific configuration settings. The test involves capturing packets from Tshark while the subscriber is being brought online and verifying that the priority of those packets matches the inner CoS and outer CoS values configured for the subscriber. To set this up, a DHCP inner cos and outer cos must be configured along with a single stack IPoE subscriber in default VRF, utilizing Spirent to create an IPoE client, and including a radius user profile.",
                "Pass/Fail Criteria": "Pcap files verification is performed.\nSubscriber bringup verification verification is performed.\nInner and outer cos verification by capturing specific packets. verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe mls",
                "Procedure": "To test multiple loopbacks on dual-stack IPoE subscriber sessions, the following steps are taken: a dual stack IPoE subscriber is configured in both default and non-default VRFs, with 16 auto-loopbacks set up under each one. Multiple address ranges and loopbacks are also defined, before bringing up dual-stack IPoE subscriber sessions that distribute traffic between these two virtual routing and forwarding environments. Dynamic routes are then verified, along with the successful transmission of bidirectional IPv4 and IPv6 traffic streams. Once this is confirmed, the subscriber sessions are brought down, after which their session and service accounting status is checked. The configuration includes a Spirent device that creates an IPoE client, a traffic stream that generates bidirectional IPv4 and IPv6 traffic, and a RADIUS user profile.\n\nThis test is triggered by configuring a dual-stack IPoE subscriber in both default and non-default VRFs with 16 auto-loopbacks under each.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nAccounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nof dynamic routes for multiple loopbacks verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe mls churn",
                "Procedure": "The test checks how multiple dual-stack IPoE subscriber sessions bring up and bring down over 32 address pools with churn. It involves configuring 32 address pools, 32 default DHCP profiles, 32 subscriber profiles, 32 loopback interfaces, and setting up a dual-stack IPoE subscriber in distributed VRFs. Then, it simulates traffic for 75% of subscribers using Spirent to create an IPoE client and a traffic stream with bidirectional IPv4 and IPv6 traffic. The test also includes subscriber churn, route reconfiguration, and a final shutdown of the sessions.\n\nThis test is triggered by a change notification (CNBNG) process that requires testing over 32 address pools.",
                "Pass/Fail Criteria": "Get subscriber to verify verification is performed.\nSubscriber session details verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nof dynamic routes for multiple loopbacks verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nDynamic route verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe fca mls",
                "Procedure": "Dual-stack IPoE subscriber sessions are tested with multiple loopbacks, including a configuration that spans 32 address pools, default and non-default multiple loopbacks, default and non-default VRFs, and 32 default DHCP profiles. Subscriber sessions are brought up and verified for dynamic routes using bidirectional IPv4 and IPv6 traffic, then brought down. This test is triggered by configuring Spirent to create an IPoE client with a radius user profile that supports dual-stack IPoE in both default and non-default VRFs, along with a traffic stream of bidirectional IPv4 and IPv6 traffic.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nof dynamic routes for multiple loopbacks verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nDynamic route verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe multiple addr pool mls",
                "Procedure": "To test multiple loopbacks on dual-stack IPoE subscriber sessions, configure 32 address pools, four multiple loopbacks (default and non default), bring up 50% of subscribers in stage one. Add the remaining four multiple loopbacks to the final configuration and perform route reconfiguration. Bring up the remaining 50% of subscribers, verify dynamic routes, run bidirectional IPv4 traffic, run bidirectional IPv6 traffic, then bring down subscriber sessions.\n\nThis test is triggered by a Spirent setup that creates an IPoE client, generates dual-stack traffic streams (IPv4 and IPv6), and utilizes Radius user profiles in both default and non-default VRFs.",
                "Pass/Fail Criteria": "Cp up association verification is performed.\nSubscriber session details verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nof dynamic routes for multiple loopbacks verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nDynamic route verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe coa",
                "Procedure": "Dual-stack IPoE subscriber sessions, which include CNBNG and PBNG operations (P0 TC), are tested for test COA operations. This test is triggered by the requirement to perform account-status-query, Account-update, Activate-service, Deactivate-service, disconnect using a POD Disconnect Message, and verify subscriber session and service accounting on dual-stack IPoE sessions in default and non-default VRFs with bidirectional ipv4 and ipv6 traffic running from a Spirent-created IPoE client.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe bundle across lc",
                "Procedure": "Dual-stack IPoE subscriber sessions are tested over multi-member bundles across Line Cards (LC). This test is triggered by the configuration of a dual stack IPoE subscriber, utilizing Spirent to create an IPoE client, along with traffic streams that include bidirectional IPv4 and IPv6 traffic, as well as a RADIUS user profile. Configuration includes bringing up dual-stack IPoE subscriber sessions in both default and non-default Virtual Routing and Forwarding (VRF) instances, which are distributed across the LC. The test continues by running bidirectional IPv4 and IPv6 subscriber traffic, before finally shutting down the subscriber sessions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_members: \"ApData.zap.get_testcase_configuration('bundle_lc_members')\"",
                "Pass/Fail Criteria": "Across lc verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe bundle across np",
                "Procedure": "Dual-stack IPoE subscriber sessions are tested over a multi-member bundle across network processors (NPs) from the same location controller (LC). This test is triggered by configuring a bundle interface with two links across the NP from the same LC, bringing up dual-stack IPoE subscriber sessions in both default and non-default VRFs, running bidirectional IPv4 and IPv6 subscriber traffic, and then bringing down the subscriber sessions. The configuration involves a dual stack IPoE subscriber, a Spirent device creating an IPoE client, and a traffic stream generating bidirectional IPv4 and IPv6 traffic, as well as a RADIUS user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_members: \"ApData.zap.get_testcase_configuration('bundle_np_members')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe macoa",
                "Procedure": "To test the functionality of dual-stack IPoE subscriber sessions, we bring up dual-stack IPoE subscriber sessions distributed across both default and non-default VRFs. We then perform various combinations of CoA operations, including activating and deactivating services, and verify the outcome after each operation with traffic flowing through the session. Next, we disconnect the subscriber session using a POD (Disconnect Message) to test its impact on the subscription and service accounting. The configuration for this test includes dual-stack IPoE subscribers in both default and non-default VRFs, a Spirent device generating an IPoE client, and a traffic stream of both IPv4 and IPv6 bidirectional traffic with Radius user profiles.\n\nThis test is triggered by verifying the correct functioning of MA-CoA/POD operations on dual-stack IPoE subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack bundle addition deletion",
                "Procedure": "During testing of dual-stack IPoE subscriber sessions on a CNBNG system, the following operations are performed: Bring up IPoE subscriber sessions, then add new links in the same bundle where those sessions are coming online. Once all sessions are active, bidirectional IPv4 and IPv6 traffic is sent. The process is repeated with subscriber sessions being brought down, followed by removing a link from the bundle where those sessions are going offline, adding another link while those sessions are down, bringing up subscribers again while removing the first added link. This test is triggered by creating an IPoE client using spirent, and sending bidirectional traffic streams for both IPv4 and IPv6 through radius user profiles in default and non-default VRF configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_mode: \"ApData.zap.get_testcase_configuration('bundle_modification_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber disconnect count verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe dhcpv6 class",
                "Procedure": "The DHCPv6 class is tested with dual-stack IPoE subscriber sessions. This test is triggered by configuring a radius profile with a dhcpv6 class, performing a dual stack IPoE bringup, and then verifying the support of various elements under option class, including IanaPoolName, IapdPoolName, DnsServers, DomainName, Preference, AftrName, and Lease. The test is conducted in both default and non-default VRFs, with Spirent simulating an IPoE client and a radius user profile configured.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe dhcpv6 options",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought up, verifying that the server responds with host configuration options such as AFTR support, preference option, domain list, and DNS server IPv6 address. The server is also tested to send interface-id, remote-id, vendor-class, user-class, and client-id towards radius. This test is triggered by bringing down dual-stack IPoE subscriber sessions in default and non-default VRF with Spirent creating the IPoE client and a radius user profile being used for the setup.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber disconnect count verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe dhcpv4 class",
                "Procedure": "DHCPv4 classes can be configured using the following key parameters: circuit-id (DHCP Option 82), remote-id (DHCP Option 82), vendor-class (DHCP Option 60), and user-class (DHCP Option 77). To test this configuration, perform a dual-stack bringup with the following elements supported under an option class with dual-stack IPoE sessions: pool name, DNS servers, NTP servers, NetBiosNameServer, domain name, boot filename, next server, NetBios info, lease, and option codes. Additionally, test option class selection based on a class name provided from RADIUS. The test involves a dual stack IPoE subscriber in both the default and non-default VRFs, with a Spirent creating an IPoE client and a RADIUS user profile.\n\nThis test is triggered by the configuration of dual-stack IPoE subscribers in both the default and non-default VRFs, using Spirent to create an IPoE client and relying on a RADIUS user profile.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe dhcpv4 options",
                "Procedure": "To test DHCPv4 options with dual-stack IPoE subscriber sessions, bring up dual-stack IPoE subscriber sessions distributed across both the default and non-default VRFs. Verify that the server can respond to requests with the following host configuration options: the boot filename (Option 67), domain name (Option 15), netbios node type (Option 46), netbios name server (Option 44), and domain name server (Option 6). Additionally, verify that the server sends the circuit-id (DHCP Option 82), remote-id (DHCP Option 82), vendor-class (DHCP Option 60), user-class (DHCP Option 77), and client-id (DHCP Options 61) towards the radius. This test is triggered by a Spirent creating an IPoE client using a radius user profile in a dual-stack IPoE subscriber configuration, set up within both default and non-default VRFs.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe httpr",
                "Procedure": "IPoE dual-stack subscriber sessions with HTTP-R functionality are tested on dual-stack IPoE subscriber sessions. This test is triggered by bringing up IPoE dual-stack subscriber sessions from Spirent with specific combinations, including default and non-default VRF, some sessions having HTTP-R applied through RADIUS during bring-up, and others with HTTP-R applied through a feature template. The test then triggers Management-Action (MA) and Change of Authorization (CoA) operations to deactivate the HTTP-R service and activate HSI service on the subscriber sessions. Non-HTTP IPv4 and IPv6 traffic is run for all subscriber sessions, after which they are brought down and verified along with their associated services and accounting.\n\nTrigger: This test is triggered by a configuration that includes dual-stack IPoE subscribers in default and non-default VRFs, a Spirent setup to create an IPoE client, a RADIUS user profile, and traffic streams of IPv4 and IPv6 bidirectional traffic.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPbr summary verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe abf",
                "Procedure": "ABF operations are tested on dual-stack IPoE subscriber sessions, including those in default and non-default VRF with ABF enabled. The test setup includes IPv4 and IPv6 ACLs configured for \"next-hop\", the application of ABF on subscriber sessions through a feature-template in cnBNG CP, and bringing up dual-stack IPoE subscriber sessions distributed across default and non-default VRFs. Bidirectional ipv4 and ipv6 subscriber traffic is then run, followed by bringing down the subscriber sessions and removing ABF from the feature-template to configure it via Radius. The process is repeated with ABF removed through CoA before finally bringing down the subscriber sessions.\n\nThis test is triggered by configuration that involves a dual stack IPoE subscriber in default and non-default VRF, an Spirent creating IPoE client traffic, and a radius user profile generating traffic stream for ipv4 and ipv6 bidirectional traffic.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRun and traffic with abf verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe li",
                "Procedure": "Dual-stack IPoE subscriber sessions, including both CNBNG and PBNG, are tested for functionality. The lawful intercept use case is also examined using dual-stack IPoE subscriber sessions. A test setup includes a spirent simulator creating an IPoE client with the following combinations: default and non-default VRFs, and TAP enabled for subscriber sessions through RADIUS during bring-up. The RADIUS access-accept should include specific AVPs such as Cisco-avpair=\"intercept-id=abcd0012\" to initiate interception. Traffic is then run for all subscriber sessions, and the interception can be started or stopped through CoA by modifying the \"li-action\" avp.\n\nThis test is triggered by a RADIUS access-accept message containing specific AVPs including Cisco-avpair=\"intercept-id=abcd0012\", Cisco-avpair=\"md-ip-addr=<MD IP>\", Cisco-avpair=\"md-port=4545\", Cisco-avpair=\"md-dscp=7\", and Cisco-avpair=\"li-action=1\".",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nTcam entry count verification is performed.\nRun and traffic with li verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe urpf",
                "Procedure": "Test Strict uRPF operations on dual-stack IPoE subscriber sessions. The test involves enabling IPoE strict uRPF in the BNG system with 50K dual-stack IPoE subscriber sessions, bringing up these sessions from Spirent using different configurations such as CHAP authentication, double tag VLAN, non-default VRF, and default VRF, running bidirectional IPv4 and IPv6 traffic, configuring corrupted devices on default and non-default VRF, and running corrupted IPv4 and IPv6 traffic. The test also involves bringing down the subscriber sessions and verifying subscriber session and service accounting. The test configuration includes dual stack IPoE subscribers in default and non-default VRF, Spirent creating an IPoE client, a traffic stream with bidirectional IPv4 and IPv6 traffic, and a RADIUS user profile.\n\nThis test is triggered by enabling IPoE strict uRPF in the BNG system.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRun and corrupt traffic verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe client reboot",
                "Procedure": "Fifty thousand dual-stack IPoE subscriber sessions are brought up, distributed between the default and non-default VRFs. The clients are then aborted from Spirent and FSOLs are triggered again. Bidirectional IPv4 and IPv6 subscriber traffic is run through the system. Finally, the subscriber sessions are brought down.\n\nThis test is triggered by aborting all clients from the Spirent setup and triggering FSOLs again.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSpirent reboot verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe priority allocation",
                "Procedure": "The test prioritizes allocation of properties on dual-stack IPoE subscriber sessions, focusing on CNBNG and PBNG. It involves overriding certain properties using RADIUS, including ACLs, MTU settings, uRPF check, ICMP reachability flags, and accounting interim intervals. To replicate this scenario, the configuration is set up with 50K dual-stack IPoE subscriber sessions in default and non-default VRFs, using Spirent to create an IPoE client and traffic streams for both IPv4 and IPv6 bidirectional traffic. The RADIUS user profile is configured with corresponding settings in the cnBNG system.\n\nThis test is triggered by a scenario where 50K dual-stack IPoE subscriber sessions are brought up on CNBNG and PBNG, and radius attributes are applied to override properties such as ACLs, MTU, uRPF check, ICMP reachability flags, and accounting interim intervals.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack invalid vrf",
                "Procedure": "The configuration includes dual-stack IPoE subscribers in default and non-default VRFs, using RJIL profile configurations. Spirent is used to create IPoE and DHCPv6 PD clients, while the radius user profile is defined with a device password.\n\nThis test is triggered by configuring an invalid VRF in the RADIUS system and then bringing up dual-stack IPoE subscriber sessions from Spirent using various VLAN configurations.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack invalid acl",
                "Procedure": "When testing the application of undefined Access Control Lists (ACL) or Policy-Based Routing (PBR) on dual-stack Internet Protocol over Ethernet (IPoE) subscriber sessions, particularly for the P1 Test Case (TC), it is essential to consider two specific scenarios. First, if the definition of an ACL name or PBR policy name referenced by the Configuration Policy (CP) is not configured in the Universal Policy (UP), then the content-aware BNG system should fail to bring up the session but remain in a consistent state. To simulate this, configure an IPv4 ACL named \"iACL_BNG_IPv4_unconfig\" and an IPv6 ACL named \"iACL_BNG_IPv6_unconfig\" in CP which are not defined in UP. Then, initiate 50K subscribers to verify the system's behavior.\n\nThis test is triggered by configuring an ACL or PBR in Configuration Policy (CP) that is not defined in Universal Policy (UP).",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber disconnect count verification is performed.\nPool verification is performed.\nSubscriber session check verification is performed.\nQoS Verification verification is performed.\nCPU Utilization verification is performed.\nPool Allocation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pool exhaustion",
                "Procedure": "When testing for test pool exhaustion, a configuration scenario is set up with an address pool that has fewer addresses than expected. Specifically, a pool of less than 50,000 addresses is defined to serve 50,000 subscribers. The system is then brought up by starting subscriber sessions in rapid succession, but the session bring-up will fail once the pool becomes exhausted due to its limited size. This test pool exhaustion scenario is triggered by configuring an address pool with a number of addresses that is less than the total number of subscribers (50K).",
                "Pass/Fail Criteria": "Pbng pool verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber disconnect count verification is performed.\nIpam pool allocation verification is performed.\nCp up session sync verification is performed.\nPool Allocation (pre + after sessions established + post) verification is performed.\nSubscriber session check verification is performed.\nCPU Utilization verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack authentication failure",
                "Procedure": "When testing authentication failure scenarios with dual-stack subscriber sessions, configure some users with incorrect passwords in the RADIUS profile. Then bring up IPoE dual-stack subscriber sessions from Spirent using one of three methods: (a) double-tag VLAN, (b) non-default VRF, or (c) default VRF. Verify that no sessions come up if the password is incorrect. Next, abort the IPoE session from TGN and verify that Subscriber Bring Down occurs. The test configuration involves dual-stack IPoE subscribers in both default and non-default VRFs, with RJIL profile configurations used for this particular test case. Spirent is also used to create IPoE and DHCPv6 PD clients, while the RADIUS user profile contains sample settings such as a password.\n\nThis test is triggered by configuring users with incorrect passwords in a RADIUS profile.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Radius server unresponsive",
                "Procedure": "The test scenario involves simulating a situation where the radius server becomes unreachable during the session bring-up process. This is done by killing the radius daemon, bringing up IPoE dual-stack subscriber sessions from Spirent using different configurations such as double tag VLAN, non-default VRF, and default VRF. The system's behavior in terms of retries, retransmits, and deadtime is then verified after making the radius server unreachable. Additionally, the test involves aborting an IPoE session from a Traffic Generator (TGN) device and verifying that the subscriber bring-down configuration works as expected.\n\nThis test is triggered by making the radius server unreachable during session bring-up.",
                "Pass/Fail Criteria": "pool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Partial feature provisioning failure",
                "Procedure": "Simulating a subset of feature failures to test the rollback behavior of UP, including CNBNG and PBNG, is a priority 1 test case. This involves bringing up IPoE dual-stack subscriber sessions from Spirent using three different configurations: double tag VLAN, non-default VRF, and default VRF. Next, multiple action combinations are tested, involving CoA operations such as activating services not configured and deactivating those that are. The goal is to verify that no CoA responses are received and check the services in session details. Finally, the test case includes aborting the IPoE session from TGN and verifying Subscriber Bring Down configuration.\n\nThis test is triggered by a failure of a subset of features in UP, including CNBNG and PBNG.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Same intercept id",
                "Procedure": "When bringing up subscribers with the same intercept-id (CNBNG and PBNG), this test should fail. Configuration involves dual-stack IPoE subscribers in default and non-default VRFs, Spirent creating an IPoE client, and a traffic stream of bidirectional ipv4 and ipv6 traffic, as well as a radius user profile.\n\nThis test is triggered by attempting to bring up more than one session with the same intercept-id.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack qos input output radius user profile",
                "Procedure": "Dual-stack IPoE subscribers can be tested with QoS input/output policies using the CNBNG (P0 TC). This test involves configuring Quality of Service (QoS) Input and Output policies on the RADIUS server, then attempting to bring up dual stack subscriber sessions. The configuration for this test includes a Dual stack IPoE subscriber in both default and non-default VRFs, Spirent equipment creating an IPoE client, and a traffic stream with bidirectional IPv4 and IPv6 traffic. Additionally, a RADIUS user profile is required that incorporates QoS input/output policies.\n\nThis test is triggered by configuring QoS Input and Output policy on radius and trying to bring up dual stack subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe dynamic pool add delete",
                "Procedure": "To test the bring-up of dual-stack subscriber sessions with IPoE over both default and non-default VRFs, including configuration for CNBNG pools, follow these steps. Configuration is required on two stages: first, create a radius user profile and set up 16 address pools in the default VRF, as well as configure dual stack IPOE subscribers within this VRF; use Spirent to simulate an IPoE client. Then, move to setting up the same configuration for non-default VRFS, including 16 address pools and dual stack IPOE subscribers.\n\nThis test is triggered by configuring radius and attempting to bring up dual-stack subscriber IPoE sessions.",
                "Pass/Fail Criteria": "Offline address pools verification is performed.\nSubscriber session count verification is performed.\nPool verification is performed.\nDhcp binding summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nSubscriber session verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe frame routes",
                "Procedure": "Dual stack IPoE subscribers can be tested by configuring IPv4/IPv6 Frame routes on the RADIUS server, which are then used to bring up dual stack subscriber sessions. This method requires a list of frame route types specified in the input file under 'testcase_configuration', with options for either \"single\" or \"maximum\" routes. The test setup includes a dual stack IPoE subscriber distributed across both default and non-default VRFs, a Spirent device creating an IPoE client, and a RADIUS user profile configured with IPv4/IPv6 frame routes.\n\nThis test is triggered by providing in the input file under 'testcase_configuration' a list named as \"frame_route_type\" containing either \"single\" or \"maximum\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('frame_route_type', ['single'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verfication verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe mls lb pool scale",
                "Procedure": "To test maximum multiple loopbacks on the UP under cnbng-nal and maximum address pool subnet on CP over a dual-stack IPoE subscriber sessions(CNBNG), this test checks the bring-up and bring-down of dual-stack IPoE subscriber session. The testing process involves configuring multiple auto-loopbacks, 23 in total, in both default and non-default VRFs, as well as multiple address ranges and loopbacks. Additionally, a dual-stack IPoE subscriber is set up in distributed VRFs with a Spirent device creating the IPoE client, while a radius user profile is configured.\n\nThis test is triggered by configuring an IPoE client using a Spirent device within both default and non-default VRFs.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nof dynamic routes for multiple loopbacks verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe rpfo",
                "Procedure": "To test the Route Switch Processor Failover (RPFO) of a Test IPoE High Availability setup, bring up a subscriber and verify its successful activation. While IPv4 and IPv6 bidirectional traffic is streaming to the Spirent-created IPoE client, trigger a failover at the route switch processor. Once the failover has completed, confirm that the number of subscribers remains stable, stop the traffic stream, and verify accounting on the Radius server by checking the user profile.",
                "Pass/Fail Criteria": "Get subscriber to verify verification is performed.\nSubscriber session details verification is performed.\nConsistency verification is performed.\nTraffic verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe ha",
                "Procedure": "To test IPoE High Availability, bring up dual-stack IPoE subscriber sessions distributed across both the default and non-default VRFs. Then run bidirectional ipv4 & ipv6 subscriber traffic for 50% of subscribers, while simultaneously starting subscriber churn for a further 25% of the subscriber sessions, all of which should be subject to CoA/MA-CoA operations, triggered by these concurrent processes, followed by stopping the traffic and bringing down the subscriber sessions.\n\nThis test is triggered by the performance of CoA/MA-CoA operations on all subscriber sessions while bidirectional ipv4 & ipv6 subscriber traffic is running for 50% subscribers and subscriber churn is initiated for a further 25%.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Get subscriber to verify verification is performed.\nSubscriber session details verification is performed.\nConsistency verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe stress",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought up, distributed across both default and non-default VRFs. As the sessions churn at a rate of 12.5K subscribers (25% of max scale), the following types of events occur: 10% unauthenticated subscriber churn, 50% client reboots, 30% graceful release and connect, and 10% address-family flaps. This test is triggered by subscriber session churn when IPoE clients in a dual-stack configuration experience various events, including unauthenticated connections, client reboots, and address-family flaps, while traffic streams are generated for both IPv4 and IPv6 bidirectional communication.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.stress_triggers\"",
                "Pass/Fail Criteria": "Get subscriber to verify verification is performed.\nSubscriber session details verification is performed.\nConsistency verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe single session replay",
                "Procedure": "This test checks how a network device handles single-session replay on dual-stack Internet Protocol over Ethernet (IPoE) subscriber sessions. It first sets up and then tears down IPoE dual-stack subscriber sessions in both default and non-default virtual routing and forwarding (VRF) contexts, simulating changes to the access and core networks with flapping connections. The test is triggered by creating an IPoE client on a Spirent device that uses a radius user profile for configuration.",
                "Pass/Fail Criteria": "Get subscriber to verify verification is performed.\nSubscriber session details verification is performed.\nSession replay verification is performed.\nConsistency verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verfication verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter revertive functionality",
                "Procedure": "The Diameter peer-mode revertive functionality is verified by bringing up IPoE dual-stack subscriber sessions from Spirent with various configurations, including CHAP authentication and Double tag VLAN. The test involves a dual stack IPoE subscriber configured in the default VRF, along with radius user profiles and diameter configuration.\n\nThis test is triggered by bringing up dual stack IPoE subscriber sessions from Spirent with (a) CHAP authentication, (b) double-tagged VLANs, and (c) default VRF configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nDiameter feature revertive functionality verification is performed.\nTermination of Primary Peer and verification verification is performed.\nBringing up Primary Peer and verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter non revertive functionality",
                "Procedure": "Diameter peer mode non-revertive is tested in the default Virtual Routing and Forwarding (VRF) with priority zero Traffic Class (P0 TC). The test verifies the functionality of Diameter peer-mode non-revertive. To do this, IP over Ethernet (IPoE) dual-stack subscriber sessions are brought up from Spirent using: (a) Challenge-Handshake Authentication Protocol (CHAP) authentication; (b) Double tag VLANs; and (c) default VRF configuration, which includes a dual stack IPoE subscriber in the default VRF, radius user profiles, and diameter configuration. This test is triggered by bringing up IPoE dual-stack subscriber sessions from Spirent with CHAP authentication, double tag VLANs, and default VRF configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nDiameter feature non revertive functionality verification is performed.\nTermination of Primary Peer and verification verification is performed.\nBringing up Primary Peer and verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Authorization failure on gx rejection",
                "Procedure": "The Diameter Gx session Authorization failure scenario test verifies that a device can properly handle authorization failures when establishing a dual-stack IPoE subscriber session. The test starts with the Diameter Service set to Default revertive mode and simulates subscriber sessions being brought up from Spirent using CHAP authentication, double-tagged VLANs, and default VRF. After verifying the successful establishment of these sessions, including the number of Diameter peers and Gx sessions, both diameter peers are then taken down and verified as down before the IPoE dual-stack subscribers are brought back up. The test verifies that services are applied correctly to these new sessions, and finally checks the PBR summary. This test is triggered by a configuration involving a dual-stack IPoE subscriber in default VRF, a RADIUS user profile, and Diameter configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPbr summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nthe services applied verification is performed.\nthe Diameter Gx session Count verification is performed.\nPBR summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe subscriber bringdown",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought down using different methods, including the P0 TC test case. This test is triggered by configuring a Radius user profile with distributed dual stack IPoE subscribers in both default and non-default VRFs, creating an IPoE client using Spirent, and establishing bidirectional IPv4 and IPv6 traffic streams.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nsubscribers_bringdown_method: \"subscriber_sessions_clear\" and \"dhcp_bindings_clear\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nSubscriber disconnect count verification is performed.\nDiameter Service Start & peer verification verification is performed.\nDiameter GX session verification verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nSubscriber bringdown method verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter peer ip change functionality",
                "Procedure": "The test involves verifying the Diameter peers' IP change functionality by having them peer with ipv4/ipv6 addresses and swapping the IPs of existing peers, then verifying the changes. This test is triggered by bringing up IPoE dual-stack subscriber sessions from Spirent using various configurations: CHAP authentication, Double tag VLAN, and Default VRF. The test setup includes a Dual stack IPoE subscriber in default VRF, RADIUS user profile, and Diameter configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter Service Start & peer verification verification is performed.\nDiameter GX session verification verification is performed.\nIp swap between primary and secondary peers verification is performed.\nDiameter GX session verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe single stack",
                "Procedure": "This test brings up and down a single-stack IPoE subscriber session within the default VRF (P1 TC), as specified in the input file under 'testcase_configuration'. The configuration includes Radius user profiles, scale on the node, single stack IPoE subscriber sessions bringup, disconnection of subscriber sessions, and specific parameters such as Minid file configuration for single_stack, a single stack IPoE subscriber in default VRF, Spirent creation of an IPoE client, and traffic streams with IPv4 or IPv6 bidirectional traffic.\n\nThis test is triggered by configuring the Radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nsession_stack: \"IPV4\" and \"IPV6\"",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nDiameter Service Start & peer verification verification is performed.\nDiameter GX session verification verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe performance",
                "Procedure": "IPoE single-stack and dual-stack subscriber sessions are tested with respect to bringup and bringdown capacity. The test involves configuring Radius user profiles, scaling on the node, bringing up IPoE subscriber sessions, disconnecting them, and verifying configuration settings for Diameter Minid files, VRFs, and Spirent-generated IPoE clients.\n\nThis test is triggered by configuring a radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nsession_stack: \"IPV4V6\" and \"IPV4\" and \"IPV6\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nBringup IPoE  subscriber sessions from spirent, simultaneously perform polling to get the subscriber count with time. verification is performed.\nBringdown subscriber sessions, simultaneously perform polling to get the subscriber count with time. verification is performed.\nthe bringup and bringdown CPS verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe missing definitions",
                "Procedure": "When attempting to bring up a dual-stack IPoE subscriber session, the process can be triggered by this test case when definitions are missing. The test takes as parameters the configurations to be removed, such as 'qos', 'acl', or 'pbr'. To simulate the scenario, configure a Radius user profile and scale on the node, then remove any existing QoS, ACL, or PBR configurations from the node. Next, attempt to bring up dual-stack IPoE subscriber sessions and disconnect them afterwards. The necessary configuration includes a Radius user profile, Spirent (creating an IPoE client), and dual-stack IPoE subscriber settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmissing_config: \"qos\" and \"acl\" and \"pbr\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPool verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter server group negative scenarios",
                "Procedure": "The Diameter peers verify that they can peer with both IPv4 and IPv6 addresses by swapping the IPs of existing connections. The test also checks that when IPoE dual-stack subscriber sessions are brought up from Spirent, authentication methods such as CHAP work correctly, double tag VLAN configurations function properly, and default VRF settings are applied. This test verifies the Diameter peers' IP change functionality.\n\nThis test is triggered by bringing up IPoE dual-stack subscriber sessions with specific configurations, including CHAP authentication, double tag VLAN, and default VRF settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nReplace method name with random method name in : aaa authorization policy-if policy_meth group GX_1 verification is performed.\ndiameter Gx sessions - Zero verification is performed.\nsubscriber service Bw_15c , It should be httpr butnot bw_15c. verification is performed.\nRevert back changes. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rar cli diameter configs",
                "Procedure": "The Diameter Gx session Authorization failure scenario is verified. To trigger this test, a RAR CLI command needs to be run from Minidiameter, specifically the configuration related to the new diameter service with Monitoring key mk11 must already be in place, including PLDT_POC on service dynamic template configured.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nShow policymap targets type pbr summary verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nif new diameter service is applied to last subscriber verification is performed.\nthe Diameter Gx session Count verification is performed.\nPBR summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Neg service request through rar cli",
                "Procedure": "The Diameter Gx session Authorization failure scenario test verifies the Diameter Gx session authorization failure scenario. This test is triggered by a RAR CLI command, issued from Minidiameter, after configuring a dual-stack IPoE subscriber in default VRF with a radius user profile and incorrect diameter service configuration, including a monitoring key of mk11.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nif new diameter service is applied to last subscriber <it shouldnot> verification is performed.\nthe Diameter Gx session Count verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter volume based quota threshold",
                "Procedure": "IPoE dual-stack subscriber session bring-up and bringdown tests are run in the default Virtual Routing Forwarding (VRF) of a network device, specifically in test environment P0 TC. The method takes as input a list of configurations, specified under 'testcase_configuration' in an input file, which includes options for authentication and VLAN tagging, among other settings. In these tests, subscriber sessions are established from Spirent using CHAP (Challenge-Handshake Authentication Protocol) authentication with double-tagged VLANs, default VRF, and dual-stack IPoE subscribers.\n\nThis test is triggered by the configuration specified in the 'testcase_configuration' section of the input file, which must include options for radius user profiles and diameter configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter peer verifications verification is performed.\nDiameter gx session verification verification is performed.\nRun traffic verification is performed.\nInitial total arrived verifications verification is performed.\ntotal arrived after the initial threshold reached verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter peer source interface",
                "Procedure": "A test is triggered when the connection with a peer source interface (P0 TC) occurs, specifically during IPoE dual-stack subscriber session bring-up and bringdown in default VRF. The test involves bringing up IPoE dual-stack subscriber sessions from Spirent using various authentication methods: CHAP, double-tag VLANs, and default VRF. To configure the test, a list of configuration modes is used, including dynamic templates specified in an input file under 'testcase_configuration'. This setup includes configuring a dual stack IPoE subscriber in default VRF, radius user profiles, diameter configurations, source interfaces with primary IP address changes to listen to the corresponding IP, and minid files configured for new listen-to-IP addresses for primary peers.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nDiameter peer verifcation verification is performed.\ngx session verification is performed.\nsubscriber feature verification verification is performed.\nRadius accounting verifcation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter source interface revertive functionality",
                "Procedure": "The test assesses the functionality of a revertive source interface as part of the P0 Test Case (P0 TC). The test is triggered by this method, which takes in a list named configuration_mode = [\"dynamic-template\"] specified in an input file under 'testcase_configuration'. The method aims to bring-up and bring-down IPoE dual-stack subscriber sessions from Spirent with specific authentication methods and VLAN configurations. These include CHAP authentication, double tag VLANs, and default VRF settings. The required configuration includes a dual stack IPoE subscriber in default VRF, diameter configuration, radius user profile, source interface with an assigned IP address, and a minid file configured to direct traffic to the primary peer's new listen-to-ip address.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber Bring-up Verification verification is performed.\nConfigure source interface and change primary minid listen to IP accordingly verification is performed.\nDiameter Service & peer verification verification is performed.\nShut Source interface and verify CCA - It should be routed to secondary server verification is performed.\nUnshut source interface and verify if revertive functionality is verified verification is performed.\nDelete Source interface and verify CCA - It should be routed to secondary server verification is performed.\nReconfigure source interface and verify if revertive functionality is verified verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter peer source invalid interface",
                "Procedure": "The test checks the functionality of an interface when the peer source is invalid. The method takes a list of configurations, including dynamic-template specifications in an input file under 'testcase_configuration'. The test involves bringing up and down IPoE dual-stack subscriber sessions from Spirent with various authentication methods, such as CHAP and Double tag VLAN, in default VRF. Additionally, the source interface is configured with IP and a minid file with new listen-to-ip for primary peer. The configuration includes radius user profiles, diameter settings, and an invalid source interface.\n\nThis test is triggered by a list of configurations specified under 'testcase_configuration' in the input file.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber Bring-up Verification verification is performed.\nConfigure source interface and change primary minid listen to IP accordingly verification is performed.\nDiameter Service & peer verification verification is performed.\nConfigure invalid source interface and change minid listen-to ip accordingly. verification is performed.\nDiameter peer verifcation verification is performed.\ngx session verification is performed.\nsubscriber feature verification verification is performed.\nRadius accounting verifcation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter update messages in verbose log",
                "Procedure": "To test IPoE dual-stack functionality, verify that the system correctly processes and logs verbose messages when updating diameter settings. The test brings up and then down a dual-stack subscriber session over the default Virtual Routing Function (VRF) using the Spirent tool to simulate various authentication scenarios, including CHAP authentication, double-tag VLANs, and operation in the default VRF. Additionally, configure the source interface with an IP address and update the minid file to enable listen-to-IP functionality for primary peers. The setup includes a dual-stack IPoE subscriber operating in the default VRF, as well as radius user profiles and diameter configuration. This test is triggered by specifying [\"dynamic-template\"] in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nDiameter peer verifcation verification is performed.\ngx session verification is performed.\nupdate messages in verbose log verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diameter realm with maximum bytes",
                "Procedure": "A test of the maximum bytes configured in a test diameter realm with names is also performed. This test brings up and down an IPoE dual-stack subscriber session in the default virtual routing and forwarding (VRF) environment. The method takes a list called \"configuration_mode\" as input, which includes the specified dynamic template configuration from the testcase_configuration file. In this scenario, IPoE dual-stack subscriber sessions are brought up using three different configurations: with CHAP authentication, double-tagged VLAN, and default VRF. Source interfaces are also configured with an IP address, while a minid file is updated to listen-to-ip for the primary peer. The configuration itself includes a dual stack IPoE subscriber in default VRF, a radius user profile, diameter configuration, and a diameter realm with maximum bytes. This test is triggered by a scenario that includes dual-stack IPoE subscribers in the default VRF environment.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nDiameter peer verifcation verification is performed.\nDiameter realm names to be configured with maximum bytes verification is performed.\ngx session verification is performed.\nupdate messages in verbose log verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Peer source interface ipchange on fly",
                "Procedure": "When a Test Diameter Peer Source Interface Ip Change On Fly is triggered, it checks that an IPoE dual-stack subscriber session bring-up & bringdown in default VRF can be successfully performed. This involves bringing up and down sessions from Spirent with CHAP authentication, Double tag VLAN, and default VRF settings, using a configuration where the Dual stack IPoE subscriber is in default VRF, radius user profile, diameter configuration, source interface configured with an IP address that can change on fly, and minid file set up to listen-to-ip for primary peer.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber Bring-up Verification verification is performed.\nConfigure source interface and change primary minid listen to IP accordingly verification is performed.\nDiameter Service & peer verification verification is performed.\nDiameter peer verifcation verification is performed.\ngx session verification is performed.\nsubscriber feature verification verification is performed.\nRadius accounting verifcation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Negative service name in minid",
                "Procedure": "The test verifies the Diameter Gx session name with a negative service name by starting the Diameter Service in Default revertive mode and bringing up IPoE dual-stack subscriber sessions from Spirent using CHAP authentication, Double tag VLAN, or Default VRF. The subscriber bringup is verified with a configuration that includes a Dual stack IPoE subscriber in default VRF, a Radius user profile, and a Diameter configuration.\n\nThis test is triggered by starting the Diameter Service in Default revertive mode.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber Bring-up Verification verification is performed.\nchange the minid file with wrong service name which is not configured as accounting service in bng verification is performed.\nbring up diameters and change verify connection status verification is performed.\ngx session count verification is performed.\nrevert back changes verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Subscribers with no peer mode",
                "Procedure": "Diameter service is verified without peer mode configurations. Start the Diameter Service in Default revertive mode, then bring up IPoE dual-stack subscriber sessions from Spirent with CHAP authentication, Double tag VLAN, and Default VRF settings. Verify that subscribers are brought up successfully and that the correct number of Diameter peers and Gx sessions are established. Trigger Configuration: Dual stack IPoE subscriber in default VRF, radius user profile, diameter configuration.\n\nThis test is triggered by verifying GX session count after configuration changes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration().get('configuration_mode_diameter', ['dynamic-template'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber Bring-up Verification verification is performed.\nDiameter Service & peer verification verification is performed.\nUnconfig diameter peer mode configuration verification is performed.\nKill both peers verification is performed.\nGx session after Trigger verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bng_ipoe_perf_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Single stack ipv4 ipoe single interface racetrack",
                "Procedure": "Single-stack IPv4 subscriber sessions are brought up and brought down on a single interface, with a racetrack profile applied. The bring-up and bring-down Count Per Second (CPS) is characterized for the following combination: THK LC type, RSP5-SE RSP type, IPoE Single stack IPv4 subscriber type, 32K subscriber scale, Racetrack config profile, one single member bundle, four parent interfaces per bundle, three and unlimited retries, bring-up CPS of 100, and bring-down CPS of 80. The method takes in a list named as 'retries', which is specified in the input file under 'testcase_configuration'. This test is triggered by a list containing the retry values \"3\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 ipoe single interface racetrack",
                "Procedure": "Here is a single, natural-sounding paragraph:\n\nThe test characterizes the bring-up and bring-down Count Per Second (CPS) for an IPoE single-stack IPv6 subscriber session on a single interface with the racetrack profile applied. The test combines the following configurations: LC Type THK, RSP Type RSP5-SE, Subscriber Type IPoE Single stack IPv6, 32K subscribers, Racetrack config profile, one single member bundle, four bundle subinterfaces per bundle, and retries of three and unlimited (in both cases). The test measures the CPS by taking the time taken for bring-up or bring-down in seconds. This method takes a list called \"retries\" which is specified in the input file under 'testcase_configuration', set to [\"3\", \"unlimited\"]. The test brings up IPoE single-stack subscriber sessions from Spirent, simultaneously polling to get the subscriber count with time, then brings down the subscriber sessions and verifies the bring-up and bring-down CPS.\n\nThis test is triggered by a list of retries specified in the input file under 'testcase_configuration', which can be either \"3\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe single interface racetrack",
                "Procedure": "On a single interface, test IPoE dual-stack subscriber sessions bring-up and bring-down Count Per Second (CPS) as per P1 TC with racetrack profile applied. The test characterizes the CPS for 32K subscribers in an IPoE Dual Stack configuration, with LC Type: THK, RSP Type: RSP5-SE, one single member bundle, four bundle subinterfaces per bundle, and retries set to three and unlimited. The measurements include time taken for bring-up or bring-down in seconds, obtained by polling the subscriber count simultaneously while bringing up or down the sessions using Spirent with DHCPv4 and DHCPv6 clients, and verifying the CPS results.\n\nThis test is triggered by inputting a list of retries values, including '3' and 'unlimited', specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 ipoe single interface feature",
                "Procedure": "Here is the rewritten paragraph with the trigger sentence at the end:\n\nThe test brings up and brings down IPoE single-stack IPv4 subscriber sessions on a single interface, applying a full feature profile. This involves characterizing bring-up and bring-down counts per second (CPS) for a specific combination of parameters, including a certain LC type, RSP type, subscriber type, scale, configuration profile, bundle, parent interfaces, retries, and CPS values. The test measures the time taken for bring-up or bring-down in seconds, with polling performed to get the subscriber count simultaneously. It brings up 32K IPoE single-stack IPv4 subscriber sessions from Spirent, while also performing polling to obtain the subscriber count over time. Then it brings down the subscriber sessions with simultaneous polling to acquire the subscriber count. The test verifies the bring-up and bring-down CPS values. Configuration includes a single-stack IPoE subscriber in default VRF using RJIL profile configurations, as well as Spirent creating a DHCPv4 client and radius user profiles. This test is triggered by providing a list of retries values in the input file under 'testcase_configuration', which can be either \"3\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 ipoe single interface feature",
                "Procedure": "The test is designed to measure the Count Per Second (CPS) for bringing up and down a large-scale IPv6 single-stack IPoE subscriber session on a single interface, with all features enabled. The measurement involves creating 32K subscriber sessions with RJIL configuration profiles, using one bundle member with four subinterfaces as parents, and repeating each test three times or indefinitely to measure the CPS. The bring-up and bring-down processes are performed simultaneously while polling for the subscriber count in real-time. This test is triggered by a list of retries specified in the input file, which can include either \"3\" or \"unlimited\" retry values.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe single interface feature",
                "Procedure": "The test measures the Count Per Second (CPS) for bringing up and down a large scale of 32,000 IPoE dual-stack subscriber sessions on a single interface, with all features enabled. The test is performed on a specific combination of hardware and software configurations, including a THK line card, an RSP5-SE node, and a RJIL profile configuration. The subscriber count is polled in real-time as the sessions are brought up and down, and the CPS is calculated based on the time taken for each operation. This method takes in a list of retry values, which can be either \"3\" or \"unlimited\", specified in an input file under 'testcase_configuration'. \n\nThis test is triggered by providing a list named as retries = [\"3\" , \"unlimited\"] which is specified in input file under 'testcase_configuration' and performing the test on a dual-stack IPoE subscriber in default VRF with RJIL profile configs.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 ipoe interface across np racetrack",
                "Procedure": "Single-stack IPv4 IPoE subscribers are brought up and down on multiple network processors (NPs) of a single line card (LC), with a racetrack configuration applied. We characterize the bring-up and bring-down count per second (CPS) for a specific combination: THK LC, RSP5-SE RSP, IPoE Single-stack IPv4 subscriber, 32K subscribers, racetrack config profile, one single-member bundle from each NP of one LC, four bundle subinterfaces per bundle, and three or unlimited retries. The test measures the time taken for bring-up or bring-down in seconds. This method takes in a list named retries, specified in the input file under 'testcase_configuration', which contains the values \"3\" and \"unlimited\". It brings up IPoE single-stack subscriber sessions from Spirent while polling for subscriber count with time, then brings down the sessions while polling for subscriber count with time. The test verifies the bring-up and bring-down CPS.\n\nThis test is triggered by a list named retries containing two values: \"3\" and \"unlimited\", which are specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 ipoe interface across np racetrack",
                "Procedure": "The test measures the Count Per Second (CPS) for bringing up and down IPoE single-stack IPv6 subscriber sessions on multiple nodes of a single Line Card. The setup involves a THK Line Card, RSP5-SE, 32,000 subscribers with an IPoE Single stack IPv6 configuration, a racetrack profile, and one bundle per node with four subinterfaces. The retries are set to three and unlimited for both bring-up and bring-down scenarios. For the measurement, time is recorded from client perspective for both operations in seconds. This test is triggered by providing a list named 'retries' with values \"3\" and \"unlimited\", specified under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe interface across np racetrack",
                "Procedure": "A test is triggered by a method that takes in a list named \"retries\" which includes both \"3\" and \"unlimited\" as specified in an input file under 'testcase_configuration'. The test measures the count per second (CPS) for bringing up or bringing down IPoE dual-stack subscriber sessions on multiple network partitions (NPs) of a single Line Card (LC), with a racetrack profile applied. It involves creating 32K subscribers, each with a parent interface consisting of four bundle subinterfaces and one member bundle from each NP, using Spirent to bring up the sessions while polling for subscriber count and time, then bringing down the sessions in the same manner. The test is configured for dual-stack IPoE subscribers in default VRF, utilizing RJIL profile configs, with Spirent creating DHCPv4 and DHCPv6 clients and a radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 ipoe interface across np feature",
                "Procedure": "The test measures the Bring-up and Bring-down Count Per Second (CPS) for a single-stack IPv4 subscriber session using IPoE on multiple Network Processors (NPs) of a single Line Card (LC). The scenario involves 32,000 subscribers, RJIL configuration profiles, and one bundle member per NP. The test takes in a list of retries with values \"3\" and \"unlimited\" from the input file's 'testcase_configuration'. It brings up IPoE subscriber sessions simultaneously while polling for subscriber count, then brings down the sessions with polling for subscriber count. The Bring-up and Bring-down CPS are verified.\n\nThis test is triggered by a list named retries in the testcase_configuration section of the input file, which contains two values: \"3\" and \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 ipoe interface across np feature",
                "Procedure": "When testing the performance of a single LC with multiple NPs, we simulate bringing up and down 32K IPoE single-stack IPv6 subscriber sessions per second. The test focuses on the THK LC type with RSP5-SE as the RSP Type, using RJIL configuration profiles and 4 bundle subinterfaces per parent interface. We measure CPS by simultaneously polling for subscriber count while bringing up or down sessions at rates of 100 and 80 per second from the client's perspective. The test retries three times and once with unlimited attempts in both cases. The method also specifies input parameters, including a list of retries options such as '3' and 'unlimited', which are defined in an input file named 'testcase_configuration'. This test is triggered by creating DHCPv6 clients on Spirent using the RJIL profile's default VRF settings for this specific test case.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe interface across np feature",
                "Procedure": "The test triggers a Count Per Second (CPS) measurement of the time taken to bring up or bring down IPoE dual-stack subscriber sessions, with full feature profiles applied. The test focuses on a specific combination: THK LC type, RSP5-SE RSP type, 32K subscribers, RJIL config profile, and one bundle per NP from a single LC, with four bundle subinterfaces per bundle, and three and unlimited retries. During the measurement, Spirent simulates bring-up and bring-down of subscriber sessions while polling for subscriber count in real-time, and verifies the bringup and bringdown CPS.\n\nThis test is triggered by input parameters specified in the testcase_configuration file, including a list named 'retries' which can be either '3' or 'unlimited'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 ipoe interface across lc racetrack",
                "Procedure": "To test IPoE single-stack IPv4 subscriber session bring-up & bringdown CPS (Count Per Second) on multiple LCs, we apply the racetrack profile and characterize Bring-up & Bring-down CPS for a specific combination of settings. This includes THK LC Type, RSP5-SE RSP Type, 32K IPoE Single stack IPv4 subscribers, Racetrack Config Profile, One single member bundle from each LC, 4 bundle subinterfaces per bundle, and retries set to 3 and unlimited. The test measures the CPS for bring-up (100) and bring-down (80), taking into account time taken in seconds. This test is triggered by providing a list of retries options including \"3\" and \"unlimited\" through an input file under 'testcase_configuration'. It simultaneously performs polling to get the subscriber count with time during bring-up and bring-down operations, then verifies the CPS for each action using spirent, creating DHCPv4 Client and utilizing radius user profile in default VRF.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 ipoe interface across lc racetrack",
                "Procedure": "The test triggers a Count Per Second measurement on multiple Line Cards, specifically for an IPoE single-stack IPv6 subscriber session bring-up and bringdown. The setup includes a THK type Line Card with RSP5-SE Response System, 32K subscribers using the Racetrack configuration profile, and one single-member bundle from each Line Card, along with parent interfaces and retries of three and unlimited in both cases. To measure CPS, subscriber sessions are brought up and down simultaneously while polling to get the subscriber count at specific times, with bring-up and bring-down rates of 100 and 80 CPS respectively. This method takes a list of retry values from the input file under 'testcase_configuration'. The test environment consists of Single stack IPoE subscribers in default VRF (using RJIL profile configs), Spirent creating a DHCPv6 Client, and Radius user profile.\n\nThis test is triggered by providing a list named as retries = [\"3\", \"unlimited\"] which is specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe interface across lc racetrack",
                "Procedure": "The test involves triggering a Count Per Second (CPS) measurement for bringing up and bringing down IPoE dual-stack subscriber sessions on multiple Load Controllers (LCs), with the racetrack profile applied. The scenario consists of 32,000 subscribers, each with one member bundle from each LC, four subinterfaces per bundle, three retries, and unlimited retries, resulting in a bring-up and bring-down CPS of 80. The test also involves verifying the time taken for bring-up or bring-down in seconds using Spirent polling to get the subscriber count simultaneously. This test is triggered by providing a list named 'retries' with values \"3\" and \"unlimited\" specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 ipoe interface across lc feature",
                "Procedure": "Here is the rewritten paragraph:\n\nTo characterize the Bring-up and Bring-down Count Per Second (CPS) for a specific combination of network settings, we test IPoE single-stack IPv4 subscriber sessions on multiple Line Cards (LCs). The settings include LC Type: THK, RSP Type: RSP5-SE, Subscriber Type: IPoE Single stack IPv4, and 32K subscribers with the RJIL configuration profile applied. We measure the CPS for bringing up and down subscriber sessions with a retry limit of either 3 or unlimited attempts, as specified in the input file. The measurement process involves simultaneously polling to get the subscriber count while bringing up or down IPoE single-stack subscriber sessions from Spirent's DHCPv4 Client, creating a new session every second.\n\nThis test is triggered by a list named 'retries' containing either 3 or the string \"unlimited\", as specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 ipoe interface across lc feature",
                "Procedure": "Here is the rewritten paragraph:\n\nThe test measures the Count Per Second (CPS) for bringing up and bringing down IPoE single-stack IPv6 subscriber sessions on multiple Line Cards (LCs), with a full feature profile applied. The measurement involves 32,000 subscribers of type IPoE Single stack IPv6 on RSP5-SE LCs with THK configuration, RJIL profile, one bundle member per LC, and four subinterfaces per bundle. The retries are set to three and unlimited in both cases. The test brings up and brings down subscriber sessions simultaneously while polling for the subscriber count, verifying the bring-up and bring-down CPS. The measurement takes into account a time of 100 seconds for bringing up and 80 seconds for bringing down from the client's perspective.\n\nThis test is triggered by providing a list of retries in the input file under 'testcase_configuration', which can include both \"3\" and \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe interface across lc feature",
                "Procedure": "Here is the rewritten paragraph:\n\nThe test involves bringing up and down IPoE dual-stack subscriber sessions at a rate of 80 CPS on multiple LCs, with a full feature profile applied. This includes characterizing the bring-up and bring-down CPS for specific combinations of hardware and software configurations. The test is triggered by a list of retries specified in an input file under 'testcase_configuration', which can be either \"3\" or \"unlimited\". During the test, subscriber sessions are brought up from Spirent while polling to get the subscriber count simultaneously, and then brought down while again polling for the subscriber count. The bring-up and bring-down CPS is verified as part of the test.\n\nThis test is triggered by a list named 'retries' which includes either \"3\" or \"unlimited\" retries specified in an input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Coa unidimensional",
                "Procedure": "The test assesses the performance of CoA in a unidimensional scenario where only CoA requests are present. The configuration involves bringing up 50K dual-stack IPoE subscriber sessions and triggering CoA requests with specific combinations, including a request rate of 40 per second, a timeout of 3 seconds, and one retry.\n\nThis test is triggered by simulating CoA requests with the parameters specified above.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nMeasure following CoA Performance parameters: verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Coa multidimensional",
                "Procedure": "To test the performance of CoA in a multidimensional scenario, bring up 50K dual-stack IPoE subscriber sessions and trigger CoA requests with a rate of 40 per second, a timeout of 3 seconds, and a retry count of 1. This test is triggered by subscriber churn with additional CoA requests in the system.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nMeasure following CoA Performance parameters: verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Macoa unidimensional",
                "Procedure": "MA-CoA Performance Parameters characterize the MA-CoA response rate in a unidimensional scenario where only CoA requests are present in the system. To test this, the system is configured with 50K dual-stack IPoE subscriber sessions, and MA-CoA requests (sa, sd) are triggered at a rate of 40 per second, with a timeout of 3 seconds and one retry. \n\nThis test is triggered by bringing up 50,000 dual-stack IPoE subscriber sessions and sending MA-CoA requests at a rate of 40 per second, with a timeout of 3 seconds and a single retry.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nMeasure following CoA Performance parameters: verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Macoa multidimensional",
                "Procedure": "50K dual-stack IPoE subscriber sessions are brought up. MA-CoA requests are triggered in various combinations: a request rate of 40 per second, with a timeout of 3 seconds and one retry attempt allowed. The test also includes subscriber session churn as an additional condition.\n\nThis test is triggered by the configuration parameters that bring up 50K dual-stack IPoE subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nMeasure following CoA Performance parameters: verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe memory utils",
                "Procedure": "During bringup and bringdown, collect memory statistics for a P0 TC test used to measure the impact of bringing up single-stack or dual-stack IPoE subscriber sessions in mixed VRFs. The test collects memory statistics after bringing up the sessions, with the option to specify a parameter for the subscriber stack. It then brings down the sessions and takes further memory readings. Configuration includes setting up a single- or dual-stack IPoE subscriber session in a mixed VRF environment, using a Spirent device as an IPoE client, and defining a radius user profile.\n\nThis test is triggered by bringing up single-stack or dual-stack IPoE subscriber sessions in a mixed VRF setup with a specified subscriber stack.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmemory_subscriber_stack: \"ApData.zap.get_testcase_configuration('memory_subscriber_stack')\"",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nPool verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bng_ipoe_srg_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Cnbng nal association",
                "Procedure": "The test case for the CNBNG CP-UP Association on SRG nodes evaluates the network's behavior under various connectivity scenarios, including breaking and restoring connections, clearing associations, unconfiguring and reconfiguring NAL configurations. The process begins with intentionally disrupting the CP-UP connection on one of the SRG units by setting an Access Control List (ACL), after which it verifies that the connection is down but the association remains active for three heartbeats. Following this, connectivity is restored, and the test ensures that both the connection and association are functioning correctly. Next, the association is cleared from the unit in a controlled manner, after which the test confirms that the connection is down and the association inactive. The process of unconfiguring and reconfiguring the cnbng-nal is then performed, with verification checks to ensure the connection is back up and active. This entire sequence of steps is repeated on the other SRG node. Configuration involves both unconfiguring and reconfiguring the CNBNG-NAL settings.\n\nThis test is triggered by changing the Access Control List (ACL) setting on one of the SRG nodes, causing a deliberate disconnection of the CP-UP link.",
                "Pass/Fail Criteria": "Cp up association verification is performed.\ncnbng-nal association status CLI on UP verification is performed.\nshow peers CLI on CP verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng bringup",
                "Procedure": "The test of dual-stack IPoE subscriber session bring-up and bringdown is triggered by a P0 TC on the SRG. This involves configuring a list of protocols, including IPv4, IPv6, and IPv4V6, which are specified in the input file under 'testcase_configuration'. The setup includes configuring a Radius user profile, scaling both SRG nodes, and setting tracks and parameters on both nodes. Additionally, Spirent is configured to perform pre-test validations, followed by dual-stack IPoE subscriber sessions being brought up in default and non-default VRFs, verifying that the sessions are synced from Master to Slave. Bidirectional traffic for IPv4, IANA, and IAPD is then run, and the subscriber sessions are brought down before verifying both session and service accounting.\n\nThis test is triggered by a P0 TC on the SRG.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconfig_protocol: \"ApData.zap.get_testcase_configuration().get('config_protocol', ['IPV4V6'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng track failure",
                "Procedure": "The test case involves bringing up and down dual-stack IPoE subscriber sessions in both default and non-default VRFs with a Shared Radio Group (SRG) trigger. To set this up, configure the following: a Radius user profile, scale on both SRG nodes, tracks and SRG parameters on both nodes, Spirent traffic generation, and pre-test validations. Dual-stack IPoE subscriber sessions are brought up in default and non-default VRFs, and verified that the sessions are synced from Master to Slave. Bidirectional IPv4, IANA, and IAPD traffic is run multiple times with various network configurations, including an access/core flap in BNG1, which causes BNG2 to become master. The subscriber groups are then retained back in Active-Active mode after the revertive timer expires. Finally, bidirectional IPv4, IANA, and IAPD traffic is run one last time before bringing down the subscriber sessions and verifying their status and service accounting. This test is triggered by a Shared Radio Group (SRG) configuration change.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrack_fail: \"ApData.zap.get_testcase_configuration().get('track_failure', ['access_port_flap', 'core_flap'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRadius accounting records verification is performed.\nSubscriber session count verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng track failure churn",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought up and down in both default and non-default VRFs with SRG trigger. Configuration involves setting a Radius user profile, scaling on both SRG nodes, configuring tracks and SRG parameters, and using Spirent for pre-test validations. Sessions are verified to be synced from Master to Slave, and bidirectional IPv4, IANA, and IAPD traffic is run in both directions while the BNGs flap between master and standby modes. The revertive timer expires and subscriber groups remain active after the sessions are brought down.\n\nThis test is triggered by the configuration of a dual-stack IPoE subscriber in default and non-default VRF, using Spirent to create an IPoE client, with SRG configuration, traffic stream, and Radius user profile.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng rpfo",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought up and down in default and non-default VRF with SRG trigger. The test method takes a list of RPF modes specified in the input file under 'testcase_configuration', which is currently set to [\"bng1\", \"bng2\"]. This test is triggered by configuring a Radius user profile, scaling on both SRG nodes, setting tracks and SRG parameters on both nodes, and performing pre-test validations with Spirent. The method then brings up dual-stack IPoE subscriber sessions in default and non-default VRF, verifies that the sessions are synced from Master to Slave, runs bidirectional IPv4, IANA, and IAPD traffic, performs RPFO, runs additional bidirectional IPv4, IANA, and IAPD traffic, and finally brings down the subscriber sessions while verifying subscriber session and service accounting. The test configuration includes dual-stack IPoE subscribers in default and non-default VRF, Spirent for creating an IPoE client, SRG configuration, a traffic stream, and a Radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrpfo_mode: \"ApData.zap.get_testcase_configuration().get('rpfo_trigger', ['bng1', 'bng2'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng account logon off",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought up and brought down in both default and non-default Virtual Routing Forwarding configurations, while simultaneously running tests on Scale Ring Group nodes. This is done through a series of steps, including configuring the Radius user profile and Spirent parameters, as well as performing pre-test validations using Spirent to create an IPoE client. Once set up, the test involves bringing up dual-stack IPoE subscriber sessions in both default and non-default VRFs, verifying that sessions are synced from the master to the slave node, running bidirectional IPv4, IANA, and IAPD traffic, performing account logon and verifying subscriber manager statistics, switching over, logging off accounts, and verifying subscriber bringdown. The configuration includes dual-stack IPoE subscribers in default and non-default VRFs, Spirent for creating an IPoE client, Scale Ring Group setup, and Radius user profile configuration.\n\nThis test is triggered by the creation of a Spirent-configured IPoE client with specific parameters set within the Scale Ring Group nodes.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng coa",
                "Procedure": "The test involves bringing up and down dual-stack IPoE subscriber sessions in both the default and non-default VRFs, triggered by a specific event. This test is triggered by the requirement to test the resilience of the system, particularly the ability of SRG nodes to handle configuration changes and traffic flows under different conditions. The test includes configuring various parameters such as Radius user profiles, scale on SRG nodes, tracks and SRG settings, and Spirent for generating IPoE clients, followed by bringing up dual-stack sessions in default and non-default VRFs, verifying session syncing between Master and Slave nodes, activating services through CoA, running bidirectional traffic, performing admin switchover in BNG1, and finally bringing down subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRadius accounting records verification is performed.\nSubscriber session count verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng macoa",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought up and down in both the default and non-default VRF with Service Request Gateway (SRG) trigger. The process begins by configuring a Radius user profile, scaling on both SRG nodes, tracking and SRG parameters on both nodes, as well as setting up Spirent for pre-test validations. Next, dual-stack IPoE subscriber sessions are brought up in the default and non-default VRF, with verification that the sessions are synced from the Master to Slave node. The service is then activated/deactivated via MACoA, followed by running bidirectional IPv4, IANA, and IAPD traffic, as well as performing an admin switchover in BNG1. After verifying that BNG2 becomes the master and the service is deactivated via CoA and confirmed to be deactived, subscriber sessions are brought down for final verification of subscriber session and service accounting.\n\nThis test is triggered by configuring a Radius user profile, scaling on both SRG nodes, tracking and SRG parameters on both nodes, as well as setting up Spirent.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng session limit",
                "Procedure": "Dual-stack IPoE subscriber sessions bring-up and bring-down testing is performed on both default and non-default VRF with a session limit, triggered by the requirement for high availability in critical applications. The test involves configuring a Radius user profile, scaling parameters on both Service Request Generator (SRG) nodes, setting up tracks and SRG parameters on both nodes, conducting pre-test validations using Spirent, and configuring a session limit. Subscriber sessions are brought up in default and non-default VRFs, with verification that the sessions are synced from Master to Slave. A switchover is then performed, verifying again that the sessions are synced correctly before bringing down the subscriber sessions. Verification of subscriber session and service accounting is also conducted.\n\nThis test is triggered by the need for high availability in critical applications (P0 TC).",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber session count verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng httpr",
                "Procedure": "The test involves bringing up and down dual-stack IPoE subscriber sessions in both the default and non-default Virtual Routing Forwarding (VRF) environments, utilizing the Service Request Gateway (SRG) trigger with an HTTP request template. The setup includes configuring a Radius user profile, scaling on SRG nodes, tracking parameters, and Spirent configuration for pre-test validation. The test also verifies that sessions are synced from the master to the slave node during switchover in BNG1, checks for retention of subscriber groups in Active-Active mode, and ensures proper service accounting.\n\nThis test is triggered by a Service Request Gateway (SRG) event with an HTTP request template (P0 TC).",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPbr summary verification is performed.\nRadius accounting records verification is performed.\nSubscriber session count verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng frame route",
                "Procedure": "Dual-stack IPoE subscriber sessions are tested for bring-up and bringdown in both default and non-default VRFs with the SRG trigger, priority P0, Traffic Control. The test setup includes a configured Radius user profile, scaled on both SRG nodes, tracks and parameters, and Spirent performing pre-test validations. Dual-stack IPoE subscriber sessions are brought up in default and non-default VRFs, verified to be synced from Master to Slave, then brought down with verification of subscriber session and service accounting. The configuration involves dual-stack IPoE subscribers in both VRFs, a Spirent creating an IPoE client, SRG setup, and Radius user profile.\n\nThis test is triggered by the creation of an IPoE client using Spirent.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('frame_route_type', ['single'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng active standby",
                "Procedure": "A test scenario involves setting up dual-stack IPoE subscriber sessions in both default and non-default VRF in active-standby mode with a service request gateway (SRG) trigger, which is triggered when the priority 0 traffic class (TC) is exceeded. The configuration includes Radius user profiles, scaling on both SRG nodes, tracking parameters on both nodes, and Spirent setup for pre-test validation. Traffic is then run in bidirectional IPv4, IANA, and IAPD modes to verify session syncing from master to slave node. Following this, an admin switchover is performed on BNG1, verifying that BNG2 becomes the new master, and traffic is run again. A second admin switchover occurs on BNG2, with subscriber groups retained in active-standby mode, followed by bidirectional IPv4, IANA, and IAPD traffic runs to validate session syncing. Finally, subscriber sessions are brought down and verified, along with service accounting.\n\nThis test is triggered by when the Priority 0 Traffic Class (P0 TC) is exceeded.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRadius accounting records verification is performed.\nSubscriber session count verification is performed.\nRedundancy group id verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng li",
                "Procedure": "To test the functionality of a dual-stack IPoE subscriber session, bring it up and down in both the default and non-default Virtual Routing Forwarding (VRF) environments. First, configure a Radius user profile, scale on both Service Request Gateway (SRG) nodes, set tracks and SRG parameters on both nodes, and prepare Spirent for testing by creating an IPoE client with dual-stack configuration. Then bring up the subscriber sessions in default and non-default VRFs, verifying that they are synced between Master and Slave, and checking LI functionality. Next, perform a BNG1 access/core flap to see if BNG2 becomes the new master and the subscriber groups retain their Active-Active mode status. After waiting for the revertive timer to expire, verify that the subscriber sessions and service accounting function correctly.\n\nThis test is triggered by the creation of an IPoE client with dual-stack configuration in Spirent.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nTcam entry count verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng active standby ha",
                "Procedure": "The test involves dual-stack IPoE subscriber session bring-up and bring-down in both default and non-default VRFs, using active-standby mode with a Service Route Group (SRG) trigger. It consists of several steps: configuring the Radius user profile, scaling on both SRG nodes, tracking and SRG parameters on both nodes, setting up Spirent and performing pre-test validations, bringing up dual-stack IPoE subscriber sessions in default and non-default VRFs, verifying session synchronization from master to slave, running bidirectional IPv4, IANA, and IAPD traffic, triggering a high-availability (ha) event on BNG1, verifying that BNG2 becomes the new master, re-running bidirectional traffic after a revertive timer has triggered a return to the original state, verifying subscriber group retention in active-standby mode, and finally bringing down subscriber sessions while checking for retained session and service accounting.\n\nThis test is triggered by configuring a user profile on the Radius server.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nha_trigger: \"ApData.zap.get_testcase_configuration().get('ha_triggers', ['active_rp_reload', 'lc_reload'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nSubscriber session count verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng access down",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought up and down in both the default and non-default Virtual Routing Forwarding (VRF) configurations, with Session Redirect Gateway (SRG) triggers activated. A range of setup steps precede this test: a RADIUS user profile is configured, scaling is enabled on both SRG nodes, track parameters and SRG settings are adjusted, Spirent equipment is prepared for testing, and pre-test checks are performed to ensure all systems are functioning correctly. The test then initiates the dual-stack IPoE subscriber sessions in default and non-default VRF configurations, verifies that session data synchronizes from Master to Slave nodes, causes access disruptions on both Slave and Master nodes, performs health checks, and finally brings down subscriber sessions. Post-test verification includes checking for accurate accounting and subscription records. This test is triggered by a P0 Trigger Condition (TC) event in SRG mode, using the Scale On Both configuration.\n\nThis test is triggered by the occurrence of a P0 Trigger Condition (TC) event in Session Redirect Gateway (SRG) mode, with both nodes configured to scale on both.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nContext verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng ha",
                "Procedure": "Dual-stack IPoE subscriber sessions bring up and bring down in both default and non-default VRFs with the SRG trigger enabled. This test is triggered by the event of configuring a radius user profile, setting scale on both Service Routing Gateway (SRG) nodes, defining tracks and SRG parameters on each node, configuring Spirent to simulate an IPoE client, and performing pre-test validations. The test involves bringing up dual-stack IPoE subscriber sessions in default and non-default VRFs, verifying that the sessions are synchronized from Master to Slave, triggering high availability (HA), running bidirectional IPv4, IANA, and IAPD traffic, and then bringing down the subscriber sessions while also checking for correct subscriber session and service accounting. The test configuration includes dual-stack IPoE subscribers in both default and non-default VRFs, a Spirent setup to simulate an IPoE client, SRG configuration, a traffic stream, and a radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nConsistency verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng missing definitions",
                "Procedure": "When attempting to bring up a dual-stack IPoE subscriber session, the test fails if certain definitions are missing. The test case can be triggered by this condition: This test is triggered when bringing-up a dual-stack IPoE subscriber session and specific definitions such as qos, acl, or pbr configurations are missing from the parameters 'missing_config'. To test this scenario, start by configuring a Radius user profile, scaling on both SRG nodes, and removing existing QoS, ACL, and PBR configurations from Active and Standby. Next, configure track and SRG parameters, perform pre-test validations, and set up Spirent to create an IPoE client. Finally, attempt to bring up dual-stack IPoE subscriber sessions and disconnect the subscribers.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmissing_config: \"qos\" and \"acl\" and \"pbr\"",
                "Pass/Fail Criteria": "Redundancy group id verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg",
                "Procedure": "The test involves bringing up and taking down dual-stack IPoE subscriber sessions in a mixed VRF environment with Service Route Group (SRG) trigger. This test case treats the srg triggers as 'trigger' events, such as core_track_flap, access_interface_flap, graceful_switchover, or n4_link_failure. The test configuration includes a Radius user profile, scaling on both SRG nodes, tracks and SRG parameters on the upstream node, SRG parameters on the control plane node, and Spirent setup for generating IPoE traffic. The test verifies subscriber session bring-up and tear-down in mixed VRF, checks for successful radius start and verification of subscriber sessions, performs SRG specific validations, runs bidirectional IPv4, IANA, and IAPD traffic, and verifies router accounting for the traffic.\n\nThis test is triggered by performing actions such as core_track_flap or access_interface_flap on an interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"core_track_flap\" and \"access_interface_flap\" and \"graceful_switchover\" and \"n4_link_failure\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nRadius accounting records verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nAccounting verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nAccounting on router verification is performed.\nRadius accounting verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg reload userplane",
                "Procedure": "Dual-stack IPoE SRG subscriber sessions must be up with an Active-Active configuration for the test to run. The following configurations are required: a Radius user profile, Spirent setup to create an IPoE client, dual stack IPoE subscribers, SRG parameters set to active/active configuration, and a traffic stream of bidirectional IPv4 and IANA traffic. This test is triggered by having all the above-mentioned configurations in place.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nSubscriber session count verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nRadius accounting records verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nAccounting verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nAccounting on router verification is performed.\nRadius accounting verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe default vrf",
                "Procedure": "To test the dual-stack IPoE subscriber session bring-up and bringdown in default VRF with an SRG trigger, configure a Radius user profile, scale on both SRG nodes, and set up tracks and SRG parameters on the upstream node. On the control plane, configure SRG parameters and clear dynamic routes and associations. Perform a successful SRG sync and verify that srg-roles are negotiated properly on both upstream nodes. Complete pre-test validations and set up Spirent. Bring up dual-stack IPoE subscriber sessions in default VRF, verify subscribers with Radius Start check, and perform detailed verification and SRG-specific validations.\n\nThis test is triggered by the configuration of Active/Active SRG parameters, which enables bidirectional IPv4, IANA, and IAPD traffic, as well as router accounting for the traffic run.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nRadius accounting records verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nAccounting verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nAccounting on router verification is performed.\nRadius accounting verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg access lc reload",
                "Procedure": "The test aims to verify the dual-stack IPoE subscriber session bring-up and bring-down process in a mixed VRF environment with Service Request Gateway (SRG) trigger. To set up this test, we configure a Radius user profile, scale on both SRG nodes, tracks and SRG parameters on the upstream node, SRG parameters on the control plane, clear dynamic-routes and cp-srg association, perform SRG sync, verify SRG sync is successful on the control plane, and verify srg-roles are negotiated properly. We then perform pre-test validations, configure Spirent to create an IPoE client, bring up dual-stack IPoE subscriber sessions in mixed VRF with Radius Start check verification, and run bidirectional IPv4, IANA, and IAPD traffic while verifying router accounting. After triggering a Service Request Gateway switchover (LC Reload), we verify the switchover is successful, perform SRG specific validations, and then recover from the switchover and bring back to the original state.\n\nThis test is triggered by configuring SRG parameters to have an Active / Active configuration on the dual stack IPoE subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nRadius accounting records verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nAccounting verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nAccounting on router verification is performed.\nRadius accounting verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng bringup pqos",
                "Procedure": "Configuring a dual-stack IPoE subscriber session involves several steps, including setting up a Radius pqos user profile, configuring scale on both SRG nodes, and configuring tracks and SRG parameters on both nodes. Additionally, Spirent is used to perform pre-test validations by creating an IPoE client. The test then proceeds with bringing up dual-stack IPoE subscriber sessions in default and non-default VRF, verifying that the sessions are synced from Master to Slave, running bidirectional IPv4, IANA & IAPD traffic, and finally bringing down the subscriber sessions while verifying subscriber session and service accounting.\n\nThis test is triggered by configuring a dual stack IPoE subscriber in default and non-default VRF with Spirent (creating an IPoE client), SRG configuration, traffic stream, and Radius user profile.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng bringup acl",
                "Procedure": "Dual-stack IPoE subscriber sessions are brought up and down in default and non-default Virtual Routing Forwarding (VRF) with Service Request Gateway (SRG) trigger, a priority-0 (P0) Test Case (TC). This test is triggered by the configuration specified in the input file under 'testcase_configuration'. The setup involves configuring Radius user profiles, scale on both SRG nodes, Access Block Filter (ABF) ACLs on R1 and R4, tracks and SRG parameters on both nodes, and Spirent with pre-test validations. Dual-stack IPoE subscriber sessions are brought up in default and non-default VRF, verified for synchronization from Master to Slave, subjected to uplink traffic verification through the ABF interface, and then switched over to verify traffic flow through the ABF interface. Next, a Change of Authorization (CoA) is sent to deactivate the ABF ACL and activate a non-ABF ACL, with subsequent verification of regular traffic flow. Finally, subscriber sessions are brought down, and their synchronization and service accounting are verified.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRadius accounting records verification is performed.\nSubscriber session count verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfd dual stack ipoe pbng rapid srg switchover cscwa94064",
                "Procedure": "Here is the rewritten paragraph:\n\nTo test dual-stack IPoE subscriber sessions, the system first brings up a session in active-standby mode and then rapidly switches between source routing gateways (P0 TC) CSCwa94064-Rapid SRG switchover flaps leading to accounting stale radius \"Attribute event timestamp\" value. This test also verifies the interim update timestamp after rapid SRG switchover.\n\nThis test is triggered by configuring a subscriber with a dual-stack IPoE session in default and non-default VRF, along with Spirent, SRG, traffic stream, and Radius user profile configurations.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber session count verification is performed.\nRedundancy group id verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\n radius accounting record verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng subscriber bringup cac",
                "Procedure": "Dual-stack IPoE subscribers are tested in a mixed VRF environment, with one network operating as the default VRF and the other as a non-default VRF. The test is run without the SRG trigger mechanism and uses a watchdog timer (P1 TC). To set this up, a Radius user profile needs to be configured, as well as scale settings on both Service Resource Gateways (SRGs). Tracks and SRG parameters must also be configured, along with watchdog memory levels. The test also requires Spirent configuration, including the creation of an IPoE client, and pre-test validations need to be performed. This test is triggered by a dual-stack IPoE subscriber in default and non-default VRF configurations.",
                "Pass/Fail Criteria": "Redundancy group id verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber infra readiness and memory level verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pbng cac rpfo",
                "Procedure": "The test involves configuring a dual-stack IPoE subscriber in mixed VRF environments, using the rpfo trigger and watchdog timer. The process starts with configuring radius user profiles, scaling on both Service Resource Gateway (SRG) nodes, setting track and SRG parameters, and establishing watchdog memory levels. Spirent is then configured to perform pre-test validations. Next, dual-stack IPoE subscriber sessions are brought up in default and non-default VRFs, followed by verification of the subscriber infrastructure's readiness and session syncing from Master to Slave nodes. Bidirectional IPv4, IANA, and IAPD traffic is run, along with RPFO operations, after which the subscriber infrastructure's readiness state is verified again. The process concludes with bringing down subscriber sessions and verifying subscriber session and service accounting.\n\nThis test is triggered by a list named \"rpfo_mode\" being specified in the input file under 'testcase_configuration', with 'bng1' as its value.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrpfo_mode: \"ApData.zap.get_testcase_configuration().get('rpfo_trigger', ['bng1'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nSubscriber infra readiness verification is performed.\nRedundancy groups verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nsubscriber infra readiness state verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg httpr",
                "Procedure": "To test the HTTPR functionality in a dual-stack IPoE environment, validate that it works correctly with the srg trigger. This test is triggered by configuring Radius user profile settings on both nodes of the Service Range Gateway (SRG), as well as the tracks and SRG parameters on the User Plane (UP) and Control Plane (CP). The configuration also includes scale settings on both SRG nodes, a clear association between the control plane and subscriber gateway network function (cp-srg association), and a successful synchronization of SRG. The test then proceeds with pre-test validations, configuring Spirent to create IPoE clients in a mixed VRF and bringing up dual-stack subscriber sessions over the Radius Start check. Various verifications are performed throughout, including subscriber session checks, PBR (Policy-Based Routing) checks, and CoA (Change of Authorization) triggers, as well as specific SRG validations after switchover and recovery to the original state. The test concludes with verifying that all SRG parameters return to their initial settings after a successful recovery.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nCnbng cp srg sync verification is performed.\nPbr summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nPBR target verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe renew rebind",
                "Procedure": "The test case involves bringing up and tearing down IPoE subscriber sessions with DHCP renew and rebind, testing dual-stack and single-protocol configurations. The test takes a session_stack argument that is passed to the handle function with one of three values: 'IPV4V6PD', 'IPV4', or 'IPV6PD'. Before running the test, several configuration steps are performed: setting up Radius user profiles, configuring scale on both SRG nodes, and establishing tracks and SRG parameters on the UP node. Additionally, the cnbng-nal dynamic-routes and cp-srg association must be cleared. The test then synchronizes the SRG on the CP node and verifies its success. Subsequent steps include verifying that subscriber sessions with Radius are started properly, performing detailed verification of subscriber details, and testing SRG-specific validations. DHCP Renew packets are sent to all subscribers, and their receipt is verified; the same process occurs for DHCP Rebind. Finally, subscriber sessions are disconnected and verified as completely down. \n\nThis test is triggered by providing one of three session_stack values - IPV4V6PD, IPV4, or IPV6PD - which determine the configuration options used during testing.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nsession_stack: \"IPV4V6PD\" and \"IPV4\" and \"IPV6PD\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nRadius accounting records verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nRenew / Rebind counter verifications verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Clear subscriber from cp",
                "Procedure": "To configure a test that meets the requirements for active and standby BNG, several steps must be taken. This includes configuring the Radius user profile, scaling on both SRG nodes, tracks, and SRG parameters on the UP and CP, as well as clearing dynamic routes and associations. The Core track at BNG2 should then be brought down, followed by an SRG sync and verification of successful sync on the CP. Subsequent steps involve verifying srg-roles negotiated properly, performing pre-test validations with Spirent configuration, bringing up dual stack IPoE subscriber sessions in mixed VRF, and verifying subscriber sessions with a Radius start check. Further testing involves detailed subscriber verifications, SRG specific validations, and clearing of subscriber sessions using the CP CLI for both active and standby SRGs.\n\nThis test is triggered by an Active/Active configuration on the SRG parameters and utilizes Spirent to create an IPoE client as part of the Radius user profile.",
                "Pass/Fail Criteria": "Cnbng up srg summary verification is performed.\nSubscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nSubscriber synchronize verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Srg bringup post both n4 linkfail",
                "Procedure": "When the N4 link fails on both SRG nodes, a dual-stack IPoE subscriber session's bring-up is triggered post failure and recovery. This test is triggered by SRG's N4 link failure and recovered (P1 TC). \n\nConfiguration: Radius user profile with Active / Active configuration for SRG parameters, Spirent creating an IPoE client as a dual stack IPoE subscriber.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPost N4 link restoration, SRG roles are negotiated as per configs verification is performed.\nPost N4 link restoration, subscriber session bringup and count verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ds ipoe ipam pool exhaust",
                "Procedure": "To validate IPAM pool exhaustion, test steps are as follows: Create a new IPAM pool with 128 IPv4 and IPv6 addresses, assign it, configure it in CP, perform TGN config load, set up tunnels and Radius config, bring up subscriber sessions, verify the number of subscribers matches in UP and CP with no inconsistency, validate session count with IPAM pool address numbers, and conduct cleanup checks for system consistency. This test is triggered by assigning an IPAM pool with 128 IPv4 and IPv6 addresses only to a Dual Stack IPoE SRG subscriber.",
                "Pass/Fail Criteria": "Ipam pool allocation verification is performed.\nCnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nCp up session sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscribers will come up onlu until the IPAM pools are exhausted verification is performed.\nthe number of subscribers matches in UP and CP, no inconsistency verification is performed.\nSystem stability when having an IPAM pool with less address and try to bring up more subscribers verification is performed.\nIPAM pool verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ds ipoe vrf definition missing on standby",
                "Procedure": "When a test case for dual-stack IPoE subscriber sessions is triggered by the absence of VRF definitions in a standby UP, it involves configuring Radius user profiles and SRG nodes, then verifying that IPoE subscriber sessions can bring up successfully on both nodes with active-active configurations.\n\nThis test is triggered by the absence of VRF definition in standby UP (P1 TC).",
                "Pass/Fail Criteria": "Subscriber synchronize verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ds ipoe delete loopback on standby srg",
                "Procedure": "Dual-stack IPoE subscriber session bring-up occurs when VRF definitions are missing in the standby UP. This test is triggered by having a missing VRF definition in the standby SRG node, which allows the tester to validate IPOE Dual stack session bring-up under these conditions. The test case involves configuring Radius user profiles, scaling on both SRG nodes, removing the VRF definition from the standby SRG node, and configuring tracks and SRG parameters on the UP and CP. After clearing dynamic-routes and cp-srg association, performing SRG sync, verifying its success on the CP, and negotiating srg-roles properly on both UPs, pre-test validations are performed and Spirent is configured to bring up Dual stack IPoE subscriber sessions. Session details are verified, a loopback interface is attempted to be removed from the standby SRG node under cnbng-nal config, and a commit failure is expected as part of system stability verification before disconnecting the subscriber sessions. The configuration includes Radius user profiles, Spirent (creating IPoE clients), Dual stack IPoE subscribers, and SRG parameters with an Active / Active configuration.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg missing definitions",
                "Procedure": "When attempting to establish a dual-stack IPoE subscriber session, the test configures the necessary parameters and definitions for successful setup. The parameters that are removed from the UPs include QoS, ACL, and PBR configurations, which are then reconfigured on both nodes after scaling. Tracks and SRG parameters are set up on the CP, and the dynamic-routes are cleared to ensure a clean sync process. After verifying the SRG sync on the CP is successful, srg-roles negotiation between the two UPs is confirmed to be proper. This test takes into consideration configurations that would otherwise be missing in UP (P1 TC) such as qos, acl, pbr and also considers 'missing_config' parameter. \n\nThis test is triggered by configurations being removed from the Active and Standby UP, including QoS, ACL, and PBR definitions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmissing_config: \"qos\" and \"acl\" and \"pbr\"",
                "Pass/Fail Criteria": "Cnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg coa disconnect",
                "Procedure": "To test disconnecting a dual-stack IPoE subscriber session using CoA, the following steps must be taken: Configure a radius user profile and scale on both Service Rate Group (SRG) nodes. Next, configure tracks and SRG parameters on the upstream node, then configure the same SRG parameters on the central processor. Clear the dynamic routes and association between the SRG nodes, perform an SRG sync, and verify that it is successful. The roles should be negotiated properly on both upstream nodes. Pre-test validations are performed along with configuring Spirent, which creates a dual-stack IPoE client. Subscriber sessions are brought up in mixed VRF, then verified with radius Start checks. Further verification includes performing subscriber and SRG specific validations before initiating CoA Disconnect for all sessions. The subscriber sessions are then disconnected, and it's verified that they are completely down.\n\nThis test is triggered by a dual-stack IPoE subscriber session being configured with Active/Active configuration on the SRG parameters.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg missing definition one node",
                "Procedure": "The test case simulates a scenario where policy definitions are missing on one of the nodes with dual-stack IPoE subscribers. The test is triggered by a missing configuration for parameters such as pbr, acl, pbr_macoa, or qos. To configure the test environment, Radius user profiles, Spirent settings (including creating an IPoE client), and SRG parameters are set up to reflect Active/Active configuration. Dual-stack IPoE subscriber sessions are then brought up in a mixed VRF, with subscriber sessions verified with Radius Start check before further verification steps take place.\n\nThis test is triggered by the absence of a specified configuration for parameters such as 'pbr', 'acl', 'pbr_macoa', or 'qos'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmissing_config: \"pbr\" and \"acl\" and \"pbr_macoa\" and \"qos\"",
                "Pass/Fail Criteria": "Subscriber synchronize verification is performed.\nSubscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nPbr summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nPBR Summary check and Target verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Srg swo not ready default damping timer",
                "Procedure": "The test for SRG SWO is triggered when another node is not ready and the default damping timer (P0 TC) has been configured. To prepare, scale on both SRG nodes must be configured, as well as tracks and SRG parameters on the UP without the damping timer. The SRG parameters on CP also need to be configured, along with clearing dynamic-routes and cp-srg association, bringing down Core track at BNG2, performing and verifying an SRG sync that is successful on CP, and negotiating srg-roles properly on both UPs in Active / Standby mode. Additionally, default damping timer must be set to 120 seconds on all srg groups, tracks object failure at the Active node should then be performed, verifying all groups are in Standby / Standby mode, and finally the object is restored to running state with verification of SRG roles.\n\nThis test is triggered by another node being not ready and the default damping timer (P0 TC) being configured.",
                "Pass/Fail Criteria": "Cnbng up srg summary verification is performed.\nCnbng cp srg sync verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg coa during n4 failure",
                "Procedure": "The test case is designed to simulate a scenario where the n4 link on one of the nodes with dual stack IPoE subscribers breaks, triggering PBR activation. The test involves configuring Radius user profiles, setting up scale on both Service Router Gateway (SRG) nodes, and configuring tracks and SRG parameters on the User Plane (UP). Additional configurations include clearing dynamic routes and associations, syncing SRG parameters, verifying successful sync, negotiating srg-roles, performing pre-test validations, and configuring Spirent. The test also includes bringing up dual stack IPoE subscriber sessions in mixed VRF, verifying subscriber sessions with radius Start check, and performing SRG specific and CoA to activate service for all sessions.\n\nThis test is triggered by the n4 link being broken on one of the nodes with dual stack IPoE subscribers (P1 TC).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"pbr\" and \"acl\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCp up association verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber synchronize verification is performed.\nCnbng up srg summary verification is performed.\nPbr summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nPBR Summary check and Target verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe srg without preferred roles",
                "Procedure": "To test dual-stack IPoE Subscriber Resource Group (SRG) sessions without preferred roles in SRG groups, the following steps are taken: Configure a Radius user profile, set scaling on both SRG nodes, and configure tracks and SRG parameters on the User Plane. The Central Plane is then configured with SRG parameters without preferred roles, and the cnbng-nal dynamic-routes and cp-srg association are cleared. The system is synced, and it's verified that the sync was successful on the Central Plane. Next, subscriber sessions with Radius Start checks are brought up in mixed Virtual Routing and Forwarding (VRF), and detailed verification of each session is performed. SRG-specific validations are also carried out, followed by a switchover trigger to ensure success. Once complete, the subscriber sessions are disconnected, and it's verified that they're completely down.\n\nThis test is triggered by having a Radius user profile in place, Spirent configured with an IPoE client creating dual-stack IPoE subscribers, SRG parameters set for Active/Active configuration, and traffic streaming IPv4 and IPv6 bidirectional traffic.",
                "Pass/Fail Criteria": "Cnbng up srg summary verification is performed.\nSubscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg framed routes",
                "Procedure": "A test case is designed to validate the functionality of IPoE dual-stack session bring-up when framed routes are pushed from a radius server in a P0 topology control. The test involves configuring a radius user profile with framed routes, scaling both Service Routing Group (SRG) nodes, and setting up various parameters on the Universal Provider (UP) and Central Provider (CP). The configuration also includes clearing dynamic-routes and cp-srg associations, performing SRG sync to ensure synchronization is successful on the CP, verifying that srg-roles are negotiated correctly on both UPs, and configuring Spirent for creating an IPoE client. Once pre-test validations are complete, dual-stack IPoE subscriber sessions are brought up, with verification of session bring-up on both SRG nodes, followed by disconnection of the subscriber sessions. This test is triggered by a radius user profile that includes framed routes to be pushed from the server in the P0 topology control.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ncount: \"single\" and \"maximum\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nIpv4 route verification is performed.\nIpv6 route verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe srg add preferred roles while subscribers are up",
                "Procedure": "To test the functionality of dual-stack IPoE SRG subscriber sessions, configure a radius user profile, scale on both SRG nodes, and set tracks and SRG parameters. Without preferred roles, configure SRG parameters on the control plane. Clear dynamic-routes and cp-srg association, then perform an SRG sync to ensure it is successful on the control plane. Verify that SRG roles are negotiated properly between both units in use (UPs). Once validated, bring up dual-stack IPoE subscriber sessions with mixed VRF using a radius Start check. Perform detailed verification of these sessions and specific validations for SRG. Next, configure preferred roles in SRG groups, then perform an SRG switchover trigger to verify the switch is successful. After waiting for the revertive timer, re-perform SRG validations to confirm the preferred roles are taken.\n\nThis test is triggered by configuring preferred roles in SRG groups and performing an SRG switchover trigger.",
                "Pass/Fail Criteria": "Cnbng up srg summary verification is performed.\nSubscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg li",
                "Procedure": "To test Lawful Intercept functionality with dual-stack IPoE SRG subscriber sessions, configure a Radius user profile with specific Cisco-avpair settings. These include intercept-id, MD IP address, port number, DSCP value, and LI action. Due to system limitations, the actual LI scale is 511 but we're testing with 496 sessions to evenly distribute subscribers across 16 SRG groups. Configure scaling on both SRG nodes, set up tracks and SRG parameters on the upstream device, configure SRG parameters on the control plane without preferred roles, clear dynamic routes, perform SRG sync, and verify its success. Perform pre-test validations, bring up dual-stack IPoE subscriber sessions in mixed VRF, start check, perform detailed verification of subscribers, and specific SRG validations.\n\nThis test is triggered by configuring a Radius user profile with Cisco-avpair settings for intercept-id=abcd0012, md-ip-addr=<MD IP>, md-port=4545, md-dscp=7, li-action=1.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nTcam entry count verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTCAM entries verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg max lb pool",
                "Procedure": "When testing dual-stack IPoE SRG subscriber sessions with maximum loopbacks, pools, access interfaces, and groups, as well as fast switchover disabled, the following conditions should be met. Multiple address ranges are configured in the ipam pool, while multiple loopbacks are set up in both Service Request Gateway (SRG) units; a Radius user profile is also configured. The SRG nodes are scaled such that session counts are evenly distributed across 1472 access interfaces, and 1472 SRG groups are established on both the units and control plane. Tracks and SRG parameters are then configured on the units and control plane. The dynamic routes and cp-srg association are cleared before performing an SRG sync and verifying its success on the control plane; srg-roles are also negotiated properly on both units. Pre-test validations, Spirent configuration, and subscriber session bringup in mixed VRF are completed before verifying start checks for the subscriber sessions with Radius. Subscriber detailed verification is then performed, followed by specific SRG validations. The switchover trigger is initiated, and successful validation is confirmed. Finally, recovery from switchover brings back the system to its original state, after which specific SRG parameters are verified.\n\nThis test is triggered by enabling fast switchover on the Service Request Gateway (SRG) units.",
                "Pass/Fail Criteria": "Cnbng up srg summary verification is performed.\nSubscriber session details verification is performed.\nCnbng cp srg sync verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nSubscriber srg role based count verification is performed.\nSubscribers across srg grp verification is performed.\nSrg grp details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nDynamic routes verfification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg gil member operations",
                "Procedure": "Dual-stack IPoE subscribers with operations on GIL members and SRG trigger require a specific setup. This includes configuring the Radius user profile, scaling on both SRG nodes, setting tracks and SRG parameters on UP, configuring SRG parameters on CP, clearing cnbng-nal dynamic-routes and cp-srg association, and performing SRG sync to verify it's successful on CP. Verification steps include checking srg-roles negotiated properly on both UPs, bringing up dual stack IPoE subscriber sessions in mixed VRF, verifying subscriber sessions with radius Start check, and performing subscriber detailed verification. After adding new members to existing GIL, SRG specific validations are performed before and after the operation. Further testing involves triggering a SRG switchover, verifying its success and performing SRG specific validations, recovering from the switchover, bringing back to the original state, and verifying SRG specific parameters. Throughout these operations, Radius stats for session and service accounting should be verified.\n\nThis test is triggered by configuring SRG parameters with Active/Active configuration on both nodes.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nRadius accounting records verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nRadius accounting verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg ha no swo",
                "Procedure": "Here is the rewritten paragraph:\n\nTo test dual-stack IPoE subscriber sessions with HA triggers on a SRG environment without SRG SWO, we configure a Radius user profile, scale both SRG nodes, and set up tracks and SRG parameters on the UP and CP. We then clear dynamic routes and associations, synchronize SRG for both UPs, and perform pre-test validations and configure Spirent. The test verifies successful SRG sync on the CP, proper negotiation of srg-roles on both UPs, and dual-stack IPoE subscriber sessions in mixed VRF. We also verify subscriber sessions with radius start checks, perform subscriber detailed verification, and conduct SRG specific validations.\n\nThis test is triggered by performing HA triggers when traffic, churn, and CoA are running, with a minimum of 15 minutes between each process crash or restart to allow the system to settle down.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"process_restart\" and \"process_crash\" and \"rpfo\" and \"standby_rsp_oir\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nSubscriber srg role based count verification is performed.\nSubscribers across srg grp verification is performed.\nSrg grp details verification is performed.\nConsistency verification is performed.\nTraffic verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg ha swo",
                "Procedure": "The test case for dual-stack IPoE subscriber sessions with HA triggers on an SRG environment without SRG SWO is as follows. The HA triggers are performed as 'trigger' such as reload_up, cp_up_flap, admin_lc_reload, access_interface_flap, and graceful_swo, which will result in SRG SWO. To configure the test case, Radius user profiles, scale on both SRG nodes, tracks, and SRG parameters need to be set up on both UPs and CP. Additionally, cnbng-nal dynamic-routes and cp-srg association should be cleared, and SRG synchronize for both UPs needs to be performed. Pre-test validations and Spirent configuration are also required. Once the test case is configured, it is verified that SRG sync is successful on CP, srg-roles are negotiated properly on both UPs, dual-stack IPoE subscriber sessions bringup in mixed VRF, and subscriber sessions with Radius start check. The test case further involves starting bidirectional IPv4, IANA & IAPD traffic for some subscribers and performing subscriber churn with different variants such as un-auth churn, client reboots, graceful release and connect, and address-family flaps. It also includes triggering the CoA for account update on all subscribers, performing HA triggers when traffic, churn, and CoA are running, verifying SRG roles negotiated after HA triggers, allowing 10 minutes in case of n4_link failure, verifying that traffic went fine for subscribers which were not under churn, waiting for revertive timer to revert the SRG roles, disconnecting subscriber sessions, and verifying that subscriber sessions are completely down.\n\nThis test is triggered by HA triggers such as 'reload_up', 'cp_up_flap', 'admin_lc_reload', 'access_interface_flap', 'graceful_swo'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload_up\" and \"cp_up_flap\" and \"admin_lc_reload\" and \"access_interface_flap\" and \"graceful_swo\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nConsistency verification is performed.\nTraffic verification is performed.\nCnbng up srg summary verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber srg role based count verification is performed.\nSubscribers across srg grp verification is performed.\nSrg grp details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg stress",
                "Procedure": "Here's the rewritten paragraph with the trigger sentence at the end:\n\nThis test case is triggered by taking the HA triggers as 'none' or 'core_track_flap'. It involves configuring a Radius user profile, scaling on both Service Router Gateway (SRG) nodes, and setting up tracks and SRG parameters. The configuration also includes clearing dynamic-routes and cp-srg associations, synchronizing SRG for both User Ports (UPs), and performing pre-test validations with Spirent. The test verifies that the SRG sync is successful on the Control Plane (CP), that srg-roles are negotiated properly, and that dual stack IPoE subscriber sessions bring up in mixed Virtual Routing and Forwarding (VRF). Further verification includes checking for subscriber sessions with radius Start check, performing subscriber detailed verification, and specific validations. The test then simulates churn on the subscribers using various scenarios: un-auth churn, client reboots, graceful release and connect, and address-family flaps. As the churn is running, stress triggers are performed, and the roles negotiated after stress triggers are verified. Finally, subscriber sessions are disconnected and verified to be completely down.\n\nConfiguration: Radius user profile, Spirent (creating IPoE client), dual stack IPoE subscriber, SRG parameters with Active/Active configuration\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"none\" and \"core_track_flap\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nConsistency verification is performed.\nCnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nSubscriber srg role based count verification is performed.\nSubscribers across srg grp verification is performed.\nSrg grp details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe srg high incoming requests",
                "Procedure": "High incoming CoA/MA-CoA cases or High incoming CPs on dual-stack IPoE SRG subscribers trigger a test that involves configuring the following: a Radius user profile, scale on both SRG nodes, tracks and SRG parameters on UP, SRG parameters on CP, clearing dynamic-routes and cp-srg association, synchronizing SRG for both UPs, performing pre-test validations and configuring Spirent. The test verifies successful synchronization of SRG sync on CP, proper negotiation of srg-roles on both UPs, and dual stack IPoE subscriber sessions bringup in mixed VRF. It also involves verifying subscriber sessions with Radius Start check, performing subscriber detailed verification, simulating high incoming CoA/MA-CoA requests, and checking the consistency of subscriber sessions.\n\nThis test is triggered by specific HA triggers such as 'coa', 'macoa', or 'cps'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration('test_high_incoming_requests/triggers')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nContext verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nCp up session sync verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nDHCP binding summary verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe srg feature performance",
                "Procedure": "Here is the rewritten paragraph:\n\nThe test involves characterizing the Count Per Second (CPS) performance of bringing up and bringing down Internet Protocol over Ethernet (IPoE) Subscriber Reference Group (SRG) sessions with feature template profiles. The test cases include measuring the CPS for a large subscriber scale of 128K, with various configurations such as flow control rates, Radius user profiles, and SRG parameters. Additionally, the test involves verifying the successful negotiation of srg-roles on both User Ports (UPs), performing pre-test validations, configuring Spirent, and bringing up and down IPoE dual-stack subscriber sessions simultaneously while polling for the subscriber count.\n\nThis test is triggered by a combination of LC Type: THK, RSP Type: RSP5-SE / RSP-880, Subscriber Type: IPoE SRG, and Config Profile: Features.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nsession_stack: \"ApData.zap.get_testcase_configuration().get('performance_session_stack', ['IPV4V6', 'IPV4', 'IPV6'])\"",
                "Pass/Fail Criteria": "Cnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nRedundancy group id verification is performed.\nCPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe srg race track performance",
                "Procedure": "Test IPoE SRG session bringup & bringdown is characterized by measuring Count Per Second (CPS) with Racetrack profiles, specifically for P1 TC. The test focuses on the combination of Local Concentrator Type: THK, RSP Type: RSP5-SE / RSP-880, and Subscriber Type: IPoE SRG with 128K subscribers. Configuration includes features enabled, 0 and unlimited retries, bringup CPS of 200, and bringdown CPS of 200 from the client side. Time is measured for both bringup and bringdown in seconds. Pre-test validations involve configuring flow control rate on SRG nodes, Radius user profile, scale on both SRG nodes, tracks, and SRG parameters on UP and CP. Additional steps include clearing cnbng-nal dynamic-routes and cp-srg association, performing SRG sync, verifying srg-roles negotiation, and configuring spirent for polling subscriber count.\n\nThis test is triggered by the configuration of IPoE subscriber sessions with spirent and a Radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nsession_stack: \"ApData.zap.get_testcase_configuration().get('performance_session_stack', ['IPV4V6', 'IPV4', 'IPV6'])\"",
                "Pass/Fail Criteria": "Cnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nRedundancy group id verification is performed.\nCPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ipoe srg unidimensional performance",
                "Procedure": "The test characterizes the performance of IPoE SRG Unidimensional CoA/MA-CoA in a unidimensional scenario where only CoA/MA-CoA requests are processed by the system. This is triggered by sending CoA requests at a rate of 80 per second, with a timeout of 3 seconds and one retry.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration().get('trigger_type', ['coa', 'macoa'])\"",
                "Pass/Fail Criteria": "Cnbng cp srg sync verification is performed.\nCnbng up srg summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber session count verification is performed.\nSubscriber session bringup verification is performed.\nMeasure the rate at which CoA/MA-CoA got processed verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bng_ipoe_pppoe_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Dual stack ipoe pppoe default vrf",
                "Procedure": "This test is triggered by sending a list of configuration modes, such as radius or dynamic-template, to the system under test. The test brings up and then brings down dual-stack subscriber sessions using IPoE and PPPoE over default VRF, with various authentication methods, IPv4 address allocation methods, and IPv6 address configuration methods. It also covers DHCPv6 prefix delegation and performs bidirectional IPv4 and IPv6 traffic tests. The test uses a Spirent system to create clients, sends traffic using a traffic stream, and verifies subscriber sessions and service accounting with a radius user profile configured on the system under test.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration('configuration_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp process verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp process before session bringup verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe non default vrf",
                "Procedure": "Here is the rewritten paragraph:\n\nThis test involves bringing up and down dual-stack subscriber sessions for IPoE and PPPoE in non-default VRF. The test takes into account various configuration modes, including radius and dynamic-template, and covers different methods of IPv4 address allocation through radius or local address pools. It also includes multiple ways to configure CPE WAN interface IPv6 addresses using IANA or DHCPv6 address pools, as well as performing DHCPv6 prefix delegation over IPoE-PPPoE with various methods. Additionally, it assigns attributes from the radius in access-accept, including DNS servers and prefix lengths. The test runs bidirectional IPv4 and IPv6 traffic, with sources derived from CPE WAN or LAN IPv6 addresses, and verifies subscriber sessions and service accounting.\n\nThis test is triggered by specifying a list of configuration modes, such as \"radius\" or \"dynamic-template\", in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration('configuration_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp process verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp process before session bringup verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cp up reconciliation",
                "Procedure": "To test the CP-UP reconciliation process, we must first bring up dual-stack IPoE and PPPoE subscriber sessions that are distributed in both default and non-default VRFs. The CP-UP transport should then be broken and some sessions cleared in CP. This triggers a reconciliation from CP to ensure that all data is consistent. Next, deleted sessions need to be reconnected from TGEN. Finally, we must run bidirectional IPv4 and IPv6 subscriber traffic through the system. The configuration for this test involves dual-stack IPoE and PPPoE subscribers in both default and non-default VRFs, a Spirent device that creates IPoE and PPPoE clients, a traffic stream with bidirectional IPv4 and IPv6 traffic, and a RADIUS user profile.\n\nThis test is triggered by breaking the CP-UP transport.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCp up association verification is performed.\nSubscriber synchronize verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nCP-UP Connection Status is down/up verification is performed.\nAll the session not there in CP deleted from UP post reconciliation. verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe coa",
                "Procedure": "The test involves testing COA operations on dual-stack IPoE and PPPoE subscriber sessions, including CNBNG and PBNG. It performs combinations of account-status-query, account-update, activate-service, and deactivate-service CoA operations while running bidirectional IPv4 and IPv6 traffic with the source set as either the CPE WAN IPv6 address or the CPE LAN IPv6 address derived from a delegated prefix. The test also includes disconnecting subscriber sessions using a Disconnect Message, verifying the subscriber session, and checking service accounting. This test is triggered by a Spirent configuration that creates IPoE and PPPoE clients with dual-stack subscribers in default and non-default VRFs, generates bidirectional IPv4 and IPv6 traffic streams, and uses a sample radius user profile with password and device pass authentication.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp process verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp process before session bringup verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe qos input output radius user profile",
                "Procedure": "Configuring Quality of Service (QoS) Input and Output policies on the RADIUS server brings up dual-stack Internet Protocol over Ethernet (IPoE) and Point-to-Point Protocol over Ethernet (PPPoE) subscriber sessions distributed in both default and non-default Virtual Routing Forwarding (VRF) instances. This test is triggered by a configuration type specified as a list, including \"qos_in_out_radius\", \"qos_in_out_radius_non_qos_service\", and \"qos_non_qos_radius\", which are defined in the input file under 'testcase_configuration/configuration_type'. The setup involves creating IPoE/PPPoE clients using Spirent, generating bidirectional IPv4 and IPv6 traffic streams, and configuring a RADIUS user profile with QoS policies for input and output.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('configuration_type', ['qos_in_out_radius'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nPbr summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nTraffic verification verification is performed.\nAccounting on router verification is performed.\nPBR summary verification (When Non-QoS service applied) verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe dynamic pool add delete",
                "Procedure": "To test the bringing up of dual-stack subscriber sessions for both IPoE and PPPoE, configure RADIUS with a user profile and 32 address pools in the default VRF, then create dual-stack subscribers with Spirent clients. After this, mark the 32 address pools offline and delete them. Next, configure 32 address pools in a non-default VRF and add dual-stack subscribers in that VRF.\n\nThis test is triggered by: a list of configuration types, including \"max_pools\" and \"excessive_pools\", specified under 'testcase_configuration/pool_conf_type' in the input file.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('pool_conf_type', ['max_pools'])\"",
                "Pass/Fail Criteria": "Offline address pools verification is performed.\npool verification verification is performed.\nSubscriber session verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe single session replay",
                "Procedure": "Test Single session replay on dual-stack IPoE/PPPoE subscriber sessions(CNBNG). This test checks the bringup and bringdown of IPoE/PPPoE dual-stack subscriber sessions, distributed in default and non-default VRFs, and then performs churn with access flaps and core flaps. The method uses a list to specify the configuration type, such as port flaps only or control plane up flaps, which is defined in an input file under 'testcase_configuration/churn_with_flap'. The test involves bringing up IPoE/PPPoE dual-stack subscriber sessions from Spirent, verifying the subscriber session configuration, and uses a Spirent client to create IPoE/PPPoE subscribers with radius user profiles. This test is triggered by specifying conf_type = [\"port_flaps_only\", \"cp_up_flaps\"] in the input file.\n\nNote: The rewritten trigger sentence has been placed at the end of the paragraph as requested.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('churn_with_flap', ['port_flaps_only'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSession replay verification is performed.\nConsistency verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verfication verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe negative qos input output radius",
                "Procedure": "Dual-stack IPoE/PPPoE subscriber sessions are brought up in a distributed manner, both in the default and non-default VRFs. The setup involves configuring Quality of Service (QoS) policies for both input and output traffic on the RADIUS server and attempting to bring up dual-stack IPoE/PPPoE subscriber sessions. This test takes into account two configuration types specified in an input file: \"same_service_definition_cp\" and \"missing_definition_up\". The test scenario includes a setup where dual stack IPoE & PPPoE subscribers are distributed across default and non-default VRFs, with a Spirent tool generating IPoE/PPPoE clients. Additionally, the RADIUS user profile is configured to include QoS policies.\n\nThis test is triggered by providing a list of configuration types as conf_type = [\"same_service_definition_cp\", \"missing_definition_up\"] in the input file under 'testcase_configuration/negative_conf_type'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('negative_conf_type', ['same_service_definition_cp'])\"",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session check verification is performed.\nCPU Utilization verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe qos input output radius coa same policy",
                "Procedure": "A test is set up to bring up dual-stack subscriber sessions using both IPoE and PPPoE protocols, distributed in default VRF and non-default VRF. This test is triggered by a scenario where a Spirent device creates an IPoE/PPPoE client with radius user profiles having QoS input and output policies configured, and then generates bidirectional IPv4 and IPv6 traffic streams. The goal of the test is to enable the same policy (CNBNG) in all cases and perform CoA to bring up the dual-stack subscriber sessions successfully.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe pool exhaustion",
                "Procedure": "To simulate test pool exhaustion with dual-stack IPoE/PPPoE subscriber sessions, configure a pool with fewer addresses than expected and start bringing up subscriber sessions. When the pool becomes exhausted, subscriber sessions will fail to come online, but the system should remain consistent. The configuration involves defining an address pool containing fewer addresses than the total number of subscribers (50K) and then bringing up 50K subscribers.\n\nThis test is triggered by configuring a dual-stack IPoE/PPPoE subscriber session with a defined address pool having fewer addresses than the actual number of subscribers, which in this case is 50K.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nIpam pool allocation verification is performed.\nPpp process verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber disconnect count verification is performed.\nPpp process before session bringup verification is performed.\nCp up session sync verification is performed.\nPool Allocation (pre + after sessions established + post) verification is performed.\nSubscriber session check verification is performed.\nCPU Utilization verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe frame routes",
                "Procedure": "When testing dual-stack subscriber sessions, a test is triggered by the scenario where excess or invalid or maximum framed routes (CNBNG) are configured for IPoE/PPPoE subscribers. The test involves configuring framed routes for subscribers from RADIUS and attempting to bring up both IPv4 and IPv6 dual-stack sessions using Spirent devices as clients with a specific RADIUS user profile containing IPv4 and IPv6 framed routes in both the default and non-default VRFs.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('fr_conf_type', ['excess'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber session count verification is performed.\nPool verification verification is performed.\nSubscriber session check verification is performed.\nCPU Utilization verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe pool add delete while sessions up",
                "Procedure": "Configuration for testing addition and deletion of address pools while dual-stack subscriber sessions are up involves the following steps: configure a radius user profile, create 16 address pools in the default virtual routing and forwarding (VRF), set up dual-stack IPoE/PPPoE subscribers in the default VRF using Spirent to simulate IPoE and PPPoE clients, start session churn on the subscribers, add 16 non-default VRF pools, delete the same number of non-default VRF pools, update the configuration with 16 address pools in non-default VRF, set up dual-stack IPoE/PPPoE subscribers in non-default VRF using Spirent to simulate clients. This test is triggered by bringing down subscribers.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nConsistency verification is performed.\nPool verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nSubscriber session verification verification is performed.\nConsistency verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe invalid pools",
                "Procedure": "Dual-stack IPoE/PPPoE subscriber sessions are brought up with invalid pools configured in the CP (CNBNG). To test this scenario, configure invalid pools in the CP and attempt to bring up dual stack IPoE/PPPoE subscriber sessions. The configuration involves dual stack IPoE & PPPoE subscribers on 32 pools, a Spirent tool for creating an IPoE/PPPoE client, and a radius user profile.\n\nThis test is triggered by configuring invalid pools in the CP (CNBNG).",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPool verification verification is performed.\nSubscriber session check verification is performed.\nCPU Utilization verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe frame routes coa",
                "Procedure": "Dual-stack IPoE/PPPoE subscriber sessions are brought up with framed routes for CNBNG and P0 testing. This test involves configuring framed routes from the RADIUS server and attempting to bring up dual-stack IPoE/PPPoE subscriber sessions on a device with Spirent creating an IPoE/PPPoE client, where the RADIUS user profile includes both IPv4 and IPv6 framed routes. \n\nThis test is triggered by having a radius user profile that includes both ipv4 / ipv6 framed routes.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPool verification verification is performed.\nSubscriber session check verification is performed.\nCPU Utilization verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe qos input output coa",
                "Procedure": "Dual-stack IPoE & PPPoE subscriber sessions are brought up and down in both default and non-default VRF configurations, specifically in a Critical Network Bringup/Bringdown Network Gap (CNBNG) scenario. The goal is to test these sessions against Quality of Service (QoS) policies configured on the RADIUS server. The configuration involves: dual-stack IPoE & PPPoE subscribers distributed across default and non-default VRFs, Spirent equipment generating an IPoE/PPPoE client, bidirectional traffic streams for both IPv4 and IPv6, and a RADIUS user profile with QoS input/output policies in place.\n\nThis test is triggered by creating an IPoE/PPPoE client using Spirent equipment.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nQos interface verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nTraffic verification verification is performed.\nAccounting on router verification is performed.\nPBR summary verification (When Non-QoS service applied) verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe subscriber disconnect",
                "Procedure": "Dual-stack IPoE & PPPoE subscriber sessions are brought up and down using a distributed configuration in both default and non-default VRFs (CNBNG) for Priority 0 testing. This involves bringing up the sessions and then closing them using CoA Disconnect, Lease/Keepalive expiry, or CP CLI Clear commands. The setup consists of dual-stack IPoE & PPPoE subscribers distributed across both default and non-default VRFs, with a Spirent device creating the IPoE/PPPoE client, and a radius user profile to manage the session settings. This test is triggered by the configuration described above.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe pool exhaustion churn",
                "Procedure": "Dual-stack IPoE and PPPoE subscriber sessions are brought up on exhaustive address pools, with the goal of starting churn. This test is triggered by trying to bring up dual stack IPoE and PPPoE subscribers with 16 exhaustive address pools using a Spirent system that creates IPoE/PPPoE clients and applies a RADIUS user profile with the specified configuration.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nIpam pool allocation verification is performed.\nSubscriber synchronize verification is performed.\nCp up session sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nSubscriber session verification verification is performed.\nConsistency verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack ipoe pppoe bringup sanity",
                "Procedure": "IPoE & PPPoE dual-stack subscriber sessions bringup & bringdown are distributed in both the default and non-default Virtual Routing Forwarding (VRF) configurations, including CNBNG and PBNG. This test is triggered by creating a Spirent IPoE/PPPoE client for testing purposes.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp process verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp process before session bringup verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Coexistence standalone dhcp",
                "Procedure": "To test the coexistence of standalone dhcp v4/v6 relay/proxy/server, configure cnBNG to operate as a standalone dhcp v4/v6 relay/proxy/server. Bring up non-subscribers and cnBNG IPoE & PPPoE subscribers with a configuration that includes dual stack IPoE & PPPoE subscribers in default and non-default VRFs along with non-subscribers, using Spirent to create IPoE & PPPoE clients and a DHCP server, and RADIUS user profiles such as the following: {ApData.device_user: {'password': ApData.device_pass}}.\n\nThis test is triggered by the configuration of cnBNG as a standalone DHCP v4/v6 relay/proxy/server, with dual stack IPoE & PPPoE subscribers in default and non-default VRFs.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nDhcp proxy binding summary verification is performed.\nDhcp ipv4 server binding non subscriber verification is performed.\nIpv4 route summary verification is performed.\nIpv6 route summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nDhcpverifyerror verification is performed.\nPool allocation verification verification is performed.\nSubscriber session verification verification is performed.\nNon subscriber session verification verification is performed.\nQos interface verification is performed.\nACL Verification verification is performed.\nFADB Verification verification is performed.\nSubscriber clean-up verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Gil interface combination",
                "Procedure": "When testing the bundle-only/bundle-physical mix combo interfaces in generic-interface-list, the method takes a list named gil_type specified in the input file as either \"bundle\" or \"mix\". The test case involves setting up IPoE & PPPoE dual-stack subscriber sessions distributed in default and non-default VRF from Spirent with CHAP authentication, double tag VLAN, and default VRF. Bidirectional IPv4 and IPv6 traffic is then run, with the latter sourced from either the CPE WAN or LAN IPv6 address. After bringing down the subscriber sessions, the test verifies subscriber session and service accounting. Configuration includes dual-stack IPoE & PPPoE subscribers in default and non-default VRF using RJIL, ALTIBOX, and VODAFONE profiles, Spirent for creating IPoE & PPPoE clients, traffic streams with bidirectional IPv4 and IPv6 traffic, and a RADIUS user profile. This test is triggered by the bundle-only/bundle-physical (mix) combo interfaces in generic-interface-list (CNBNG and PBNG).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ngil_type: \"ApData.zap.get_testcase_configuration('gil_type')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp process verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp process before session bringup verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Coexistence bundle pwhe",
                "Procedure": "To test the coexistence of both Bundle and pwhe subscribers with dual stack IPoE and PPPoE subscribers, a specific configuration is set up on an ASR9K device. This involves configuring Bundle/pwhe interfaces in cnBNG UP mode and bringing up 25,000 subscribers over both the Bundle access-interface and the pw-ether access interface.\n\nThis test is triggered by configuring a Spirent setup with IPoE and PPPoE clients and RADIUS user profiles using a sample profile that contains device user information, including passwords.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nNon subscriber session verification is performed.\nQos interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSubscriber clean-up verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Multiple pseudowires over same gil",
                "Procedure": "Configuring a GIL interface with two pindown members and attaching it to multiple PWHE access interfaces is the first step in testing dual-stack IPoE & PPPoE subscriber sessions. This involves bringing up 50K dual-stack subscriber sessions over multiple pw-ether interfaces, running bidirectional IPv4 and IPv6 subscriber traffic, then shutting down the subscriber sessions to verify that session and service accounting are working correctly.\n\nThis test is triggered by a specific combination of profile, including RJIL, ALTIBOX, and VODAFONE, used in the default VRF.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp process verification is performed.\nQos interface verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp process before session bringup verification is performed.\nPool verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Max interfaces",
                "Procedure": "To test the maximum supported interfaces in a pindown list with dual-stack IPoE & PPPoE subscribers, configure one GIL interface with 8 members and bring up subscriber sessions. Run bidirectional ipv4 & ipv6 subscriber traffic through Spirent (creating IPoE & PPPoE clients) and Traffic Stream (ipv4 and ipv6 bidirectional traffic), using a radius user profile to authenticate the subscribers. The configuration includes dual stack IPoE & PPPoE subscribers in default VRF, with RJIL, ALTIBOX, and VODAFONE profiles used for this test case.\n\nThis test is triggered by verifying subscriber session and service accounting after bringing down subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp process verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp process before session bringup verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pwhe on stick",
                "Procedure": "Dual-stack IPoE & PPPoE subscriber sessions are tested in a stick scenario with dual-stack CNBNG, P0 TC. The core and CP connectivity are configured via the same access PW (stick). Dual-stack IPoE & PPPoE subscriber sessions are brought up, distributed in default and non-default VRFs. Bidirectional ipv4 & ipv6 subscriber traffic is run. The subscriber sessions are then brought down.\n\nThis test is triggered by configuring a spirent with IPoE & PPPoE clients, sending bidirectional ipv4 and ipv6 traffic via a traffic stream, and using a radius user profile such as 'user_profile = {ApData.device_user: {'password': ApData.device_pass}}' for RJIL, ALTIBOX, or VODAFONE profiles.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bng_l2tp_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Cnbng nal association",
                "Procedure": "The test of CP-UP Association verifies the connection status after breaking and restoring connectivity, clearing association, unconfiguring and reconfiguring NAL configurations. It checks that the connection is initially up, then goes down after three heartbeats, and eventually returns to an up state. The configuration for this test involves applying and removing ACLs on management interfaces, as well as configuring and deconfiguring cnBNG-NAL settings. This test is triggered by a trigger associated with the release of the association from the UP state.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nl2tp_node: \"lac\" and \"lns\"",
                "Pass/Fail Criteria": "Cp up association verification is performed.\ncnbng-nal association status CLI on UP verification is performed.\nshow peers CLI on CP verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Userplane offline",
                "Procedure": "When testing the Up Offline mode in Control Plane (CP), we first configure both the control-plane and user-plane with specific configurations. Next, we put the user-plane into OFFLINE mode, removing its configuration from CP and then reconfiguring it. We also remove and reconfigure the cnbng-nal config on the user-plane.\n\nThis test is triggered by a change to the UP OFFLINE state in Control Plane (CP).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nl2tp_node: \"lac\" and \"lns\"",
                "Pass/Fail Criteria": "Cp up association verification is performed.\ncnbng-nal association status CLI on UP verification is performed.\nshow peers CLI on CP verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp vrf",
                "Procedure": "The test for dual-stack L2TP subscriber sessions covers both bringup and bringdown scenarios in various VRF configurations, including default, non-default, and mixed (default and non-default) VRFs. This test is triggered by the method taking a list of configuration types, specified in the input file under 'testcase_configuration', which includes \"mixed_vrf\", \"default_vrf\", and \"non_default_vrf\". The test involves setting up PPPoE dual-stack subscriber sessions from Spirent, assigning specific attributes from LAC and LNS RADIUS servers, running bidirectional IPv4 and IPv6 traffic, bringing down the subscriber sessions, and verifying session and service accounting.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('vrf_type', ['mixed_vrf'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nLacradius accounting records verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp pod operations",
                "Procedure": "L2TP dual-stack subscriber sessions are tested when distributed in both default and non-default Virtual Routing Forwarding (VRF) and performed in a POD operation. This test brings up and down PPPoE dual-stack subscriber sessions using the Spirent tool, assigning specific attributes from both LAC and LNS radius servers. The attributes assigned include Tunnel-Assignment-Id, primary-dns or Ascend-Client-Primary-DNS, secondary-dns or Ascend-Client-Secondary-DNS, DNS-Server-IPv6-Address or ipv6-dns-servers-addr. The test then runs bidirectional IPv4 and IPv6 traffic before bringing down the subscriber using a CoA disconnect/POD operation, and verifies the subscriber session and service accounting. This method takes in a list named conf_type = [\"LAC\", \"LNS\"] which is specified in the input file under 'testcase_configuration'. This test is triggered by a configuration that includes dual-stack L2TP subscribers distributed in default and non-default VRF, Spirent, traffic stream, and radius user profiles.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"LAC\" and \"LNS\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nLacradius accounting records verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp coa",
                "Procedure": "Testing COA operations on dual-stack L2TP subscriber sessions involves bringing up and down the session, both with and without a default VRF. It also performs various changes of authorization (CoA) operations, including account-status-query, account-update, activate-service, and deactivate-service. The test uses bidirectional IPv4 traffic and IPv6 traffic sourced from both the CPE WAN address and the delegated prefix. Additionally, it simulates disconnecting a subscriber session using a POD Disconnect Message. Finally, it verifies that the subscriber session and service accounting are correct.\n\nThis test is triggered by running a L2TP client created by Spirent, with a dual-stack subscriber in the default VRF, and using an IP traffic stream configured to simulate both IPv4 and IPv6 bidirectional traffic.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nLacradius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp lac bundle across lc",
                "Procedure": "Dual-stack L2TP subscriber sessions are tested over a multi-member bundle across Local Concentrator (LC) by configuring the bundle interface with two links, bringing up dual-stack L2TP subscriber sessions in both default and non-default Virtual Routing and Forwarding (VRFs), running bidirectional IPv4 and IPv6 subscriber traffic, and then shutting down the subscriber sessions. This test is triggered by configuring a dual-stack L2TP subscriber session in default and non-default VRFs, Spirent device configuration, a traffic stream, and a RADIUS user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_members: \"ApData.zap.get_testcase_configuration('bundle_lc_members')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nLacradius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp lac bundle across np",
                "Procedure": "To test dual-stack L2TP subscriber sessions over a multi-member bundle across two nodes from the same location controller, you need to configure the bundle interface with two links on both nodes. Then bring up the dual-stack L2TP subscriber sessions in default and non-default VRFs, run bidirectional IPv4 and IPv6 traffic through the subscriber sessions, and finally bring down the subscriber sessions.\n\nThis test is triggered by a configuration consisting of a dual-stack L2TP subscriber in default and non-default VRFs, Spirent device setup, traffic stream creation, and a RADIUS user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_members: \"ApData.zap.get_testcase_configuration('bundle_np_members')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nLacradius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp lns bundle across np lc",
                "Procedure": "Dual-stack L2TP subscriber sessions are tested over a multi-member bundle across the Load Controller (LC) on the Local Network Server (LNS). To test this scenario, the bundle interface is configured with two links across LC on LNS. Dual-stack L2TP subscriber sessions are then brought up and distributed in both default and non-default Virtual Routing and Forwarding (VRFs), while bidirectional IPv4 and IPv6 subscriber traffic is run. Finally, the subscriber sessions are brought down.\n\nThis test is triggered by configuring a dual-stack L2TP subscriber in both the default and non-default VRFs, along with Spirent device configuration, a traffic stream, and a RADIUS user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_mode: \"ApData.zap.get_testcase_configuration('lns_bundle_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nLacradius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack lac bundle across np lc addition deletion",
                "Procedure": "LAC Bundle addition/deletion operations on dual-stack L2TP subscriber sessions test the bring-up and bring-down of L2TP dual-stack subscriber sessions in both default and non-default VRF while adding or removing bundle members dynamically. The test involves bringing up L2TP subscriber sessions, adding a new link to the same bundle as sessions come online, and running bidirectional IPv4 and IPv6 traffic once all sessions are active. It then proceeds by bringing down subscriber sessions, removing the link from the bundle where sessions go offline, adding another link in the same bundle as sessions come back up, and finally bringing up subscribers again while removing the original link from the bundle.\n\nThis test is triggered by a configuration featuring dual-stack L2TP subscribers in both default and non-default VRF, an Spirent device creating the L2TP client, traffic streams of bidirectional IPv4 and IPv6 traffic, and a RADIUS user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_mode: \"ApData.zap.get_testcase_configuration('bundle_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber session count verification is performed.\nCnbng session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack lns bundle across lc addition deletion",
                "Procedure": "L2TP dual-stack subscriber session bring-up and bringdown operations are tested, including adding and removing bundle members on the fly. This test is triggered by a configuration consisting of a dual stack L2TP subscriber in both default and non-default VRFs, an Spirent creating an L2TP client, and a traffic stream generating bidirectional IPv4 and IPv6 traffic as well as a RADIUS user profile.",
                "Pass/Fail Criteria": "L2tp tunnel summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp macoa",
                "Procedure": "Dual-stack L2TP subscriber sessions are tested for MA-CoA operations on dual-stack L2TP sessions. This test is triggered by performing various CoA operations, including account-status-query, Account-update, Activate-service, and Deactivate-service, while running both IPv4 and IPv6 bidirectional traffic from a Spirent device creating an L2TP client in the default VRF with a radius user profile configured for dual-stack L2TP subscribers.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nLacradius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp clear sessions",
                "Procedure": "L2TP dual-stack subscriber sessions are tested by bringing up and down both the default and non-default VRFs, then clearing subscribers from the Control Plane (CP), either from the Local Access Concentrator (LAC) or the Network Access Server (LNS). This is triggered by sending a CP Disconnect Message to disconnect the subscriber session. The test verifies that the subscriber session and tunnel count are correctly updated after bringing up and down the sessions, and that there is bidirectional traffic (IPv4 and IPv6) between the L2TP client and the server as configured in the RADIUS user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nl2tp_node: \"lac\" and \"lns\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp clear tunnel",
                "Procedure": "The test involves verifying the functionality of dual-stack L2TP subscriber sessions, including bringup and bringdown operations within default and non-default Virtual Routing Forwarding (VRF) environments. The process includes clearing tunnels from the control point using a Disconnect Message and then checking the subscriber session and tunnel counts. A specific configuration is used for this test: it involves a dual-stack L2TP subscriber in a mixed VRF setup, where Spirent creates an L2TP client and simulates bidirectional IPv4 and IPv6 traffic through a radius user profile.\n\nThis test is triggered by creating an L2TP client using Spirent to simulate bi-directional IPv4 and IPv6 traffic with a dual-stack subscriber in a mixed VRF configuration and applying a radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nl2tp_node: \"lac\" and \"lns\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2tp tunnel keepalive",
                "Procedure": "The test confirms the behavior of the L2TP tunnel Keepalive mechanism. When a failure occurs, subscriber sessions should go down first, followed by the entire tunnel when all sessions are closed. To test this, the PPP keepalive retry is set to a higher number on both the LNS control plane and tunnel gateway node to prevent initial session failures. Subscriber sessions are brought up and verified as active, then traffic flows in both directions over IPv4 and IPv6 connections while accounting records are generated on the RADIUS servers of the local access concentrator (LAC) and tunnel gateway (TGN). The L2TP keepalive mechanism is simulated by shutting down IP connectivity to either the source or destination interface of the tunnel. This should cause sessions to drop first, followed by the entire tunnel, with corresponding disconnect reason recorded on RADIUS. After resetting the PPP keepalive retry to its default setting and restoring IP connectivity, subscriber sessions are brought back up and verified as active along with traffic and accounting records. The test concludes with a graceful session teardown and final cleanup verification. This test is triggered by shutting down L2TP tunnel IP connectivity (src or dst interface).",
                "Pass/Fail Criteria": "Radius accounting records verification is performed.\nSubscriber summary verification is performed.\nL2tp tunnel summary verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nRadius accounting verification on LAC and LNS verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp cp up reconciliation",
                "Procedure": "Dual-stack L2TP subscriber sessions are brought up with CP-UP Recon on the LAC or LNS side, and PPPoE dual-stack subscriber sessions from Spirent are also established. To facilitate this, certain attributes must be assigned by the radius server: Tunnel-Assignment-Id is required from the LAC in access-accept, while primary-dns, secondary-dns, DNS-Server-IPv6-Address, and ipv6-dns-servers-addr must come from the LNS via cisco AVPs. After setup, transport is broken and some sessions are cleared in CP before reconciliation triggers a reconnect of deleted sessions back from TGEN. Traffic for both IPv4 and IPv6 is then run in both directions, followed by verification of subscriber session and service accounting, and finally the subscriber sessions are brought down. This test involves dual-stack L2TP subscribers distributed across default and non-default VRFs, using Spirent, a traffic stream, and radius user profiles.\n\nThis test is triggered by bringing up PPPoE dual-stack subscriber sessions from Spirent and assigning specific attributes as described above.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"LAC\" and \"LNS\"",
                "Pass/Fail Criteria": "Cp up association verification is performed.\nSubscriber synchronize verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2tp memory utils",
                "Procedure": "Memory statistics are collected during bringup/bringdown by bringing up single-stack or dual-stack L2TP subscriber sessions in mixed VRFs, collecting memory statistics, and then bringing down the subscriber sessions. This test is triggered by bringing up a single or dual stack L2TP subscriber with Spirent creating an L2TP client, using a radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmemory_subscriber_stack: \"ApData.zap.get_testcase_configuration('memory_subscriber_stack')\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nPool verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lns pppoe keepalive",
                "Procedure": "The test case confirms the behavior of the LNS PPPoE Keepalive mechanism. The steps involve bringing up subscriber sessions, verifying that they are up and running, checking for proper accounting on the Local Access Concentrator (LAC) and the Local Network Server (LNS) using Radius, simulating a PPP keepalive failure in the Test Generation Equipment (TGEN) by aborting the subscriber sessions, waiting 300 seconds for the PPPoE timer to expire, verifying that the sessions go down gracefully, checking the state of the sessions across both LAC and LNS, and verifying the disconnect reason on the LNS Radius. This test is triggered by aborting a pppoe subscriber session from Tgen.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nLacradius accounting records verification is performed.\nSubscriber session verification verification is performed.\nSubscriber accounting on LAC and LNS Radius verification is performed.\nDisconnect reason at LNS Radius verification is performed.\nSubscriber clean-Up verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lns pppoe keepalive bng",
                "Procedure": "In a dual-stack PPPoE subscriber sessions scenario, where the client is running PPP Keepalive enabled but the BNG system and LAC/LNS have it disabled by default, this test checks for proper functionality. To do so, enable PPP Keepalive at both the client and BNG sides, bring up the subscriber sessions, verify they are operational and accounting is happening through Radius on the LAC and LNS. Then simulate a failure in the TGN by aborting the subscriber session, wait for 60*7 seconds, which should allow the PPPoE timer to expire, causing the sessions to go down normally. After this, disable PPP Keepalive at the LAC/LNS BNG but enable it only on the client and try to bring up the subscribers again. This time, verify that the subscriber sessions do not come back online as they should be unable to establish a connection due to the lack of keepalive at the BNG side.\n\nThis test is triggered by aborting pppoe subscriber session from Tgen.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber summary verification is performed.\nL2tp tunnel summary verification is performed.\nLacradius accounting records verification is performed.\nSubscriber session verification verification is performed.\nSubscriber accounting on LAC and LNS Radius verification is performed.\nDisconnect reason at LNS Radius verification is performed.\nSubscriber clean-Up verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Session limit per l2tp tunnel",
                "Procedure": "L2TP tunnels on a Load Balancing Access Concentrator (LAC) are configured with a session limit of 16,000. Two L2TP tunnels are brought up by default, but only two are allowed in this test case. The number of subscribers is set to 40,000 on the Traffic Generation Node (TGN). Subscriber sessions are established and verified as active, while also checking that the total number of active sessions matches the configured session limit of 32,000 (16,000 for each L2TP tunnel) in the LAC CLI. The remaining subscriber sessions are not brought up, and stale entries are verified to be absent.\n\nThis test is triggered by configuring two L2TP tunnels on a Load Balancing Access Concentrator (LAC), when the default configuration would allow for 128.",
                "Pass/Fail Criteria": "Lns subscriber summary verification is performed.\nNumber of subscribers in a given L2TP Tunnel matches with configured value verification is performed.\nRest of the extra sessions should not come UP and no stale entries verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpdn session limit pbng",
                "Procedure": "The test is designed to validate the vpdn session limit configuration on a Local Access Concentrator (LAC). To do this, a session limit of 16K is configured in the LAC and 20K subscribers are set up in the TGN. The subscriber sessions are then brought up, and it's verified that the number of active sessions matches the configured limit in the CLI for vpdn session limit (16k), not the actual number of subscribers (20k). It's also checked that any additional sessions do not become active and that no stale entries are present. Finally, the configuration is restored to its original state with a session limit of 64k in the LAC.\n\nThis test is triggered by configuring vpdn session-limit number(16k) in the Local Access Concentrator (LAC).",
                "Pass/Fail Criteria": "Lns subscriber summary verification is performed.\nNumber of subscribers in a given L2TP Tunnel matches with configured value verification is performed.\nRest of the extra sessions should not come UP and no stale entries verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "No session timeout for l2tp tunnel pbng",
                "Procedure": "A test is conducted to ensure that a tunnel does not time out, and also verifies that there is no user timeout for the tunnel. The configuration involves setting \"never\" as the keyword for the timeout of no users under the L2TP class in the LAC. This allows the tunnel to remain up even without any users connected. The test steps include configuring a subscriber with a session bringup, verifying that the sessions are up, and then cleaning up the subscriber. Additionally, it is verified that the tunnel remains up even after subscribers have disconnected, and finally the L2TP tunnel is cleared. This test is triggered by having a timeout of \"never\" for no users under the l2tp-class.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber bringup verification verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTunnel verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack invalid vrf lac",
                "Procedure": "When an invalid VRF push comes from lac radius, we want to check that the system remains stable. This test aims to validate this stability by configuring an incorrect VRF name at the lac radius and then attempting to bring up subscribers, checking their state and verifying that sessions do not come online as expected. The subscriber's state is checked again after correcting the VRF name in the radius file and bringing up the sessions.\n\nThis test is triggered by attempting to push a wrong VRF name from lac radius.",
                "Pass/Fail Criteria": "Subscriber summary verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber should not come UP and system stability when invalid or non-existent VRF name verification is performed.\nSubscriber should come UP, once we correct VRF name verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack invalid vpdn template from radius",
                "Procedure": "When a wrong VRF name is configured and pushed from the lac radius, the system stability is tested with default_vrf_combination_dynamic_template. This test aims to validate system stability when an invalid or non-existent vpdn name is configured at the lac radius. The steps to follow are: Configure an invalid or non-existent vpdn name at the lac radius and try to bring up subscribers, then check the subscriber state - sessions should not come UP. Correct the vpdn name in the radius file and again bring up sessions with usual subscriber verifications. \n\nThis test is triggered by configuring an invalid or non-existent vpdn name in the radius file.",
                "Pass/Fail Criteria": "Subscriber summary verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber should not come UP and system stability when invalid or non-existent vpdn name verification is performed.\nSubscriber should come UP, once we correct vpdn name verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "One sub per tunnel max tunnel",
                "Procedure": "To validate one subscriber per tunnel and scale the tunnel to 16,000 subscribers, we configure a tunnel count and session count of 16,000. We then bring up the TGN user profile, enable subscriber sessions, and verify that they are all active. Next, we run traffic and accounting tests to ensure the system is functioning as expected. This test is triggered by configuring an L2TP tunnel with a session limit of 16,000 using the CLI in the LAC device.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nNumber of subscribers in a given L2TP Tunnel matches with configured value verification is performed.\nRest of the extra sessions should not come UP and no stale entries verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2tp tunnel linkfail bad route",
                "Procedure": "Here is the rewritten paragraph:\n\nWhen a link fail occurs, causing an L2TP tunnel to become unreachable, the system should behave in a specific way. Upon keepalive failure, all subscriber sessions on that tunnel should go down, but first the initial sessions should terminate before the entire tunnel becomes unavailable. To test this behavior, bring one link down on the LAC side and another on the LNS side, and verify how the system responds. The PPP keepalive retry value should be increased to prevent subscriber sessions from going down prematurely. Next, simulate a L2TP keepalive failure by either shutting down IP connectivity on both sides or injecting a bad route into the default VRF and a secondary VRF instance.\n\nThis test is triggered by bringing down and verifying one link on the LAC side and another on the LNS side in link_fail mode, and by injecting bad routes into the default VRF and a secondary VRF instance respectively.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntunnel_down_mode: \"ApData.zap.get_testcase_configuration('test_l2tp_tunnel_linkfail_bad_route').get('tunnel_down_mode', ['link_fail'])\"",
                "Pass/Fail Criteria": "Radius accounting records verification is performed.\nSubscriber summary verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nLacradius accounting records verification is performed.\nL2tp tunnel summary verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nRadius accounting verification on LAC and LNS verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack invalid vrf lns cp",
                "Procedure": "The system stability is tested when an invalid VRF push comes from the LNS CP. To validate this, an invalid or nonexistent VRF name is configured at the LNS CP, and attempts are made to bring up subscribers. The subscriber state is checked, and it's expected that sessions do not come UP. After correcting the VRF name in the LNS CP, subscribers are brought back online and usual verifications are performed.\n\nThis test is triggered by configuring an invalid or non-existent VRF name at the LNS Control Point (CP).",
                "Pass/Fail Criteria": "Subscriber summary verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber should not come UP and system stability when invalid or non-existent VRF name in LNS CP verification is performed.\nSubscriber should come UP, once we correct VRF name verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp httpr",
                "Procedure": "Here is the rewritten paragraph:\n\nThe test of HTTPR functionality on dual-stack L2TP subscriber sessions involves bringing up PPPoE dual-stack subscriber sessions from a Spirent device with various combinations, including default and non-default VRFs, as well as subscribers with HTTP-R applied through Radius or feature-templates. This triggers MA-CoA for the subscriber sessions to deactivate the HTTP-R service and activate other services.\n\nThis test is triggered by bringing up dual-stack L2TP subscriber sessions in mixed (default & non default VRF) environments.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPbr summary verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp absolute timeout",
                "Procedure": "L2TP dual-stack subscriber sessions are tested for bringup and bringdown with an absolute timeout. The test involves testing the session's bringup and bringdown in distributed Mixed (default and non-default) Virtual Routing Forwarding (VRF) environments. In this method, a list of configurations is used, including \"lac\" and \"lns\". Specifically, PPP keepalives are set to 60 seconds on the Local Network Server (LNS) Concentrator, and an absolute timeout is configured under the PPP section in the start and activate feature template in the Control Plane (CP). The test also includes bringing up PPPoE dual-stack subscriber sessions from Spirent, assigning Tunnel-Assignment-Id from the LAC RADIUS in access-accept, as well as assigning primary and secondary DNS addresses or IPv6 DNS servers from the LNS RADIUS in access-accept. Finally, subscriber sessions are brought down through an absolute timeout.\n\nThis test is triggered by a configuration of dual-stack L2TP subscribers distributed in default and non-default VRF environments, with Spirent traffic streams and Radius user profiles.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"lac\" and \"lns\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lac lns radius authentication failure",
                "Procedure": "To test authentication failure scenarios, configure dual-stack PPPoE subscriber sessions with 128 sessions to see how it affects radius profile generation. This can take more time due to the increased number of sessions, which is limited to 128. To trigger this scenario, wrong username or password in the LAC and LNS radius profiles must be configured, and then bring up PPPoE dual-stack subscriber sessions from Spirent. Verify that sessions with incorrect usernames or passwords do not come online, then abort a session from TGN, verify Subscriber Bring Down, correct the Radius username or password, and finally verify Subscriber Bring Up. The necessary configurations for this test include wrong usernames or passwords in the LAC and LNS radius profiles, correct Radius usernames or passwords, radius configuration and bringup, as well as TGN bringup.\n\nThis test is triggered by configuring wrong username or password in the LAC and LNS radius profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nwrong_credential: \"ApData.zap.get_testcase_configuration('test_lac_lns_radius_authentication_failure').get('wrong_credential', ['invalid_user_name'])\"",
                "Pass/Fail Criteria": "Subscriber summary verification is performed.\nSubscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nAaa radius server verification is performed.\nSubscriber should not come when invalid/wrong credentials at LAC and LNS Radius verification is performed.\nRadius reject stats verification is performed.\nFADB verifications verification is performed.\nCPU, memory utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 lac interface across lc racetrack",
                "Procedure": "The test characterizes the Bringup and Bringdown Count Per Second (CPS) for a specific combination of configurations. The configuration includes THK LC Type, RSP5-SE RSP Type, L2TP Single-stack IPv4 Subscriber Type, 32K subscriber scale, Racetrack Config Profile, One single member bundle from each LC on LAC Bundle, Parent Interfaces with 4 bundle subinterfaces per bundle, and Retries of 0 and unlimited. The test takes around 70 CPS for Bringup and 60 CPS for Bringdown. This test is triggered by a list named retries which contains the values \"0\" or \"unlimited\", specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 lac interface across lc racetrack",
                "Procedure": "Here is a single, natural-sounding paragraph:\n\nTo test the performance of an L2TP single-stack IPv6 subscriber session bringup and bringdown, we characterize the Count Per Second (CPS) for a specific scenario: THK Local Convergence (LC) Type, RSP5-SE Radio Network Controller Type, 32K subscribers using L2TP Single-stack IPv6, with the Racetrack configuration profile and one bundle per LC on the Load Aggregation Controller. We measure the CPS from the client perspective for bringup and bringdown, where a high value indicates faster session establishment and termination. This test is triggered by a list of retry configurations, including \"0\" retries or unlimited retries, which are specified in the input file under 'testcase_configuration'.\n\nThis method takes in a list named as retries = [\"0\" , \"unlimited\"] which is specified in input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack lac interface across lc racetrack",
                "Procedure": "To characterize the bringup and bringdown counts per second for a large-scale test with 32,000 subscribers, we simulate a scenario using THK LCs, RSP5-SE RSPs, and L2TP dual-stack subscribers. We configure one single-member bundle from each local context (LC), four bundle subinterfaces per parent interface, and zero or unlimited retries in both cases. The test measures the time taken for bringup and bringdown in seconds. Bringup is triggered by Simcenter's Spirent, which creates PPPoX and DHCPv6 clients, while simultaneously polling to get the subscriber count with time.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 lac interface across lc feature",
                "Procedure": "L2TP single-stack subscriber session bringup and bringdown Count Per Second (CPS) is measured across Local Concentrators (LCs) on the Load Aggregator Controller (LAC). The test involves characterizing the CPS for a specific combination of configurations: THK LC type, RSP5-SE Radio Site Platform type, L2TP single-stack IPv4 subscriber, 32K subscribers, Vodafone configuration profile, and one single-member bundle from each LC on the LAC. Four bundle subinterfaces per bundle are used as parent interfaces, with retries set to either 0 or unlimited in both cases. The measured CPS includes the time taken for bringup (70 CPS) and bringdown (60 CPS) operations. This test is triggered by passing a list of retry values [\"0\", \"unlimited\"] specified in the input file under 'testcase_configuration'. The test brings up L2TP single-stack subscriber sessions from Spirent, simultaneously polling to get the subscriber count with time, then brings down the subscriber sessions and verifies the bringup and bringdown CPS. The configuration involves a single-stack L2TP subscriber in mixed Virtual Routing Forwarding (VRF) with Spirent creating PPPoX Client and radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 lac interface across lc feature",
                "Procedure": "The test involves bringing up and down L2TP single-stack subscriber sessions on a THK LC with RSP5-SE RSPs, using a Vodafone configuration profile. The subscriber scale is 32K, with one bundle member from each LC and four bundle subinterfaces per parent interface. The testing includes two retries cases: no retries and unlimited retries. During the test, Spirent brings up and down L2TP sessions simultaneously while polling for the subscriber count in real-time. This method takes in a list of retry values specified in the input file under 'testcase_configuration'. The goal is to measure the Bringup and Bringdown CPS (Count Per Second) across multiple locations on the Load Balancing Controller. This test is triggered by a list named as retries = [\"0\", \"unlimited\"] which specifies the number of retries allowed for both bringup and bringdown operations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack lac interface across lc feature",
                "Procedure": "The test characterizes the bringup and bringdown Count Per Second (CPS) for a specific scenario involving L2TP dual-stack subscriber sessions. The setup includes THK LCs, RSP5-SE RSPs, 32K subscribers, Vodafone config profiles, and one single-member bundle from each LC on the LAC. The parent interfaces consist of four bundle subinterfaces per bundle, with retries set to either 0 or unlimited. During the test, L2TP dual-stack subscriber sessions are brought up and down simultaneously using Spirent, while polling is performed to obtain the subscriber count in real-time. Finally, the bringup and bringdown CPS are verified.\n\nThis method takes in a list named as retries = [\"0\", \"unlimited\"] which is specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 lns interface across lc racetrack",
                "Procedure": "L2TP single-stack IPv4 subscriber sessions are brought up and down on Load Controllers (LCs) connected to a Local Network Server (LNS). The test measures the Count Per Second (CPS) of bringup and bringdown for 32,000 subscribers with a Racetrack configuration profile. Each LC has one bundle with four subinterfaces, and retries are set to either 0 or unlimited. The method uses Spirent to create PPPoX clients and radius user profiles. This test is triggered by passing in a list named \"retries\" which contains either the string \"0\" or the string \"unlimited\", specified under 'testcase_configuration' in the input file.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 lns interface across lc racetrack",
                "Procedure": "L2TP single-stack IPv6 subscriber sessions are brought up and down at a rate of 32,000 per second across Load Controllers (LCs) on the LNS. The tests involve THK LCs with RSP5-SE Response Time Monitors, each configured to handle 32,000 L2TP Single-stack IPv6 subscribers, with a single member bundle from each LC and four bundle subinterfaces per parent interface. The subscriber sessions are brought up at a rate of 70 per second and down at a rate of 60 per second, measured in seconds. This test is triggered by a list of retries values specified in the input file under 'testcase_configuration', which can be either \"0\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack lns interface across lc racetrack",
                "Procedure": "L2TP dual-stack subscriber sessions are brought up and down using Spirent, with polling performed simultaneously to get the subscriber count. The test is conducted on a THK LC Type with an RSP5-SE RSP Type, 32K L2TP Dual-Stack Subscriber scale, and a Racetrack Config Profile. A single member bundle from each LC is used, with four bundle subinterfaces per bundle as parent interfaces. Retries are set to both 0 and unlimited, resulting in bringup CPS of 60 and bringdown CPS of 50 from the client's perspective. The time taken for bringup or bringdown is measured to verify the bringup and bringdown CPS. This test is triggered by a list named retries which contains \"0\" and \"unlimited\", specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 lns interface feature",
                "Procedure": "The test characterizes the Bringup and Bringdown Count Per Second (CPS) for a specific combination of settings. The configuration includes THK Local Convergence Type, RSP5-SE Remote Switching Processor Type, 32,000 L2TP Single-stack IPv4 subscribers, Racetrack Config Profile, one single-member bundle with four bundle subinterfaces per bundle, and unlimited retries. Bringup CPS is measured as 70 from the client's perspective, while bringdown CPS is 60. This test takes in a list of retry values specified in the input file under 'testcase_configuration'. The method involves bringing up L2TP single-stack subscriber sessions simultaneously with polling to track the subscriber count over time, verifying the CPS; then bringing down the subscribers with simultaneous polling for the subscriber count. This test is triggered by specifying retries = [\"0\", \"unlimited\"] in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 lns interface feature",
                "Procedure": "The test characterizes the Bringup and Bringdown Count Per Second (CPS) for a specific combination of configuration settings. The scenario involves a Large-Capacity Type Host (LC Type: THK), a Response System 5-SE (RSP Type: RSP5-SE), and a single-stack IPv6 subscriber with 32,000 subscribers, using the Racetrack Config Profile and a single member bundle with four subinterfaces. The test measures the time taken for bringup and bringdown operations, including simultaneous polling to get the subscriber count, and verifies the CPS results. This test is triggered by the method taking in a list of retries values, which are specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack lns interface feature",
                "Procedure": "The test characterizes the bringup and bringdown Count Per Second (CPS) for a specific combination of configurations on an LNS. This includes: LC Type THK, RSP Type RSP5-SE, Subscriber Type L2TP Dual-Stack with 32K subscribers, Config Profile Racetrack, one single-member bundle on the LNS, four subinterfaces per bundle, and Retries set to both 0 and unlimited. The test takes time measurements for bringup and bringdown, polling the subscriber count simultaneously using Spirent, which creates PPPoX and DHCPv6 clients with a radius user profile.\n\nThis test is triggered by supplying a list of retries values in the input file under 'testcase_configuration', specifically including [\"0\", \"unlimited\"].\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 lns interface across np feature",
                "Procedure": "L2TP single-stack IPv4 subscriber sessions are brought up and down at a rate of 70 Count Per Second (CPS) for bringup and 60 CPS for bringdown. The measurement is taken over time, in seconds, to determine the CPS. This test is triggered by input from an external list called \"retries\" which contains two values: \"0\" and \"unlimited\", both indicating zero retries with no limit.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 lns interface across np feature",
                "Procedure": "When testing a subscriber session that uses L2TP single-stack IPv6, we measure the Count Per Second (CPS) for bringup and bringdown across multiple Nodes Processes (NPs) on the same Line Card (LC). We test two different scenarios: one where retries are set to 0, and another with unlimited retries. The configuration includes a THK LC Type, RSP5-SE RSP Type, L2TP Single-stack IPv6 subscriber type, and a scale of 32,000 subscribers. We use the Racetrack config profile and one single member bundle from each NP on the same LC. Parent interfaces include four subinterfaces per bundle. The test brings up or brings down the subscriber sessions simultaneously while polling for the subscriber count, then verifies the bringup and bringdown CPS.\n\nThis test is triggered by a list of retry values, specified in the input file under 'testcase_configuration', including both \"0\" and \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Radius server unresponsive",
                "Procedure": "The test involves simulating a server outage scenario for the LAC and LNS on a Radius server. The steps include verifying that the Radius server is available at the start of the test, then killing the Radius daemon and initiating PPPoE dual-stack subscriber sessions from Spirent to verify Radius timeouts statistics. Next, the Radius service and subscriber bringup are initiated, followed by bringing down the subscriber connection. Various configurations will be tested, including a dual-stack PPPoE subscriber in default and non-default VRFs, using a radius user profile.\n\nThis test is triggered by simulating a server outage condition on the LAC/LNS side.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nl2tp_node: \"lac\" and \"lns\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nAaa radius server verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Missing definition in lns up",
                "Procedure": "The test aims to validate various subscriber bringup scenarios, where one or more definitions such as ACLs, QoS, PBR, or Services are missing in the Local Network Server (LNS) Unit Protocol (UP). To simulate these scenarios, a backup of the router configuration is taken using the rollback feature. One of these definitions is then intentionally removed from the LNS UP, and PPPoE dual-stack subscriber sessions are brought up from Spirent. The verification process checks if subscribers come up successfully without this definition. The missing definition is corrected by reverting to the previous configuration via rollback, and the subscriber bringup process is verified again. Finally, the subscribers are brought down, and any remaining cleanup verification steps are performed.\n\nThis test is triggered when one of the following parameters is provided: an ACL, QoS, PBR, or Services definition that is missing in LNS UP.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ndefinition_name: \"acl\" and \"qos\" and \"pbr\" and \"services\"",
                "Pass/Fail Criteria": "Subscriber summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber session details verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber bringup, subscribers should not come up, when definitions are missing at LNS UP. Definitions are defined in LNS CP - under feature template verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2tp tunnel authentication fail",
                "Procedure": "The system's stability is validated by testing its behavior when passwords mismatch between LAC and LNS Control Points for L2TP Tunnel configuration. To test this, a different password is configured in the LNS CP under L2TP config, subscribers are tried to be brought up, their state is checked, and it is verified that sessions do not come UP as expected. The passwords are then corrected to match in both LAC and LNS CP before again bringing UP the sessions and conducting usual subscriber verifications.\n\nThis test is triggered by a configuration where different passwords are set in LAC and LNS CP for the L2TP config, and then correcting the password to match in between LAC and LNS.",
                "Pass/Fail Criteria": "Subscriber summary verification is performed.\nSubscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber should not come UP and system stability when password mismatch happens in LAC and LNS CP for L2TP Tunnel config verification is performed.\nSubscriber should come UP, once we correct password verification is performed.\nSubscriber clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Lac access interface deletion",
                "Procedure": "To validate system stability when an access bundle in LAC UP is deleted, we bring up PPPoE dual-stack subscriber sessions, delete the LAC UP, and check the subscribers' state at both the LAC UP and LNS UP. We then bring back the LAC UP, access the Bundle interface, do a remote control (RCON) at the LNS CP, and verify that everything is in sync. After that, we bring down the subscribers, clean up any verification issues, and restore the deleted Access Bundle interface in LAC UP.\n\nThis test is triggered by deleting an Access Bundle interface in Local Access Concentrator (LAC) UP configuration.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscribers states when LAC UP access bundle is down verification is performed.\nUP-CP stability post rcon verification is performed.\ncleanup verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp static pool",
                "Procedure": "L2TP dual-stack subscriber sessions are brought up through a Static pool by testing the following configuration and steps. The test involves bringing up PPPoE dual-stack subscriber sessions from a device known as Spirent, where attributes such as Tunnel-Assignment-Id, Framed-IP-Address, Cisco-AVPair with the value 'addrv6', and Delegated-IPv6-Prefix are assigned from LAC radius in access-accept, and further attributes are assigned from LNS radius in access-accept. The test then runs bidirectional ipv4 and ipv6 traffic before bringing down the subscriber sessions. This test is triggered by having a configuration that includes dual-stack L2TP subscribers in default VRF, Spirent as the device used to bring up PPPoE dual-stack subscriber sessions, a traffic stream, and Radius user profiles.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe lns qos",
                "Procedure": "To test Quality of Service policy operations on dual-stack PPPoE subscriber sessions, we configure QoS policies through a feature template in the LNS Control Plane, bring up dual-stack PPPoE subscriber sessions distributed across both default and non-default VRFs, and then run bidirectional IPv4 and IPv6 traffic. We also test the removal of these policy settings from the LNS Control Plane Subscriber profile, reestablishing the subscriber sessions and updating policies via CoA. Additionally, we verify QoS policy compliance with specific traffic scenarios before deactivating the policies in Radius, restoring default LNS feature templates in the teardown method.\n\nThis test is triggered by a spirent device configuration that includes traffic streams and a radius user profile to simulate PPPoE subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nTraffic verification is performed.\nQos interface verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe lns icmp unreachables",
                "Procedure": "The test validates the ICMP Unreachable feature by enabling it for both IPv4 and IPv6, verifying that an unreachable message is sent when a link goes down. When the feature is disabled, no such messages are sent by default. To conduct the test, enable ICMP Unreachable in the LNS Control Plane under active FT, establish dual-stack PPPoE subscriber sessions distributed across default and non-default VRFs, run bidirectional IPv4 and IPv6 traffic, then disable the feature and repeat the process.\n\nThis test is triggered by enabling or disabling the icmp unreachable feature for v4 and v6 in the LNS Control Plane under active FT.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nICMP traffic at system level verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe lns acl",
                "Procedure": "Dual-stack PPPoE subscriber sessions are tested by performing a series of operations. Ingress and egress ACLs for IPv4 and IPv6 are configured through a feature template on the LNS CP. Dual-stack PPPoE subscriber sessions, distributed in both default and non-default VRFs with ACL enabled, are brought up and then run bidirectional ipv4 and ipv6 subscriber traffic. The subscriber sessions are then brought down, the ACL is removed from the feature template, and default ACLs are configured through Radius. Subscriber sessions are brought up again and run bidirectional ipv4 and ipv6 traffic. A deny ACL is updated through CoA and traffic drop scenarios are verified with deny ACLs in place. Subscriber sessions are then brought down again. The configuration is restored to its original state by restoring the default v4 and v6 ACLs and the LNS FT with defaults in the teardown method. This test is triggered by a Spirent device configured for testing PPPoE subscriber traffic, along with a Radius user profile used to configure subscriber sessions and authenticate users.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nAcl count verification is performed.\nTraffic verification is performed.\nAcl interface verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Isolated session clear",
                "Procedure": "The purpose of this test is to evaluate system stability in a specific scenario. The setup involves establishing dual-stack PPPoE subscriber sessions over L2TP, with subscribers distributed across default and non-default VRFs. Connectivity between the LAC/LNS control plane (CP) and user plane (UP) is then interrupted, followed by clearing subscribers from the LNS/LAC CP. Once this is done, connectivity is restored between the LAC/LNS CP and UP, and a recon process is initiated from the LAC/LNS CP. This test is triggered by changes to configuration that break the connectivity between the LAC/LNS CP and UP, clear subscribers from the LNS/LAC CP, and initiate a recon process from the LAC/LNS CP.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nl2tp_node: \"lac\" and \"lns\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCp up association verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nwhen there is connectivity down in LAC/LNS UP & CP, LAC/LNS UP & CP will be out of sync verification is performed.\nPost recon, there should not be any out of sync in CP-UP verification is performed.\nClean up verification - no memory, CPU spike verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe lns abf",
                "Procedure": "ABF operations are tested on dual-stack PPPoE subscriber sessions by simulating the bringup and bringdown of distributed, dual-stack subscriber sessions within both default and non-default VRFs while ABF is enabled. The test involves configuring IPv4 and IPv6 ACLs with a \"next-hop\" target, applying ABF to subscriber sessions through a feature template in the LNS control plane, bringing up dual-stack PPPoE subscriber sessions, and running bidirectional IPv4 and IPv6 subscriber traffic. Afterward, the sessions are brought down, ABF is removed from the feature template and configured via RADIUS, and the subscriber sessions are brought back up to run more bidirectional traffic. This test is triggered by applying a change of authorization (CoA) command to remove ABF.",
                "Pass/Fail Criteria": "Run and traffic with abf verification is performed.\nSubscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp priority config",
                "Procedure": "We test the priority of a subscriber's configuration when it comes from different sources by bringing up dual-stack L2TP subscribers, which tests the session bringup and bringdown with a mixed (default and non-default) VRFs configuration. The testing is done in several steps: first, PPPoE dual-stack subscriber sessions are brought up on Spirent; then feature template configurations are set up with IPv4 and IPv6 MTU as 1492; the LNS Radius sends an MTU of 1400 for both IPv4 and IPv6 to take priority. The LAC radius assigns specific attributes in access-accept, including Tunnel-Assignment-Id, while the LNS radius assigns primary and secondary DNS addresses via cisco AVPs or other means, as well as ipv6-dns-servers-addr. After this, bidirectional IPv4 and IPv6 traffic are run, subscriber sessions are brought down, and the session and service accounting are verified. This test is triggered by a configuration involving dual-stack L2TP subscribers distributed in default and non-default VRFs, Spirent, traffic streams, and Radius user profiles.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack lns pool exhaustion",
                "Procedure": "The test case is designed to validate LNS IPAM pool exhaustion by simulating a scenario where all available addresses are allocated. To do this, a new IPAM pool is created with exactly 32 IPv4 and IPv6 addresses, assigned, and then configured in LNS CP. The TGN configuration, tunnels, and Radius setup are also completed before attempting to bring up subscriber sessions. Once the sessions are established, it's verified that the number of subscribers matches between LNS UP and CP, and there are no inconsistencies. Additionally, session count is validated with IPAM pool address numbers, as only those many subscribers can come up. After cleanup checks for system inconsistencies, the process is brought down and closed, and finally, the IPAM pool is restored to its default addresses.\n\nThis test is triggered by creating a new IPAM pool with 32 IPv4 and IPv6 addresses only.",
                "Pass/Fail Criteria": "Lns subscriber summary verification is performed.\nIpam pool allocation verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nOnly 32 Subscribers will come UP verification is performed.\nthe number of subscribers matches in LNS UP and CP, no inconsistency verification is performed.\nSystem stability when having an IPAM pool with less address and try to bring up more subscribers verification is performed.\nIPAM pool verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp multiple sources",
                "Procedure": "L2TP dual-stack subscriber sessions are brought up and down in the default VRF, utilizing multiple sources and a single destination. This test is triggered by bringing up PPPoE dual-stack subscriber sessions from Spirent, with specific attributes assigned via radius: \"Tunnel-Assignment-Id\" from the LAC in access-accept, and \"primary-dns\", \"secondary-dns\", \"DNS-Server-IPv6-Address\", or \"ipv6-dns-servers-addr\" from the LNS in access-accept. The test also involves tunnel load balancing with equal distribution, running bidirectional ipv4 and ipv6 traffic, verifying subscriber session and service accounting, and then bringing down the subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2tp lns main interface bundle cases",
                "Procedure": "L2TP dual-stack subscriber session bringup is tested on alternate chunks in Layer Configuration (LC) for single or across_np or across_lc bundle modes. The test takes into account the 'bundle_mode' list, defined as 'bundle_int_distribution' under testcase_configuration. To perform this test, PPPoE dual-stack subscriber sessions from Spirent are brought up on alternative chunks, while assigning Tunnel-Assignment-Id from LAC radius in access-accept and primary-dns, secondary-dns, DNS-Server-IPv6-Address or ipv6-dns-servers-addr attributes from LNS radius in access-accept. The test also involves bringing down subscriber sessions. This test is triggered by Dual-stack L2TP subscribers distributed in default & non-default VRF, Spirent configuration, and Radius user profiles.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_mode: \"ApData.zap.get_testcase_configuration('bundle_int_distribution')\"",
                "Pass/Fail Criteria": "Qos programming verification is performed.\nSubscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nQoS Programming verification on Chunks verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack l2tp multiple destinations",
                "Procedure": "L2TP single-stack subscriber sessions are tested through bringup and bringdown processes in a default Virtual Routing Forwarding (VRF) environment, with multiple destinations both with and without weight assigned. The test also includes the setup of PPPoE single-stack subscriber sessions from Spirent, where certain attributes are assigned to the subscriber session from the LAC radius in access-accept, including Tunnel-Assignment-Id. Additionally, other attributes such as primary-dns, secondary-dns, DNS-Server-IPv6-Address, and ipv6-dns-servers-addr or their Cisco equivalent avps are also assigned from the LNS radius in access-accept. After setting up the test configuration, which involves single-stack L2TP subscribers distributed in default with multiple destinations, a traffic stream is configured for only v4 stack using Spirent, and bidirectional ipv4 traffic is run. The subscriber sessions are then brought down after verifying subscriber session and service accounting.\n\nThis test is triggered by bringing up PPPoE single-stack subscriber sessions from Spirent, assigning specific attributes to the subscriber session in access-accept, running bidirectional ipv4 traffic, and testing tunnel load balancing with equal and weighted distribution.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nlac_mode: \"ApData.zap.get_testcase_configuration('multi_destination_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nV4 Traffic Verification and 60% of downstream traffic will fail due reverse route for tunnel [Topology limitation] verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2tp lns bundle cases qos programming",
                "Procedure": "The test verifies Quality of Service (QoS) resource programming by simulating various scenarios involving L2TP subscriber sessions. The simulation involves configuring alternative chunks with different members on a Border Element 10 device, bringing up dual-stack L2TP subscriber sessions in default VRF, and verifying QoS programming after each step. This is triggered when the 'conf_mode' parameter, defined as 'bundle_scenario_modes', is set to one of the following scenarios: \"3_chunks\", \"all_chunks\", \"qos_ma_ea_restart\", \"qos_ma_ea_3_chunks\", \"qos_ma_ea_3_chunks_same_lc_link\", \"rpfo\", \"rpfo_3_chunks\", \"rpfo_3_chunks_same_lc_link\", \"rpfo_3_chunks_diff_lc_link\", \"3_chunks_diff_lc_link\", or \"across_lc_reload_lc\". The test steps include configuring alternative chunks, bringing up subscriber sessions, restarting the QoS_MA_EA process, performing Radius Policy and Filtering Operation (RPFO), adding links or members to Border Element 10 devices, reloading local concentrators, and verifying QoS programming at each stage.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_mode: \"ApData.zap.get_testcase_configuration('bundle_scenario_modes')\"",
                "Pass/Fail Criteria": "Qos programming verification is performed.\nSubscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRestart crash verification is performed.\nCp up association verification is performed.\nSubscriber synchronize verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nQoS Programming verification on Chunks verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp framed routes",
                "Procedure": "Dual-stack L2TP subscribers with IPv4 and IPv6 framed routes pushed from the LNS radius are tested. This test is triggered by a scenario involving a LAC that assigns \"Tunnel-Assignment-Id\" and an LNS that pushes framed routes through radius in access-accept, distributed in both default and non-default VRFs for PPPoE dual-stack subscriber sessions, with Spirent configuration and the relevant radius user profiles.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp with mpls",
                "Procedure": "L2TP dual-stack subscriber sessions are tested for bringup and bringdown with MPLS LDP configuration on the LAC side, particularly in a scenario where these sessions are distributed across Mixed (default and non-default) Virtual Routing and Forwarding (VRFs). To test this, MPLS Label Distribution Protocol (LDP) is configured on both the LAC upstream (R1) and LAC core (R3) devices. A PPPoE dual-stack subscriber session is brought up from a Spirent traffic stream. Radius attributes are assigned to these sessions: from the LAC, a \"Tunnel-Assignment-Id\" attribute, and from the LNS, either cisco attribute \"primary-dns\" or \"Ascend-Client-Primary-DNS\", \"secondary-dns\" or \"Ascend-Client-Secondary-DNS\", \"DNS-Server-IPv6-Address\", or cisco attribute \"ipv6-dns-servers-addr\". Traffic is then run in both IPv4 and IPv6 directions, after which the subscriber sessions are brought down, and their status and service accounting verified.\n\nThis test is triggered by configuring MPLS LDP on LAC devices R1 and R3.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nMPLS LDP Neighbor verification verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nL2TP Tunnel verification verification is performed.\nQos Interface verification verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp without sso",
                "Procedure": "Dual-stack L2TP subscriber sessions are tested for their bringup and bringdown operations, which are distributed in both default and non-default VRF. RPFO (RADIUS Posture Fabric Operations) is then performed on these sessions. The test setup consists of a dual-stack L2TP subscriber in the default VRF, an Spirent device creating an L2TP client, and bidirectional traffic streams for both IPv4 and IPv6. A RADIUS user profile is also part of the configuration.\n\nThis test is triggered by a dual-stack L2TP subscriber session being created with an associated RADIUS user profile, bidirectional IPv4 and IPv6 traffic between the Spirent device's L2TP client and the tested system in default VRF.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nDisconnect reason verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp ha stress",
                "Procedure": "Dual-stack L2TP subscriber sessions are brought up, distributed across default and non-default Virtual Routing and Forwarding (VRF) domains. A high-stress scenario is then triggered with 12,500 subscribers, which includes a mix of churn types: 10% unauthenticated disconnects, 50% client reboots, 30% graceful disconnections followed by reconnects, and 10% address-family flaps. During this stress test, additional triggers are applied to simulate CoA (Change of Authorization) events that deactivate services. This test is triggered by a configuration involving dual-stack L2TP subscribers distributed in default and non-default VRF domains, along with specific Spirent device settings and RADIUS user profile configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration('stress_triggers')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nCp up session sync verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nCP-UP consistency verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp high availability",
                "Procedure": "To test the high availability of dual-stack L2TP subscribers, bring up multiple subscriber sessions distributed across both default and non-default virtual routing forwards (VRFs). Then, simulate a significant amount of churn on these sessions by randomly disconnecting 10% of them from authentication, rebooting 50%, performing a controlled release and reconnect for 30%, and flipping the address family settings for 10%. As this churn occurs, start sending bidirectional traffic between the L2TP subscribers. To trigger the high availability mechanisms, simulate one or more hardware faults such as an access port flap, process crash, chassis reload, or other failures that would normally cause a switch to take over from its standby unit.\n\nThis test is triggered by various failure scenarios, including hardware faults and system crashes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger_type: \"ApData.zap.get_testcase_configuration('ha_triggers')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nGet subscriber to verify verification is performed.\nCp up session sync verification is performed.\nConsistency verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nCP-UP consistency verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp stress coa macoa",
                "Procedure": "To test the stress on dual-stack L2TP subscribers, bring up subscriber sessions with a configuration of dual-stack L2TP subscribers distributed in both default and non-default VRFs. To further test the L2TP stress, perform back-to-back triggers for \"coa\" or \"macoa\" configurations. This test is triggered by a Radius user profile configured on a Spirent device.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration('back_to_back_triggers')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nCP-UP consistency verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack l2tp high incoming requests",
                "Procedure": "Dual-stack L2TP subscriber sessions can be brought up and distributed across both default and non-default Virtual Routing Forwarding (VRF) configurations. To test these setups, triggers for testing CoA with high incoming requests are \"coa\", while those for MA-CoA with high incoming requests are \"macoa\". This test is triggered by performing either of these CoA or MA-CoA operations on dual-stack L2TP subscribers with a specific configuration in place, including dual-stack L2TP subscribers distributed across default and non-default VRFs, Spirent device setup, and radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration('test_high_incoming_requests/triggers')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nContext verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nCp up session sync verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nCP-UP consistency verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nRouter for crashes verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bng_pppoe_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Dual stack pppoe default vrf",
                "Procedure": "This test covers the setup and teardown of dual-stack PPPoE subscriber sessions on default Virtual Routing Forwarding (VRF) in the CNBNG and PBNG modes. The test method takes a list of configuration modes specified in the input file, which can include radius authentication or dynamic-template allocation. It brings up PPPoE dual-stack subscriber sessions from Spirent with various configurations, such as CHAP authentication and double-tag VLANs, and covers multiple methods of IPv4 address allocation through radius using different AVPs, including Cisco's addr-pool and Framed-pool. The test also covers CPE WAN interface IPv6 address configuration, performing DHCPv6 PD over PPPoE, and assigning various attributes from radius in access-accept. It runs bidirectional IPv4 and IPv6 traffic and brings down subscriber sessions before verifying the session and service accounting. \n\nThis test is triggered by the version being greater than or equal to 7.10.1 and the BNG mode being PBNG.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration('configuration_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nBng version verification is performed.\nIpv6 nd idb interface detail verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nipv6 nd interface detail verification for version >=7.10.1 and bng_mode is pbng verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe nondefault vrf",
                "Procedure": "When testing the bringup and bringdown of a PPPoE dual-stack subscriber session in a non-default VRF, such as CNBNG or PBNG, various scenarios are tested. These include bringing up sessions from Spirent with CHAP authentication, double-tag VLANs, and default VRF. IPv4 address allocation is covered through radius using cisco AVPs \"addr-pool\" and \"Framed-pool\", as well as an addresses+I3s pool referred locally in dynamic-template by cnBNG CP. For CPE WAN interface IPv6 address configuration, IANA methods are tested, including radius using \"Stateful-IPv6-Address-Pool\" or cisco AVP \"stateful-ipv6-address-pool\", and dhcpv6 address pool referred locally in dynamic-template or server profile by cnBNG CP. DHCPv6 PD is also performed over PPPoE, covering prefix delegation methods through radius using \"Delegated-IPv6-Prefix\" attribute or cisco AVP \"delegated-ipv6-pool\", as well as a PD pool referred locally in dhcpv6 server profile or dynamic-template or sever profile in cnBNG CP. Additionally, attributes from radius are assigned in access-accept, including primary and secondary DNS servers, IPv4-unnumbered, IPv6-enable, and DNS-Server-IPv6-Address. Traffic is run bidirectionally over ipv4 and ipv6, sourced either as CPE WAN or LAN IPv6 address. After bringing down subscriber sessions, the subscriber session and service accounting are verified. The configuration for this test includes a dual-stack PPPoE subscriber in non-default VRF, Spirent device config, traffic stream, radius user profile, and ipv6 nd ra dns config.\n\nThis test is triggered by the version being greater than or equal to 7.10.1 and the bng_mode being PBNG.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration('configuration_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nPpp subscriber framed data verification is performed.\nAccounting verification is performed.\nFramed route traffic verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nBng version verification is performed.\nIpv6 nd idb interface detail verification is performed.\nContext verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nipv6 nd interface detail verification for version >=7.10.1 and bng_mode is pbng verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe httpr",
                "Procedure": "To test HTTPR functionality on dual-stack PPPoE subscriber sessions, the following steps are performed. The system is set up with a configuration that includes dual-stack PPPoE subscribers in both default and non-default VRFs, Spirent devices configured for testing, traffic streams, and radius user profiles. Then, 50K PPPoE dual-stack subscriber sessions are brought up from Spirent with three different combinations: default and non-default VRF settings, HTTP-R applied through Radius during bringup, and HTTP-R applied through feature-templates. Next, the system triggers a Mobility Anchor - CoA (MA-CoA) operation to deactivate the HTTP-R service and activate HSI on the subscriber sessions. After that, non-HTTP IPv4 and IPv6 traffic is run for all subscriber sessions. The final steps involve bringing down the subscriber sessions and verifying both the session and service accounting.\n\nThis test is triggered by the Mobility Anchor - CoA (MA-CoA) operation to deactivate HTTP-R and activate HSI on subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPbr summary verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe coa",
                "Procedure": "Dual-stack PPPoE subscriber sessions are tested on dual-stack PPPoE subscriber sessions, specifically those that use CNBNG and PBNG. This test is triggered by a Spirent creating a PPPoE client in the default VRF, running bidirectional IPv4 and IPv6 traffic streams, where the source IPv6 address can either be the CPE WAN IPv6 address or the derived LAN IPv6 address from a delegated prefix, performing combinations of account-status-query, account-update, activate-service, and deactivate-service CoA operations, disconnecting the subscriber session using a POD (Disconnect Message), and verifying the resulting subscriber session and service accounting.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe bundle across lc",
                "Procedure": "Dual-stack PPPoE subscriber sessions are tested over a multi-member bundle across Logical Centres (LC), specifically CNBNG and PBNG, to identify potential issues. The test involves configuring a bundle interface with two links across LC, bringing up dual-stack PPPoE subscriber sessions in both default and non-default VRFs, running bidirectional IPv4 and IPv6 subscriber traffic, and then shutting down the subscriber sessions.\n\nThis test is triggered by: This tests dual-stack PPPoE subscriber sessions over a multi-member bundle across LC - Configure bundle interface with 2 links across LC.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_members: \"ApData.zap.get_testcase_configuration('bundle_lc_members')\"",
                "Pass/Fail Criteria": "Across lc verification is performed.\nSubscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe keepalive client",
                "Procedure": "Dual-stack PPPoE subscriber sessions are brought up from a Spirent device with various configurations, including CHAP authentication, Double tag VLAN, Non-Default VRF, and Default VRF. The test then simulates connection loss between the client and BNG system, as well as aborting the PPPoE session. It also waits for the keepalive to expire and verifies the resulting keepalive failures. Additionally, subscriber bring down is verified through LCP echo requests/replies and NP counters are checked for PARSE_PPP_KEEPALIVE_HW_REPLY. The test configuration includes dual-stack PPPoE subscribers in both default and non-default VRFs, as well as Spirent device, traffic stream, and RADIUS user profile configurations.\n\nThis test is triggered by enabling PPP keepalive in both the BNG system and the client when there are 50K dual-stack PPPoE subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp statistics summary verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nKeepalive failures verification verification is performed.\nLCP echo requests/replies check verification is performed.\nNP counters check for PARSE_PPP_KEEPALIVE_HW_REPLY verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe keepalive bng",
                "Procedure": "In the BNG system with a large number of dual-stack PPPoE subscriber sessions (50K), PPP keepalive is enabled. To test this, Spirent is used to bring up PPPoE dual-stack subscriber sessions with various configurations: CHAP authentication, double-tag VLAN, non-default VRF, or default VRF. The tests involve aborting the PPPoE session from a TGN device and waiting for the keepalive to expire before verifying failures. Additionally, subscriber bring-down is verified under specific configuration scenarios: dual-stack PPPoE subscribers are distributed across default and non-default VRFs, with configurations including Spirent device settings, traffic streams, RADIUS user profiles, IPv6 ND RA DNS setup (for versions 7.10.1 and later), and PBNG mode.\n\nThis test is triggered by verifying that the BNG system is configured for a large number of dual-stack PPPoE subscriber sessions with various authentication methods.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nIpv6 nd idb interface detail verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nBng version verification is performed.\nPpp statistics summary verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nipv6 nd interface detail verification for version >=7.10.1 and bng_mode is pbng verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nKeepalive failures verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe abf",
                "Procedure": "Dual-stack PPPoE subscriber session bringup and bringdown operations are tested with Advanced BNG (ABF) enabled on both CNBNG and PBNG. To test this, IPv4 and IPv6 ACLs are configured with a \"next-hop\" setting, and ABF is applied to subscriber sessions through a feature-template in the cnBNG control plane. 50,000 dual-stack PPPoE subscriber sessions are brought up, distributed across default and non-default VRFs. Bidirectional IPv4 and IPv6 traffic is then run over these sessions. The sessions are then brought down, and ABF is removed from the feature-template before being reconfigured via Radius. Subscriber sessions are brought up again, bidirectional traffic is run, and finally, ABF is removed through CoA and the sessions are brought down.\n\nThis test is triggered by testing PPPoE dual-stack subscriber session bringup & bringdown distributed in default and non default VRF with ABF Enabled.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRun and traffic with abf verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe li",
                "Procedure": "The test involves evaluating the functionality of dual-stack PPPoE subscriber sessions, including CNBNG and PBNG, as well as the lawful intercept use case. To set up the test, a PPPoE dual-stack subscriber is brought up from Spirent using specific combinations: default and non-default VRFs, and enabling TAP for subscriber sessions through radius during bringup with certain AVPs. The subscriber sessions are then run through traffic, intercepted by setting \"li-action\" to 1, stopped through CoA by resetting it to 0, started again by reverting back to 1, and finally stopped. After the test, the subscriber session is brought down and verified along with service accounting.\n\nThis test is triggered by the need to assess Lawful Intercept functionality in dual-stack PPPoE environments, specifically when TAP is enabled for subscriber sessions through radius during bringup.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nTcam entry count verification is performed.\nRun and traffic with li verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe urpf",
                "Procedure": "The test for strict uRPF operations on dual-stack PPPoE subscriber sessions involves bringing up 50K dual-stack PPPoE subscriber sessions in a BNG system with PPPoE strict uRPF enabled. These sessions should use various authentication methods, such as CHAP and Double tag VLAN, and be configured in both default and non-default VRFs. Traffic is then run bidirectionally for IPv4 and IPv6 packets to ensure correct handling by the devices. Additionally, configuration of corrupted devices with inconsistent IP addresses and MAC addresses is tested. This includes running corrupted traffic for both protocols, bringing down subscriber sessions, and verifying that session and service accounting are functioning correctly.\n\nThis test is triggered by a scenario where a BNG system has 50K dual-stack PPPoE subscriber sessions enabled with strict uRPF operations.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRun and corrupt traffic verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe bundle across np",
                "Procedure": "The dual-stack PPPoE subscriber sessions are tested over a multi-member bundle across the network process (NP) from the same Local Controller (LC), specifically targeting CNBNG and PBNG. The bundle interface is configured with two links across the NP from the same LC, while bringing up dual-stack PPPoE subscriber sessions in both default and non-default VRFs. This involves running bidirectional IPv4 and IPv6 subscriber traffic through the sessions. Configuration requirements include a dual-stack PPPoE subscriber in both default and non-default VRFs, utilizing Vodafone profile configurations for this test case. Additional setup includes Spirent creating PPPoE and DHCPv6 PD clients, along with a RADIUS user profile that includes a password.\n\nThis test is triggered by the creation of a PPPoE and DHCPv6 PD client on Spirent, using a sample RADIUS user profile configuration where the device's username and password are specified.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nbundle_members: \"ApData.zap.get_testcase_configuration('bundle_np_members')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nKeepalive failures verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe macoa",
                "Procedure": "Dual-stack PPPoE subscriber sessions are set up, both in default and non-default VRFs. The sessions are then subjected to all possible combinations of MA-CoA/POD operations, including activating and deactivating services. After each operation, the functionality is verified with traffic being sent through the system. Following this, the subscriber session is disconnected using a POD disconnect message, and both the session and service accounting are checked for correctness. This test is triggered by bringing up dual-stack PPPoE subscriber sessions in a distributed environment, specifically using Vodafone profile configurations, with Spirent simulating a PPPoE and DHCPv6 PD client and a RADIUS user profile set up as part of the configuration.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nKeepalive failures verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack invalid vrf",
                "Procedure": "When an invalid VRF is returned from RADIUS, test the dual-stack PPPoE subscriber sessions. This test is triggered by configuring an invalid VRF in RADIUS and then bringing up PPPoE dual-stack subscriber sessions from Spirent using different authentication methods: CHAP, Double Tag VLAN, a non-default VRF, or default VRF. The tests should simulate aborting the PPPoE session and verify the Subscriber Bring Down configuration. This configuration involves a dual-stack PPPoE subscriber in both default and non-default VRF settings, as defined by the Vodafone profile configurations, along with Spirent's creation of a PPPoE and DHCPv6 PD client and RADIUS user profiles that include a password and device pass for authentication.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack invalid acl",
                "Procedure": "When bringing up 50K subscribers, the cnBNG system should fail to establish sessions if an Access Control List (ACL) name or Policy-Based Routing policy name referenced by the Control Plane (CP) is not configured in the User Plane (UP). In this scenario, ACLs \"iACL_BNG_IPv4_unconfig\" and \"iACL_BNG_IPv6_unconfig\" are defined in CP but not UP. This test is triggered by configuring IPv4 and IPv6 ACLs in CP that are not defined in UP, causing the cnBNG system to enter an inconsistent state due to failed session establishment.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber disconnect count verification is performed.\nPool verification is performed.\nSubscriber session check verification is performed.\nQoS Verification verification is performed.\nCPU Utilization verification is performed.\nPool Allocation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pool exhaustion",
                "Procedure": "When testing a scenario where the test pool becomes exhausted, configure the pool with fewer addresses than expected and then start bringing up 50,000 subscribers in session. Subscriber sessions will not come up once the pool is depleted. The system should remain consistent throughout this process without any inconsistencies arising due to the test pool exhaustion.\n\nThis test is triggered by configuring a pool with a smaller number of addresses than the total subscriber count, such as defining an address pool having fewer than 50,000 addresses and then bringing up that many subscribers in session.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nIpam pool allocation verification is performed.\nPbng pool verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber disconnect count verification is performed.\nCp up session sync verification is performed.\nPool Allocation (pre + after sessions established + post) verification is performed.\nSubscriber session check verification is performed.\nCPU Utilization verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack authentication failure",
                "Procedure": "Here is a test of authentication failure scenarios for dual-stack PPPoE subscriber sessions. The test involves configuring some users with the wrong password in the RADIUS profile, and then bringing up PPPoE dual-stack subscriber sessions from Spirent using different authentication methods such as CHAP, Double Tag VLAN, Non Default VRF, and Default VRF. The sessions with incorrect passwords are not allowed to come up, and then the PPPoE session is aborted from TGN, verifying Subscriber Bring Down functionality.\n\nThis test is triggered by a RADIUS user profile configuration that includes a sample device profile with an incorrect password, for example: ApData.device_user = {'password': 'ApData.device_pass'}",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber session details verification is performed.\nQos interface verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Partial feature provisioning failure",
                "Procedure": "The features are simulated to fail in a subset, testing the rollback behavior of UP. A dual-stack PPPoE subscriber is brought up from Spirent with four different configuration options: CHAP authentication, Double tag VLAN, Non-Default VRF, and Default VRF. Then, various combinations of CoA operations are performed, including activating an unconfigured service and deactivating a configured one. The lack of CoA responses, the services shown in session details, and the result of aborting the PPPoE session from tgn are all verified. Additionally, Subscriber Bring Down is confirmed to be properly configured. This test is triggered by using a Dual-stack PPPoE subscriber in default and non-default VRF with configurations taken from the Vodafone profile, creating a PPPoE client and DHCPv6 PD client with Spirent, and utilizing a radius user profile that includes device-specific information such as password and pass.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Radius server unresponsive",
                "Procedure": "When bringing up sessions with a dual-stack PPPoE subscriber in default or non-default VRF, the system should retry, retransmit, and handle deadtime if the radius server becomes unreachable. This test is triggered by killing the radius daemon while Spirent creates PPPoE and DHCPv6 PD client connections from multiple VLANs (double-tagged, non-default, and default) with a sample Vodafone profile configuration.",
                "Pass/Fail Criteria": "pool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nCPU utilization verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Same intercept id",
                "Procedure": "When bringing up a dual-stack PPPoE subscriber with the same intercept-id as another, the test fails as expected. This can be achieved by configuring an intercept-id from the RADIUS server, then attempting to establish more than one session with the same intercept-id, which should fail due to configuration of dual-stack PPPoE subscribers in both default and non-default VRFs via Spirent device config and radius user profile.\n\nThis test is triggered by configuring dual-stack PPPoE subscribers with the same intercept-id on different virtual routing instances.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe priority allocation",
                "Procedure": "Properties of dual-stack PPPoE subscriber sessions are prioritized on allocation. This test is triggered by the need to verify that when PPPoE prioritization of properties from RADIUS to feature templates in BNG systems occurs with 50K dual-stack PPPoE subscriber sessions, overrideable values such as ACLs, MTU, uRPF checks, and ICMP reachability flags, as well as accounting interim intervals, are successfully configured. To do this, configure RADIUS attributes in the radius user profile while simultaneously configuring corresponding settings in the cnBNG system; bring up 50K dual-stack PPPoE subscriber sessions, test feature functionalities with traffic, then bring down the sessions and verify session and service accounting. Configuration includes using a Vodafone profile for the default and non-default VRF, as well as Spirent to create PPPoE and DHCPv6 PD clients, in addition to defining a radius user profile.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe dhcpv6 options",
                "Procedure": "Fifty thousand dual-stack PPPoE subscriber sessions are brought up, with verification that the server responds to host configuration options including AFTR support, preference option, domain list, DNS server IPv6 address, and interface-id. The server also sends interface-id, remote-id, vendor-class, user-class, and client-id towards the radius. After verifying successful bringup, subscriber sessions are brought down with a dual-stack PPPoE subscriber session configuration distributed in default and non default VRF, involving Spirent creating PPPoE clients and traffic streams for IPv4 and IPv6 bidirectional traffic. This test is triggered by various DHCPv6 options being tested on dual-stack PPPoE subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe qos input output radius user profile",
                "Procedure": "Configuration for testing bringup of dual-stack PPPoE subscribers with Quality of Service (QoS) input/output policies from RADIUS user profiles includes a distributed setup with a default and non-default Virtual Routing Forwarding (VRF), a Spirent device creating a PPPoE client, and an IPv4 and IPv6 bidirectional traffic stream. The RADIUS user profile is set up to include QoS input/output policies.\n\nThis test is triggered by the creation of a PPPoE client using Spirent, with IPv4 and IPv6 bidirectional traffic streaming between the client and the network.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe dynamic pool add delete",
                "Procedure": "To test the dual-stack subscriber session bring-up in default VRF and add non-default VRF pools, configure radius and attempt to establish dual stack subscriber PPPoE sessions. The configuration includes two stages: Stage 1 involves setting up a radius user profile, 16 address pools in the default VRF, dual stack PPPOE subscribers in the default VRF, and creating a Spirent PPPoE client; Stage 2 is similar but uses non-default VRF.\n\nThis test is triggered by configuring a radius server with a user profile that includes IP addresses from both IPv4 and IPv6 address pools.",
                "Pass/Fail Criteria": "Offline address pools verification is performed.\nSubscriber session count verification is performed.\nPool verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nSubscriber session verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe frame routes",
                "Procedure": "Dual stack PPPoE subscribers are brought up with single or maximum IPv4/IPv6 Frame routes (CNBNG) when the P1 TC is configured. The test requires configuring IPv4/IPv6 Frame routes on the RADIUS server and attempting to bring up dual stack subscriber sessions. This method involves a list of frame route types, specified in the input file under 'testcase_configuration', which can be either \"single\" or \"maximum\". Dual stack PPPOE subscribers are distributed across default and non-default VRFs, with a Spirent device creating a PPPoE client and a RADIUS user profile configured with IPv4/IPv6 frame routes.\n\nThis test is triggered by configuring a radius user profile with ipv4/ipv6 frame routes on the P1 TC.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconf_type: \"ApData.zap.get_testcase_configuration().get('frame_route_type', ['maximum', 'single'])\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber sadb verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe default vrf duplicate frames",
                "Procedure": "PPPoE dual-stack subscriber sessions bringup & bringdown are tested in the default VRF, covering various methods of IPv4 address allocation through radius and dynamic-template, as well as CPE WAN interface IPv6 address configuration via IANA attributes or cisco AVPs. The test also includes DHCPv6 PD (prefix delegation) over PPPoE using different radius attributes and cisco AVPs, and assigns additional attributes from the radius server in access-accept messages. Traffic is run bidirectionally for both IPv4 and IPv6, with sources as either CPE WAN or LAN IPv6 addresses. The test also brings down subscriber sessions and verifies session and service accounting.\n\nThis test is triggered by a PPPoE dual-stack subscriber session bringup & bringdown in default VRF configuration mode specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration('configuration_mode')\"",
                "Pass/Fail Criteria": "Ppp subscriber framed data verification is performed.\nSubscriber session details verification is performed.\nFramed route traffic verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nipv6 nd interface detail verification for version >=7.10.1 and bng_mode is pbng verification is performed.\nppp idb interface verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe add duplicate frame coa",
                "Procedure": "PPPoe dual-stack subscriber sessions are brought up and down in the default VRF with a frame route using coa PBNG (P0 TC). The test covers various methods of IPv4 address allocation, including through Radius using cisco AVP \"addr-pool\" or IETF AVP \"Framed-pool\", and through an addresses+I3s pool referred to locally in a dynamic-template by the cnBNG CP. It also includes multiple methods of CPE WAN interface IPv6 address configuration, such as through Radius using \"Stateful-IPv6-Address-Pool\" attribute or cisco avp \"stateful-ipv6-address-pool\", and covers DHCPv6 PD over PPPoe. Additionally, various attributes are assigned from the radius in access-accept, including cisco avps for primary and secondary DNS servers, ipv4-unnumbered, and ipv6-enable. The test also runs bidirectional ipv4 traffic, bidirectional ipv6 traffic with sources as CPE WAN IPv6 address or CPE LAN IPv6 address, and brings down subscriber sessions. It verifies subscriber session and service accounting. This test is triggered by the presence of a version >= 7.10.1 and bng_mode being pbng in the configuration.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp subscriber framed data verification is performed.\nFramed route traffic verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nipv6 nd interface detail verification for version >=7.10.1 and bng_mode is pbng verification is performed.\nppp idb interface verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe change frame route metric",
                "Procedure": "A PPPoE dual-stack subscriber session test is performed in the default Virtual Routing Forwarding (VRF) with a change of metric value. The test case configuration is specified in an input file under 'testcase_configuration'. The test brings up and brings down PPPoE dual-stack subscriber sessions from Spirent, covering various authentication methods, IPv4 address allocation, and CPE WAN interface IPv6 address configuration. It also performs DHCPv6 PD over PPPoE with different prefix delegation methods. The test assigns attributes from RADIUS in access-accept, including DNS servers, IPv4-unnumbered, and IPv6-enable. Bidirectional traffic is run for both IPv4 and IPv6 addresses, sourced from CPE WAN or LAN IPv6 address. The test then brings down subscriber sessions and verifies the session and service accounting. Additionally, it tests the change of framed route metric value via CoA and duplicate frame route feature for RP bundle and LC subscribers.\n\nThis test is triggered by the 'enable ppp duplicate frame route' configuration in the dual-stack PPPoE subscriber in default VRF.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nPpp subscriber framed data verification is performed.\nFramed route traffic verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nipv6 nd interface detail verification for version >=7.10.1 and bng_mode is pbng verification is performed.\nppp idb interface verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe rpfo",
                "Procedure": "During a Route Switch Processor Failover (RPFO), the system's ability to handle PPPoE connections is tested for high availability. A subscriber is brought up, verified, and then sent traffic while the RPFO process occurs. After failover is complete, the number of subscribers and accounting on RADIUS are verified, and the traffic is stopped. Configuration includes using a Spirent device to create a PPPoE client and generate bidirectional IPv4 and IPv6 traffic streams.\n\nThis test is triggered by sending ipv4 and ipv6 bidirectional traffic while simulating a Route Switch Processor Failover (RPFO) event.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmode: \"ApData.zap.get_testcase_configuration('duplicate_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nConsistency verification is performed.\nGet subscriber to verify verification is performed.\nPpp subscriber framed data verification is performed.\nTraffic verification is performed.\nAccounting verification is performed.\nFramed route traffic verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nPool verification verification is performed.\nSubscriber session verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe ha",
                "Procedure": "When testing the high availability of PPPoE, dual-stack sessions are brought up on both a default and non-default VRF. Next, 50% of subscribers are made to run bidirectional IPv4 and IPv6 traffic, while the other 25% have their subscriber churn started. Meanwhile, CoA/MA-CoA is performed for all sessions. This test is triggered by bringing up the subscriber sessions with distributed dual-stack PPPoE in default and non-default VRFs and running the above steps concurrently. After the test has completed, traffic is stopped and the subscriber sessions are brought down. The configuration includes a dual-stack PPPoE subscriber, a Spirent device setup, a traffic stream, a RADIUS user profile, and IPv6 ND RA DNS configuration for versions 7.10.1 or later with BNG mode set to PBNG.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nConsistency verification is performed.\nGet subscriber to verify verification is performed.\nPpp subscriber framed data verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nSubscriber disconnect count verification is performed.\nIpv6 nd idb interface detail verification is performed.\nFramed route traffic verification is performed.\nSubscriber disconnect reason verification is performed.\nBng version verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nipv6 nd interface detail verification for version >=7.10.1 and bng_mode is pbng verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe stress",
                "Procedure": "Dual-stack PPPoE subscriber sessions are brought up, with one session per subscriber distributed in both the default and non-default VRFs. Subscriber session churn is then initiated with a maximum scale of 12.5K subscribers (25%): 10% un-authenticated churn, 50% client reboots, 30% graceful release and connect, and 10% address-family flaps. The stress trigger is performed while this churn activity is ongoing.\n\nThis test is triggered by bringing up dual-stack PPPoE subscriber sessions and initiating subscriber session churn with a maximum scale of 12.5K subscribers.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.stress_triggers\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nConsistency verification is performed.\nGet subscriber to verify verification is performed.\nPpp subscriber framed data verification is performed.\nDynamic routes multiple loopback verification is performed.\nMultiple loopback dynamic route summary verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe single session replay",
                "Procedure": "A test for single-session replay on dual-stack PPPoE subscriber sessions is needed to verify the bring-up and bring-down of these sessions in both default and non-default VRFs, as well as their behavior during churn with access flaps and core flaps. The test includes bringing up PPPoE dual-stack subscriber sessions from Spirent and verifying their configuration.\n\nThis test is triggered by a RADIUS user profile that creates a PPPoE client in Spirent for a dual stack PPPOE subscriber in default and non-default VRF.",
                "Pass/Fail Criteria": "Get subscriber to verify verification is performed.\nSubscriber session details verification is performed.\nSession replay verification is performed.\nConsistency verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verfication verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bng_pppoe_perf_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Single stack ipv4 pppoe single interface racetrack",
                "Procedure": "Test PPPoE single-stack IPv4 subscriber sessions bringup and bringdown CPS on a single interface, specifically with 32K subscribers using the Racetrack config profile. The tests involve creating PPPoE clients using Spirent, polling for the subscriber count in real-time, and verifying the bringup and bringdown CPS rates of 70 and 60 per second respectively. This test is triggered by specifying a list of retries, including \"0\" and \"unlimited\", in the testcase configuration file. The configuration includes IPv4 single-stack PPPoE subscribers in default VRF using the Vodafone profile configs.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 pppoe single interface racetrack",
                "Procedure": "To characterize the Bringup and Bringdown Count Per Second (CPS) for a specific combination of settings, test PPPoE single-stack IPv6 subscriber sessions bringup and bringdown on a single interface. The specified configuration includes: LC Type: THK; RSP Type: RSP5-SE; Subscriber Type: PPPoE Single-stack IPv6; Subscriber scale: 32K; Config Profile: Racetrack; Bundle: One single member bundle with four subinterfaces per bundle; Retries: 0 and unlimited (both cases); Bringup CPS: 70; and Bringdown CPS: 60. This test measures the time taken for bringup or bringdown in seconds. It uses a list of retries, specified as [\"0\", \"unlimited\"], which is defined in the input file under 'testcase_configuration'. The test brings up PPPoE single-stack subscriber sessions from Spirent and performs polling to get the subscriber count with time, then brings down the subscriber sessions while performing polling. Finally, it verifies the bringup and bringdown CPS.\n\nThis test is triggered by a list named \"retries\" that contains the values \"0\" and \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe single interface racetrack",
                "Procedure": "The test characterizes the Bringup and Bringdown Count Per Second (CPS) for a specific combination of settings. The combination includes LC Type: THK, RSP Type: RSP5-SE, Subscriber Type: PPPoE Dual-Stack with 32K subscribers, Config Profile: Racetrack, One single member bundle, Parent Interfaces with 4 subinterfaces per bundle, and Retries set to either 0 or unlimited. During the test, the Bringup CPS is measured at 60 from the client's perspective, and the Bringdown CPS is measured at 50. The CPS measurement takes into account the time taken for bringup or bringdown in seconds. This method also considers a list of retries values, which are specified in the input file under 'testcase_configuration'. To perform the test, PPPoE dual-stack subscriber sessions are brought up and down from Spirent while simultaneously polling to get the subscriber count with time. The results are then verified for Bringup and Bringdown CPS. The configuration for this test includes Dual-stack PPPoE subscribers in default VRF, using the Vodafone profile configs, and a Spirent setup creating PPPoX and DHCPv6 Clients along with Radius user profiles.\n\nThis test is triggered by specifying the list of retries values as either \"0\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "Bng version verification is performed.\nCPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 pppoe single interface feature",
                "Procedure": "Test PPPoE single-stack IPv4 subscriber sessions bringup & bringdown on a single interface, with a focus on bringing up and down 32K subscribers using THK LCs and RSP5-SE RSPs, under the Vodafone/Optus config profile. The test is characterized by four bundle subinterfaces per bundle, zero and unlimited retries, and brings up or takes down subscriber sessions in 0.07 seconds (bringup) or 0.06 seconds (bringdown), as measured from the client perspective. This method accepts a list of retries specified in the input file, with options \"0\" or \"unlimited\", to determine whether to use zero or unlimited retries.\n\nThis test is triggered by passing a list named 'retries' containing two values: '0' and 'unlimited', which are retrieved from the 'testcase_configuration' section of the input file.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 pppoe single interface feature",
                "Procedure": "Testing brings up to 32,000 single-stack IPv6 PPPoE subscriber sessions on a single interface with a count-per-second measurement. The test is characterized by the following combination: THK line cards, RSP5-SE routers, PPPoE Single-stack IPv6 subscribers, and Vodafone/Optus configuration profiles. The test measures bringup and bringdown CPS (count per second) for 70 and 60, respectively. This method takes in a list of retries, which is specified in the input file under 'testcase_configuration', as either \"0\" or \"unlimited\". During the test, we bring up PPPoE single-stack subscriber sessions from Spirent while polling to get the subscriber count with time, then bring down the sessions and repeat the process. The configuration includes single-stack PPPoE subscribers in default VRF, using the Vodafone profile configurations, and a Spirent setup creating PPPoX and DHCPv6 clients.\n\nThis test is triggered by a list of retries specified as either \"0\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe single interface feature",
                "Procedure": "The test measures the Count Per Second (CPS) of bringing up and down a large number of dual-stack subscriber sessions over a single interface using Spirent. The test characterizes the CPS for 32,000 subscribers, with the following configuration: THK LC type, RSP5-SE RSP type, Vodafone/Optus config profile, one bundle with four subinterfaces, and unlimited retries. During bringup, 60 CPS are measured from the client's perspective, while during bringdown, 50 CPS are measured. The test also verifies the time taken for bringing up or down subscribers, which is done by polling the subscriber count simultaneously. This test takes in a list of retry values, specified in the input file under 'testcase_configuration', to determine whether retries are allowed (0) or unlimited. \n\nThis test is triggered by a list named as retries = [\"0\" , \"unlimited\"] being specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 pppoe interface across np racetrack",
                "Procedure": "PPPoE single-stack IPv4 subscriber sessions are brought up and down on a scale of 32,000 subscribers with a configuration that includes one bundle per network processor (NP), four subinterfaces per bundle, and zero or unlimited retries. The bringup and bringdown count per second (CPS) measurements show 70 CPS for bringup and 60 CPS for bringdown, as measured from the client perspective. This test method takes in a list of retry values - \"0\" and \"unlimited\" - specified in the input file's testcase_configuration section.\n\nThis test is triggered by passing a list named 'retries' to the method with values [\"0\", \"unlimited\"].\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 pppoe interface across np racetrack",
                "Procedure": "The test measures the Count Per Second (CPS) of bringup and bringdown for a single-stack IPv6 subscriber session using PPPoE. The test scenario involves a THK LC, RSP5-SE RSP, 32K subscribers, Racetrack config profile, and one bundle per NP from a single LC. The parent interfaces have four subinterfaces each, and retries are set to zero or unlimited in both cases. The CPS is measured as the time taken for bringup or bringdown in seconds. This test takes in a list of retry values from an input file named 'testcase_configuration'. The measurement involves bringing up PPPoE single-stack subscriber sessions from Spirent, polling for the subscriber count simultaneously with each session, and verifying the CPS for both bringup and bringdown operations.\n\nThis test is triggered by providing a list of retries specified in the input file under \"retries\" as either \"0\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe interface across np racetrack",
                "Procedure": "Here is the rewritten paragraph:\n\nWhen testing a PPPoE dual-stack subscriber session bringup and bringdown, we measure the Count Per Second (CPS) across multiple Network Processes (NPs) of a single Line Card (LC). We characterize the bringup and bringdown CPS for the following combination: THK LC type, RSP5-SE RSP type, PPPoE dual-stack subscriber type, 32K subscribers, Racetrack config profile, one single member bundle from each NP, four bundle subinterfaces per bundle, zero or unlimited retries (in both cases), and a bringup CPS of 60 and bringdown CPS of 50. This test takes in a list named 'retries' which is specified in the input file under 'testcase_configuration', and measures the time taken for bringup or bringdown in seconds. The test involves bringing up PPPoE dual-stack subscriber sessions from Spirent, polling to get the subscriber count with time, verifying the bringup and bringdown CPS, configuring dual-stack PPPoE subscribers in default VRF using Vodafone profile configs, creating PPPoX and DHCPv6 clients on Spirent, and setting a radius user profile. This test is triggered by the value of 'retries' in the input file under 'testcase_configuration', which can be either \"0\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 pppoe interface across np feature",
                "Procedure": "When testing a single LC with one NP, we measure the bringup and bringdown Count Per Second (CPS) for 32K PPPoE single-stack IPv4 subscribers. The test is conducted using THK as the LC type, RSP5-SE as the RSP type, and Voafone/Optus config profile. We focus on a specific bundle consisting of one member from each NP, with four bundle subinterfaces per parent interface. Two retry cases are considered: 0 retries and unlimited retries. The test involves bringing up PPPoE single-stack subscriber sessions from Spirent while simultaneously polling for the subscriber count over time to measure bringup CPS. Similarly, we bring down subscriber sessions and poll for the subscriber count in real-time to determine bringdown CPS. We aim to verify the accuracy of these measured CPS values. This test is triggered by a list named \"retries\" that includes both \"0\" and \"unlimited\", which is specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 pppoe interface across np feature",
                "Procedure": "The test measures the Bringup and Bringdown Count Per Second (CPS) for a specific combination of devices, including a THK LC, RSP5-SE RSP, and PPPoE Single-stack IPv6 subscribers. The measurement involves bringing up and down 32,000 subscribers across four bundle subinterfaces with zero or unlimited retries. The test also characterizes the Bringup and Bringdown CPS for this specific scenario, which includes a single member bundle from each node processor of one line card. The method takes into account a list of retry values specified in an input file under 'testcase_configuration'. This test is triggered by providing a list named as retries = [\"0\", \"unlimited\"] in the input file.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe interface across np feature",
                "Procedure": "The test involves measuring the count per second of subscriber session bringup and bringdown on a single Line Card, using Spirent to simulate PPPoE dual-stack subscribers. The configuration includes THK Line Cards, RSP5-SE Remote Switching Processors, 32K subscribers, Vodafone/Optus config profiles, one bundle member from each Network Processor, four bundle subinterfaces per bundle, and no or unlimited retries. Spirent is used to bring up and bring down the subscriber sessions while polling for the subscriber count in real-time. This test takes into account the time it takes for each operation to complete. This test is triggered by a list of retry values, including \"0\" and \"unlimited\", which are specified in an input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 pppoe interface across lc racetrack",
                "Procedure": "The test characterizes the Bringup and Bringdown Count Per Second (CPS) for a combination of settings, including LC Type: THK, RSP Type: RSP5-SE, Subscriber Type: PPPoE Single-stack IPv4, Subscriber scale: 32K, Config Profile: Racetrack, and Bundle: One single member bundle from each LC. The test takes place on parent interfaces with 4 bundle subinterfaces per bundle, with retries set to both 0 and unlimited. The Bringup CPS is measured at 70 CPS (from the client), while the Bringdown CPS is measured at 60 CPS. This test is triggered by passing a list named 'retries' containing either \"0\" or \"unlimited\", as specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 pppoe interface across lc racetrack",
                "Procedure": "We test the Count Per Second (CPS) for bringing up and down single-stack IPv6 PPPoE subscriber sessions across Local Controllers, specifically with THK LCs, RSP5-SE RSPs, 32K subscribers, and Racetrack config profiles. The bringup and bringdown CPS are measured as follows: 70 CPS from the client's perspective for bringup and 60 CPS for bringdown. This test is triggered by a list of retries specified in the input file under 'testcase_configuration', which includes either \"0\" or \"unlimited\". We simulate bringing up PPPoE single-stack subscriber sessions, perform polling to get the subscriber count with time, then bring down the sessions and repeat the polling process. We verify the CPS measurements for both bringup and bringdown processes. The test configuration is set up as follows: an IPv6 Single-stack PPPoE subscriber in the default VRF, using Vodafone profile configs, Spirent creating PPPoX and DHCPv6 clients, and a radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe interface across lc racetrack",
                "Procedure": "The test aims to measure the Count Per Second (CPS) of bringing up and down dual-stack PPPoE subscriber sessions across different Local Controllers (LCs). The scenario involves 32,000 subscribers with a Racetrack configuration, one bundle per LC, four bundle subinterfaces per bundle, and no retries or unlimited retries. The test consists of two phases: bringup and bringdown. In the bringup phase, subscriber sessions are created by Spirent, and polling is performed simultaneously to get the subscriber count in real-time. The time taken for this process is measured in seconds. The same procedure is repeated in the bringdown phase, where subscriber sessions are terminated, and the subscriber count is polled in real-time. This test is triggered by a list of retries values specified in an input file under 'testcase_configuration', which includes either \"0\" or \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv4 pppoe interface across lc feature",
                "Procedure": "Here is the rewritten paragraph:\n\nTo characterize the performance of a single-stack PPPoE subscriber session bringup and bringdown process, we tested the Count Per Second (CPS) metric across multiple Line Cards (LCs). We used the following configuration: THK LC Type, RSP5-SE RSP Type, 32K subscribers, Vodafone/Optus Config Profile, one single member bundle from each LC, and four bundle subinterfaces per bundle. The bringup CPS was measured to be 70 while the bringdown CPS was 60. We also varied the retries from 0 to unlimited for both cases.\n\nThis test is triggered by a method that takes in a list of retries specified in the input file under 'testcase_configuration', which includes two options: \"0\" and \"unlimited\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Single stack ipv6 pppoe interface across lc feature",
                "Procedure": "The test characterizes the Bringup and Bringdown Count Per Second (CPS) for a specific combination of configuration settings. The parameters include THK LC type, RSP5-SE RSP type, PPPoE Single-stack IPv6 subscriber type, 32K subscribers, Vodafone/Optus config profile, one single-member bundle from each LC, four parent interfaces per bundle, and retries set to either 0 or unlimited. During the test, 70 CPS is expected for bringup and 60 CPS for bringdown from the client's perspective. The measurement of CPS involves calculating the time taken in seconds for bringing up or down subscriber sessions using Spirent polling. To verify the results, the subscribers' count with time is simultaneously monitored during the process. \n\nThis test is triggered by a list named retries containing the values '0' and 'unlimited', specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe interface across lc feature",
                "Procedure": "The test characterizes the count per second (CPS) for bringing up and down dual-stack PPPoE subscriber sessions across Local Concentrators (LCs). It measures CPS in scenarios with 32K subscribers, using RSP5-SE routers, THK LC type, Vodafone/Optus config profile, and one single-member bundle from each LC. The test uses Spirent to create PPPoX and DHCPv6 clients and Radius user profiles, while simultaneously polling for subscriber counts during bringup and bringdown operations. This test is triggered by a list of retries specified in the input file as '0' or 'unlimited'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nretries: \"ApData.zap.get_testcase_configuration('retries_mode')\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Coa unidimensional",
                "Procedure": "The system tests the COA response rate in a unidimensional scenario where only COA requests are present. The configuration for this test includes setting up 50K dual-stack PPPoE subscriber sessions, bringing them up with CoA requests triggered at a rate of 40 per second, with a timeout period of 3 seconds and one retry attempt. This test is triggered by a combination of the request rate, timeout, and retry settings: (a) Request rate: 40 req/sec (b) Timeout: 3 sec (c) Retry: 1.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nMeasure following CoA Performance parameters: verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Coa multidimensional",
                "Procedure": "In the test of multidimensional COA performance parameters, we characterize the COA response rate in a scenario where there are both subscriber churn and CoA requests within the system. The configuration for this test includes bringing up 50K dual-stack PPPoE subscriber sessions and triggering CoA requests at a rate of 40 per second with a timeout of three seconds and one retry. Additionally, we consider the impact of subscriber session churn in this scenario.\n\nThis test is triggered by specific combinations of CoA request parameters: (a) a request rate of 40 per second, (b) a timeout of 3 seconds, (c) a single retry attempt.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nMeasure following CoA Performance parameters: verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Macoa unidimensional",
                "Procedure": "Characterize the response of a Mobile Anchor-Coordinate of Care (MA-COA) system in an unidimensional scenario where only COA requests are present. The test configuration involves bringing up 50K dual-stack PPPoE subscriber sessions, which triggers MA-CoA requests with the following characteristics: a request rate of 40 per second, a timeout of three seconds, and one retry attempt.\n\nThis test is triggered by the presence of 50K dual-stack PPPoE subscriber sessions.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nMeasure following CoA Performance parameters: verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Macoa multidimensional",
                "Procedure": "The Multidimensional MA-COA Performance Parameters test characterizes the MA-COA response rate in a multidimensional scenario, where subscriber churn and COA requests are simultaneously present. To configure this test, first bring up 50K dual-stack PPPoE subscriber sessions. Then, trigger MA-CoA requests according to specific combinations of request rates, timeouts, and retries: with a request rate of 40 per second, a timeout of three seconds, and one retry attempt. Finally, apply additional test conditions by simulating subscriber session churn.\n\nThis test is triggered by the combination of factors including a high request rate of 40 requests per second, a timeout period of three seconds, a single retry attempt, and the presence of subscriber session churn in the system.",
                "Pass/Fail Criteria": "Subscriber session count verification is performed.\nMeasure following CoA Performance parameters: verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe memory utils",
                "Procedure": "This test is triggered by the need to collect memory statistics during bringup/bringdown (P0 TC), specifically after bringing up a single-stack or dual-stack PPPoE subscriber session in a mixed VRF with the subscriber stack specified as a parameter. During the test, memory statistics are collected for each subscriber session, and the sessions are then brought down. The test configuration involves a single- or dual-stack PPPoE subscriber, a Spirent device creating a PPPoE client, and a RADIUS user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmemory_subscriber_stack: \"ApData.zap.get_testcase_configuration('memory_subscriber_stack')\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nPool verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "bng_pppoe_srg_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Cnbng nal association",
                "Procedure": "The test of CNBNG CP-UP Association on SRG nodes involves verifying the connection status after breaking and restoring connectivity, as well as clearing association and re-configuring NAL configs. To achieve this, the test first breaks the CP-UP connectivity on one of the SRG UPs by setting an ACL, then checks that the CP-UP Connection is down but the Association is Active after three heartbeats. The connection is then restored and verified to be active along with the association. Next, the cp association from the UP is cleared and it's confirmed that the CP-UP Connectivity is Down and association is Inactive. This process is followed by un-configuring and re-configuring cnbng-nal. All these steps are repeated on the other SRG node. The test also involves manually unconfiguring and configuring cnBNG-NAL.\n\nThis test is triggered by performing an action that breaks the CP-UP connectivity, which causes the ACL to be set.",
                "Pass/Fail Criteria": "Cp up association verification is performed.\ncnbng-nal association status CLI on UP verification is performed.\nshow peers CLI on CP verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg bringup",
                "Procedure": "Here is the rewritten paragraph:\n\nThis method takes in a list of protocols specified in the input file under 'testcase_configuration', including IP, IPv6, and dual-stack (IPV4V6). It brings up PPPoE dual-stack subscriber sessions in both R1 and R4 from Spirent with CHAP authentication, double tag VLAN, and default VRF. The test covers various methods of IPv4 address allocation through radius using Cisco AVP \"addr-pool\" or IETF AVP \"Framed-pool\", as well as addressing through the cnBNG CP's dynamic-template. For CPE WAN interface IPv6 address configuration, it includes methods such as stateful-IPv6-address-pool attribute from radius, IANA pools referred locally in dynamic-templates, and DHCPv6 address pool. The test also performs DHCPv6 PD over PPPoE with various prefix delegation methods through radius using Delegated-IPv6-Prefix attribute or cisco avp \"delegated-ipv6-pool\". Additionally, it assigns attributes from radius in access-accept such as primary and secondary DNS servers, IPv4-unnumbered, and IPv6-enable. The test verifies that sessions are synced from Master to Slave and runs bidirectional ipv4 and ipv6 traffic with sources as CPE WAN IPv6 address or derived from delegated prefix. Finally, it brings down subscriber sessions and verifies subscriber session and service accounting.\n\nThis test is triggered by a configuration protocol list specified in the input file under 'testcase_configuration'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nconfig_protocol: \"ApData.zap.get_testcase_configuration('configuration_protocol')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nCnbng srg related parameters verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfd cscvy50856 dual stack pppoe srg rpfo session cleanup verificaition",
                "Procedure": "A test is run to clean up after a Rpfo on standby srg node (P0 TC) that triggers a PPPoE dual-stack subscriber session bringup & bringdown SRG with RPFO trigger on the standby node, and checks for any sessions stuck in \"in progress\". The test involves bringing up PPPoE dual-stack subscriber sessions in both R1 and R4 from Spirent with Default VRF and Non Default VRF. Subscribers are then brought down and an RPFO trigger is performed on the standby srg node. After this, it's verified that subscribers are down within 12 minutes and no session is stuck in \"in progress\". Finally, subscriber sessions and service accounting are verified.\n\nThis test is triggered by a user profile with radius settings.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\ncheck if subscribers are stuck in progress state verification is performed.\nAfter bringing some sessions down ,Verify no subscriber is stuck in \"in progress\" state after performing rpfo on standby trigger. verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg track failure",
                "Procedure": "Dual-stack PPPoE subscriber sessions are brought up and taken down on both R1 and R4 with Spirent, using CHAP authentication and Double tag VLAN in the default VRF. Subscriber redundancy groups with bundle-ether subinterfaces are configured in each group, and IPv4 address allocation is tested through radius using cisco AVP \"addr-pool\", IETF AVP \"Framed-pool\", or locally referred pools in dynamic-templates by cnBNG CP. CPE WAN interface IPv6 addresses are also configured through various methods: IANA via radius attributes \"Stateful-IPv6-Address-Pool\" and \"stateful-ipv6-address-pool\", DHCPv6 address pools, and server profiles in cnBNG CP. Additionally, prefix delegation is tested through radius using \"Delegated-IPv6-Prefix\", \"Delegated-IPv6-Prefix-Pool\", and PD pools referred locally in dhcpv6 server profiles or dynamic-templates by cnBNG CP. Relevant attributes are assigned from radius in access-accept, including primary and secondary DNS, IPv4 unnumbered, and IPv6 enable. Sessions are verified to sync from Master to Slave, bidirectional ipv4 traffic is run, and bidirectional ipv6 traffic is tested with source addresses as both CPE WAN and LAN IPv6 addresses.\n\nThis test is triggered by a dual-stack PPPoE subscriber session on the network.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrack_fail: \"ApData.zap.get_testcase_configuration('track_failure')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nAccounting verification is performed.\nSubscriber session count verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg rpfo",
                "Procedure": "Here is the rewritten paragraph:\n\nThis test verifies dual-stack PPPoE subscriber sessions, including bringup and bringdown distributed across both default and non-default VRFs, with RPFO (Redundant Pseudo Wire Forwarding) on master/slave. It tests PPPoE dual-stack subscriber sessions in R1 and R4 from Spirent with CHAP authentication, double tag VLAN, and default VRF. The test also covers various methods of IPv4 address allocation using radius, including cisco AVPs \"addr-pool\" and \"Framed-pool\", as well as IETF AVP \"Framed-pool\". It also tests CPE WAN interface IPv6 address configuration using IANA, including radius attributes \"Stateful-IPv6-Address-Pool\" and \"stateful-ipv6-address-pool\". DHCPv6 PD (Prefix Delegation) is tested over PPPoE, as well as various methods of prefix delegation. Additionally, the test assigns specific radius attributes to access-accept, such as primary and secondary DNS servers, IPv4-unnumbered, and IPv6-enable. The test also verifies that sessions are synced from Master to Slave, runs bidirectional IPv4 and IPv6 traffic, including source as CPE WAN and LAN IPv6 addresses, brings down subscriber sessions, and verifies subscriber session and service accounting.\n\nThis test is triggered by configuring a dual-stack PPPoE subscriber in default VRF with Spirent traffic stream and radius user profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrpfo_mode: \"ApData.zap.get_testcase_configuration('rpfo_trigger')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber session count verification is performed.\nContext verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg coa",
                "Procedure": "Dual-stack PPPoE subscriber sessions with SRG are tested on a network that includes two VRFs. The test simulates the setup and teardown of these sessions by activating and deactivating services, running bidirectional IPv4 and IPv6 traffic, sourcing the IPv6 traffic from both the CPE WAN address and the delegated prefix, disconnecting the subscriber session using a POD message, and verifying that the subscriber session and service accounting are functioning correctly. The test configuration includes a dual-stack PPPoE subscriber in default VRF, a Spirent device creating a PPPoE client, and traffic streams for both IPv4 and IPv6 bidirectional traffic. This test is triggered by a radius user profile.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nSubscriber session count verification is performed.\nAccounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg macoa",
                "Procedure": "Dual-stack PPPoE subscriber sessions with SRG are tested for all combinations of MA-CoA/POD operations. The test setup includes bringing up dual-stack PPPoE subscriber sessions in both default and non-default VRFs. Various multi-action combinations of CoA operations, such as Activate-service and Deactivate-service, are performed and their functionalities are verified after the MA-CoA operation with traffic flowing through. The test also involves disconnecting the subscriber session using POD and verifying the status of the session and service accounting. The configuration for this test includes a dual-stack PPPoE subscriber in default and non-default VRFs, Spirent creating a PPPoE and DHCPv6 PD client, and a RADIUS user profile with sample attributes.\n\nThis test is triggered by testing all combinations of MA-CoA/POD operations on dual-stack PPPoE subscriber sessions with SRG.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber session count verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verifications verification is performed.\nKeepalive failures verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg httpr",
                "Procedure": "Test the functionality of HTTPR on dual-stack PPPoE subscriber sessions by bringing up 50K subscriber sessions with various configurations, including default and non-default VRFs, HTTP-R applied through Radius during bringup, and HTTP-R applied through feature-templates. This test is triggered by triggering a CoA (Change of Authorization) request for the subscriber sessions to deactivate the HTTP-R service and activate the HSI service, while running non-HTTP IPv4 and IPv6 traffic on all subscriber sessions, and then bringing down the sessions and verifying the session and service accounting.\n\nTrigger MA-CoA for subscriber sessions to deactivate HTTP-R service and activate HSI service.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nPbr summary verification is performed.\nSubscriber session count verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg admin switchover",
                "Procedure": "This test is triggered by the completion of a series of PPPoE dual-stack subscriber sessions setup on devices R1 and R4, utilizing CHAP authentication and Double tag VLAN. The sessions are brought up and down in both default and non-default VRFs, while testing various methods of IPv4 address allocation through Radius using Cisco AVPs or IETF attributes, as well as CPE WAN interface IPv6 address configuration via IANA or DHCPv6 pools. Additionally, the test covers prefix delegation through Radius using Delegated-IPv6-Prefix attributes or cisco AVPs. The setup also includes assigning various attributes from Radius in access-accept, including primary and secondary DNS servers, IPv4 unnumbered, and IPv6 enablement. The test verifies that sessions are synced between Master and Slave devices before performing admin switchover from Master to Slave, and then from New Master to Slave, while running bidirectional ipv4 and ipv6 traffic. Finally, the test brings down subscriber sessions and verifies session and service accounting.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber session count verification is performed.\nContext verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nStatistics accounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg session limit",
                "Procedure": "The test session limit functionality is designed to handle dual-stack PPPoE subscriber sessions with SRG (P0 TC). This test is triggered by bringing up PPPoE dual-stack subscriber sessions on R1 and R4 from Spirent, using CHAP authentication and double tag VLAN in default VRF. The test covers various methods of IPv4 address allocation, such as through radius using Cisco AVPs or IETF attributes, and IPv6 address configuration through stateful pools or DHCPv6 addresses. Additionally, it performs DHCPv6 prefix delegation over PPPoE, assigns various attributes from the radius server in access-accept, and verifies limited sessions are synced between Master and Slave nodes. The test also includes switchover scenarios, bidirectional traffic runs for IPv4 and IPv6, session bringdown, and verification of subscriber session and service accounting.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy group id verification is performed.\nSubscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg hold revertive timer",
                "Procedure": "Here is the rewritten paragraph:\n\nThis test evaluates the functionality of hold timer and revertive timer on dual-stack PPPoE subscriber sessions with SRG (P0 TC). It tests the bringup and bringdown of PPPoE dual-stack subscriber sessions distributed in default and non-default VRF, including configuration for hold timer and revertive timer. The test covers various methods of IPv4 address allocation, such as through radius using cisco AVP \"addr-pool\" or IETF AVP \"Framed-pool\", and IPv6 address configuration using IANA prefixes assigned by the network via DHCPv6 or Stateful-IPv6-Address-Pool attribute. Additionally, it performs prefix delegation using Delegated-IPv6-Prefix attribute, PD pool referred locally in dhcpv6 server profile, and dynamically assigns attributes from radius in access-accept. The test also verifies that sessions are synced from Master to Slave, performs switchover and revertback with verification of hold timer expiration, runs bidirectional IPv4 and IPv6 traffic, brings down subscriber sessions, and checks for proper subscriber session and service accounting.\n\nThis test is triggered by the configuration of a dual-stack PPPoE subscriber in default VRF, using Spirent as the traffic stream generator, a radius user profile for authentication.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nRadius accounting records verification is performed.\nAccounting verification is performed.\nSubscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg idle timeout",
                "Procedure": "A test is conducted on dual-stack PPPoE subscriber sessions with SRG (P0 TC) to assess functionality, specifically idle timeout. The test involves bringing up and down dual-stack PPPoE subscriber sessions distributed between default and non-default VRFs on routers R1 and R4 from Spirent using CHAP authentication and double-tag VLAN. Subscriber redundancy groups are configured with bundle-ether subinterfaces in each group, and various methods of IPv4 address allocation (through Radius with cisco AVP \"addr-pool\", IETF AVP \"Framed-pool\", or locally referred pool) and CPE WAN interface IPv6 address configuration (using IANA attributes such as \"Stateful-IPv6-Address-Pool\" or referring a DHCPv6 address pool) are tested. The test also covers DHCPv6 PD over PPPoE, prefix delegation through Radius using \"Delegated-IPv6-Prefix\" or \"Delegated-IPv6-Prefix-Pool\", and prefix delegation pools referred locally in dhcpv6 server profiles or dynamic-templates. Additionally, the assignment of various radius attributes (primary and secondary DNS, IPv4-unnumbered, IPv6-enable, DNS-Server-IPv6-Address, and Framed-Prefix-Length) is tested from Radius in access-accept. The test verifies that sessions are synced between Master and Slave routers, waits for idle time to expire, clears sessions on both Master and Slave, and ensures stop accounting is sent only from the Master. Configuration involves setting up dual-stack PPPoE subscribers in default VRF with Spirent traffic stream and Radius user profile.\n\nThis test is triggered by a test idle timeout functionality on dual-stack PPPoE subscriber sessions with SRG (P0 TC).",
                "Pass/Fail Criteria": "Redundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber session count verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nAccounting on router verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg keepalive expiry",
                "Procedure": "Dual-stack PPPoE subscriber sessions with SRG (P0 TC) bring up and bring down distributed in default and non-default VRF with keepalive expiry. This test is triggered by bringing up PPPoE dual-stack subscriber sessions in both R1 and R4 from Spirent, using the following configurations: CHAP authentication, double tag VLAN, and default VRF. Subscriber redundancy groups are configured with bundle-ether subinterfaces in each group, covering various methods of IPv4 address allocation through Radius, such as through cisco AVP \"addr-pool\" or IETF AVP \"Framed-pool\". It also covers CPE WAN interface IPv6 address configuration using IANA, either through Radius with \"Stateful-IPv6-Address-Pool\" attribute or cisco avp \"stateful-ipv6-address-pool\", and DHCPv6 PD over PPPoE. The test further covers prefix delegation methods: through Radius using \"Delegated-IPv6-Prefix\" attribute, Delegated-IPv6-Prefix-Pool attribute or cisco avp \"delegated-ipv6-pool\", and PD pool referred locally in DHCPv6 server profile or dynamic-template in cnBNG CP. Attributes such as primary and secondary DNS, IPv4-unnumbered, IPv6-enable, DNS-Server-IPv6-Address, and Framed-Prefix-Length are also assigned from Radius in access-accept. The test verifies that sessions are synced from Master to Slave, cleared when the access interface is shut down, and accounting is stopped only from the Master.",
                "Pass/Fail Criteria": "Redundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nPpp statistics summary verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nAccounting on router verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg account logon off",
                "Procedure": "PPPoe dual-stack subscriber sessions with SRG (P0 TC) functionality involves bringing up and down sessions on both R1 and R4 routers from Spirent, using various authentication methods such as CHAP and double-tag VLAN. The test covers multiple scenarios for IPv4 address allocation, including radius-based allocation through Cisco AVPs or IETF attributes, as well as dynamic-template-based allocation with locally referred pools. Additionally, it tests various methods for CPE WAN interface IPv6 address configuration, including IANA and DHCPv6 address pools. Prefix delegation is also tested using radius-based allocation, Cisco AVPs, and dynamic-template-based allocation. The test also verifies that attributes such as primary DNS, secondary DNS, IPv4 unnumbered, IPv6 enable, and DNS server IPv6 addresses are assigned from the radius in access-accept. Sessions are synced from Master to Slave, account logon is performed, subscriber manager statistics are verified, and finally, account logoff is performed to check that subscribers are going down.\n\nThis test is triggered by configuring a dual-stack PPPoE subscriber in default VRF with Spirent, traffic stream, and radius user profile.",
                "Pass/Fail Criteria": "Redundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber session details verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg slave noconfig",
                "Procedure": "PPP dual-stack subscriber sessions bringup and bringdown were tested, distributed across default and non-default VRFs by removing the slave configuration and verifying that no crash occurred. The test involved bringing up PPP dual-stack subscriber sessions on both R1 and R4 using Spirent with various configurations, including CHAP authentication, double tag VLAN, and different methods of IPv4 address allocation through radius using Cisco AVPs or IETF AVPs. Similarly, the test covered multiple methods of CPE WAN interface IPv6 address configuration using IANA, radius attributes, or DHCPv6 pools referred locally in dynamic-templates or server profiles. Additionally, DHCPv6 PD was performed over PPPoE, and various prefix delegation methods were tested through radius attributes or local PD pools. The test also involved assigning specific RADIUS attributes to subscriber sessions, including DNS servers, IPv4/IPv6 unnumbered configuration, and framed prefix lengths. To ensure synchronization of sessions between Master and Slave devices, the test verified that all sessions remained synced after removing configurations from the Slave device and bringing down subscriber sessions. Configuration was in dual-stack PPPoE subscribers in default VRF with Spirent and a RADIUS user profile.\n\nThis test is triggered by changing the \"slave_config\" attribute to 'false' in the configuration file for the BNG.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber session count verification is performed.\nContext verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfd dual stack pppoe srg with peer route disable rpfo",
                "Procedure": "PPPoE dual-stack subscriber sessions are brought up in active-standby mode with peer-route-disable configuration. The test then performs SRG SWO, followed by RPFO on the new standby node while restarting a few PPPoE sessions from the CPE. During this time, PPPoE dual-stack subscriber sessions are brought up in both R1 and R4 from Spirent using CHAP authentication, double tag VLAN, and default VRF. Subscriber redundancy groups with bundle-ether subinterfaces are configured in each group, covering methods of IPv4 address allocation through radius using cisco AVP \"addr-pool\", IETF AVP \"Framed-pool\", and locally referred pools. The test also covers CPE WAN interface IPv6 address configuration methods: IANA through radius using \"Stateful-IPv6-Address-Pool\" attribute, dhcpv6 address pool referred locally in dynamic-template or server profile, and DHCPv6 PD over PPPoE. Additionally, prefix delegation is covered through radius using \"Delegated-IPv6-Prefix\", Delegated-IPv6-Prefix-Pool attribute, or cisco avp \"delegated-ipv6-pool\". Radius attributes are assigned from access-accept, including primary and secondary DNS servers, ipv4-unnumbered, ipv6-enable, and DNS-Server-IPv6-Address. The test verifies session syncing from Master to Slave and runs bidirectional IPv4 and IPv6 traffic: source as CPE WAN IPv6 address and LAN IPv6 address (derived from delegated prefix). Finally, subscriber sessions are brought down and verified, along with service accounting.\n\nThis test is triggered by triggering a scenario where PPPoE dual-stack subscriber sessions bringup occurs in active-standby mode with peer-route-disable configuration.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nRedundancy groups verification is performed.\nRedundancy group id verification is performed.\nSubscriber session count verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack cnbng track failure",
                "Procedure": "Dual-stack PPPoE subscriber sessions bring-up and bringdown in mixed VRFs, including default and non-default VRFs, with Service Route Group trigger. The test case is triggered by a specific set of srg triggers, such as core track flap, access interface flap, graceful switchover, and N4 link failure. Configuration includes setting up a Radius user profile, scaling on both SRG nodes, configuring tracks and SRG parameters on the UP node, configuring SRG parameters on the CP node, clearing dynamic-routes and cp-srg association, and verifying successful SRG sync on the CP node. The test also involves validating subscriber sessions with Radius start checks, performing detailed verification of subscriber services, running bidirectional IPv4, IANA, and IAPD traffic, and verifying router accounting for the traffic ran. The test case is designed to test service route group switchover trigger, including successful switchover, recovery from switchover, and bringback to original state, as well as validating SRG specific parameters and Radius stats for session and service accounting. \n\nThis test is triggered by a set of specific srg triggers such as 'core_track_flap', 'access_interface_flap', 'graceful_switchover', 'n4_link_failure'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"core_track_flap\" and \"access_interface_flap\" and \"graceful_switchover\" and \"n4_link_failure\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nCnbng up srg summary verification is performed.\nSrg grp details verification is performed.\nRadius accounting records verification is performed.\nAccounting verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nAccounting on router verification is performed.\nRadius accounting verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe missing definitions",
                "Procedure": "When bringing up a dual-stack PPPoE subscriber session, the test is triggered by testing that the configs are missing as specified in the 'missing_config' parameter, such as qos and acl.\n\nConfiguration: Radius user profile, Spirent (creating PPPoE client), Dual stack PPPoE subscriber, SRG parameters to have Active / Active configuration. The test involves configuring scale on both SRG nodes, removing existing config of QoS/A CL/PBR from Active and Standby, configuring tracks and SRG parameters, performing pre-test validations, trying dual-stack PPPoE subscriber sessions bring-up, disconnecting subscriber sessions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmissing_config: \"qos\" and \"acl\" and \"pbr\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg bringup rabapol spi",
                "Procedure": "This test is triggered by the following configuration: Test PPPoE dual-stack subscriber sessions bringup & bringdown with rabapol, spi, mix (P0 TC) This method takes a list of feature modes specified in the input file under 'testcase_configuration', which includes \"rabapol_mode\", \"spi_mode\", and \"mix_mode\". The test brings up PPPoE dual-stack subscriber sessions in both R1 and R4 from Spirent with CHAP authentication, Double tag VLAN, and default VRF. It also covers various methods of IPv4 address allocation through radius using cisco AVPs or IETF attributes, as well as CPE WAN interface IPv6 address configuration through radius or DHCPv6 pools. The test performs DHCPv6 PD over PPPoE and covers prefix delegation methods through radius or local pools. Additionally, it assigns various attributes from radius in access-accept, including DNS servers and IPv4/IPv6 enablement. The test verifies session synchronization, bidirectional ipv4 traffic, bidirectional ipv6 traffic (source as CPE WAN IPv6 address and source as CPE LAN IPv6 address), subscriber session bringdown, and service accounting.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nfeature_mode: \"ApData.zap.get_testcase_configuration('feature_mode')\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nCnbng srg related parameters verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nAccounting verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe rabapol with coa",
                "Procedure": "Here is the rewritten paragraph:\n\nWe bring up PPPoE dual-stack subscriber sessions in both R1 and R4 from Spirent with various configurations, including CHAP authentication, double tag VLANs, and default VRF. We cover multiple methods of IPv4 address allocation, such as using radius with Cisco AVP \"addr-pool\" or IETF AVP \"Framed-pool\", and local pools referred to in dynamic-templates by cnBNG CP. For CPE WAN interface IPv6 address configuration, we test both IANA methods, including radius attributes like \"Stateful-IPv6-Address-Pool\" and DHCPv6 address pools referred to locally in dynamic-templates or server profiles by cnBNG CP. We also perform DHCPv6 PD with one prefix over PPPoE, covering multiple prefix delegation methods using radius attributes like \"Delegated-IPv6-Prefix\" and \"Delegated-IPv6-Prefix-Pool\". Additionally, we assign various attributes from radius in access-accept, including primary and secondary DNS servers, IPv4-unnumbered, IPv6-enable, and DNS-Server-IPv6-Address. We verify session synchronization between Master and Slave, run bidirectional ipv4 and ipv6 traffic, and bring down subscriber sessions to test accounting.\n\nThis test is triggered by the configuration of a dual-stack PPPoE subscriber in default VRF with Spirent, traffic stream, and radius user profile.",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber session count verification is performed.\nGet subscriber to verify verification is performed.\nCnbng srg related parameters verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nRadius accounting records verification is performed.\nAccounting verification is performed.\npool verification verification is performed.\nsubscriber session verification with coa verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe with invalid coa",
                "Procedure": "Here is the rewritten paragraph:\n\nThis test triggers a PPPoE dual-stack subscriber session bringup & bringdown with an invalid coa service (P0 TC). We bring up PPPoE dual-stack subscriber sessions in both R1 and R4 from Spirent with CHAP authentication, Double tag VLAN, and default VRF. Subscriber redundancy groups are configured with bundle-ether subinterfaces in each group, covering various methods of IPv4 address allocation, such as through radius using cisco AVP \"addr-pool\" or IETF AVP \"Framed-pool\", as well as addressing+I3s pool referred locally in dynamic-template by cnBNG CP. The test also covers CPE WAN interface IPv6 address configuration methods, including IANA through radius using \"Stateful-IPv6-Address-Pool\" attribute or cisco avp \"stateful-ipv6-address-pool\", and DHCPv6 PD over PPPoE, with prefix delegation performed through various means. Additionally, attributes such as primary and secondary DNS, IPv4-unnumbered, IPv6-enable, DNS-server-IPv6-Address, and Framed-Prefix-Length are assigned from radius in access-accept. The test verifies that sessions are synced from Master to Slave, runs bidirectional ipv4 and ipv6 traffic with source addresses derived from CPE WAN IPv6 address or delegated prefix, brings down subscriber sessions, and checks subscriber session and service accounting.\n\nThis test is triggered by the Spirent configuration, which includes a dual-stack PPPoE subscriber in default VRF, a traffic stream, a radius user profile.",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification with coa verification is performed.\nsubscriber redundancy group verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nFADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe srg ha",
                "Procedure": "To test PPPoE High Availability with SRG, a dual-stack PPPoE subscriber session is brought up, distributed across both the default and non-default VRFs. Next, bidirectional IPv4 and IPv6 subscriber traffic is run for 50% of the subscribers, while subscriber churn is triggered for another 25% of the sessions. At this point, CoA/MA-CoA actions are performed on all subscriber sessions. The test should be triggered while these steps are happening: It is triggered by running subscriber churn and performing CoA/MA-CoA on multiple subscriber sessions simultaneously.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Redundancy groups verification is performed.\nRedundancy group id verification is performed.\nGet subscriber to verify verification is performed.\nSubscriber session details verification is performed.\nConsistency verification is performed.\nSubscriber session count verification is performed.\nAccounting verification is performed.\nRadius accounting records verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\npool verification verification is performed.\nsubscriber session verification verification is performed.\nQos Interface verification is performed.\nACL verification verification is performed.\nSADB verification verification is performed.\nRadius accounting verification verification is performed.\nAccounting on router verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg ha no swo",
                "Procedure": "The test involves setting up a dual-stack PPPoE subscriber session with high-availability triggers on an SRG environment without the SRG SWO. The HA triggers to be performed are 'process_restart', 'process_crash', 'rpfo', and 'standby_rsp_oir'. To achieve this, configure a Radius user profile, scale on both SRG nodes, tracks and SRG parameters on UP, SRG parameters on CP, clear cnbng-nal dynamic-routes and cp-srg association, perform SRG synchronize for both UPs, and verify successful SRG sync and role negotiation. Additionally, set up dual-stack PPPoE subscriber sessions in mixed VRF, initiate traffic with Spirent, and simulate subscriber churn through un-auth churn, client reboots, graceful release and connect, and address-family flaps. After CoA for account update on all subscribers is triggered, perform HA triggers while traffic and churn are running, and verify SRG roles negotiated after HA triggers.\n\nThis test is triggered by the following process restarts: 'process_restart', 'process_crash', 'rpfo', and 'standby_rsp_oir'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"process_restart\" and \"process_crash\" and \"rpfo\" and \"standby_rsp_oir\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nSubscriber srg role based count verification is performed.\nSubscribers across srg grp verification is performed.\nSrg grp details verification is performed.\nConsistency verification is performed.\nTraffic verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nCnbng up srg summary verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Dual stack pppoe srg ha swo",
                "Procedure": "Dual-stack PPPoE subscriber session with HA triggers on SRG environment without SRG SWO is tested. The test case takes the HA triggers to be performed as 'trigger' such as reload_up, cp_up_flap, admin_lc_reload, access_interface_flap, and graceful_swo. This test is triggered by a pre-defined set of actions including client reboots, address-family flaps, un-auth churn, and graceful release and connect. Configuration includes Radius user profile, Spirent (creating PPPoE client), dual stack PPPoE subscriber, SRG parameters with Active / Active configuration, and traffic stream (ipv4 and ipv6 bidirectional traffic).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload_up\" and \"cp_up_flap\" and \"admin_lc_reload\" and \"access_interface_flap\"",
                "Pass/Fail Criteria": "Subscriber session details verification is performed.\nConsistency verification is performed.\nTraffic verification is performed.\nCnbng up srg summary verification is performed.\nSubscriber srg role based count verification is performed.\nSubscribers across srg grp verification is performed.\nSrg grp details verification is performed.\nCnbng cp srg sync verification is performed.\nSubscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSRG sync status verification verification is performed.\nSRG groups role negotiation verification verification is performed.\nPool verification verification is performed.\nSubscriber session bringup verification verification is performed.\nQos Interface verification verification is performed.\nCPU overutilization verification verification is performed.\nApplied ACL & ACL count verification verification is performed.\nFADB verification verification is performed.\nSubscriber session distribution across SRG groups verification verification is performed.\nSubscriber per SRG group verification verification is performed.\nSubscriber routes on backup SRG VRF verification verification is performed.\nTraffic Verification verification is performed.\nSubscriber Clean-Up Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe srg feature performance",
                "Procedure": "Characterizing the Bringup and Bringdown Count Per Second (CPS) for pppoe SRG sessions involves several configuration steps and measurements. The test case focuses on a specific combination of parameters, including LC Type: THK, RSP Type: RSP5-SE / RSP-880, Subscriber Type: pppoe SRG, and Subscriber scale: 128K, with Config Profile: Features and Retries: 0 and unlimited. The Bringup and Bringdown CPS are measured at 200 from the client's perspective. The configuration process includes enabling flow control rate on SRG nodes, configuring Radius user profiles, scaling on both SRG nodes, tracking and SRG parameters on UP, SRG parameters on CP, clearing cnbng-nal dynamic-routes and cp-srg association, performing SRG sync with verification of successful sync on CP, verifying srg-roles negotiation on both UPs, pre-test validations, and configuring Spirent. The test case brings up and then down pppoe dual-stack subscriber sessions from Spirent while simultaneously polling to get the subscriber count with time, ultimately verifying the bringup and bringdown CPS.\n\nThis test is triggered by a specific combination of parameters: LC Type (THK), RSP Type (RSP5-SE / RSP-880), Subscriber Type (pppoe SRG), Subscriber scale (128K), Config Profile (Features), Retries (0 and unlimited).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nsession_stack: \"ApData.zap.get_testcase_configuration().get('performance_session_stack', ['IPV4V6'])\"",
                "Pass/Fail Criteria": "CPS verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pppoe srg unidimensional performance",
                "Procedure": "To test the CoA/MA-CoA performance in a unidimensional scenario, configure flow control rates on SRG nodes, user profiles on Radius, and scale parameters. Set up tracks and SRG parameters on both UPs, as well as CP parameters. Clear dynamic routes and association records, then perform an SRG sync and verify its success on the CP. Verify that roles are negotiated correctly on both UPs. Configure Spirent and bring up pppoe dual-stack subscriber sessions. Then, send service deactivation and activation requests through unidimensional CoA to calculate response time, followed by MA-CoA requests.\n\nThis test is triggered by triggering CoA requests at a rate of 80 per second with a timeout of three seconds and one retry, and MA-CoA requests at a rate of 50 per second with the same timeout and retry settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration().get('trigger_type', ['coa', 'macoa'])\"",
                "Pass/Fail Criteria": "Subscriber disconnect count verification is performed.\nSubscriber disconnect reason verification is performed.\nSubscriber session count verification is performed.\nSubscriber session bringup verification is performed.\nMeasure the rate at which CoA/MA-CoA got processed verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "mpls_mgbl_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Verify mgbl mpls oc configuration",
                "Procedure": "MPLS Static is enabled on configured interfaces through Open Config.\n\nThis test verifies that it is triggered by the presence of an MPLS Static interface in the configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nverification_protocol: \"ApData.mgbl_config['verification_protocol']\"\nverification_operation: \"ApData.mgbl_config['verification_operation']\"",
                "Pass/Fail Criteria": "Oc mpls global interface verification is performed.\nMpls static labels verification is performed.\nStop and traffic verification is performed.\nMpls intf oc verification is performed.\nMpls lsp association oc verification is performed.\nMPLS enabled interfaces via OC verification is performed.\nStatic Interface verification via OC verification is performed.\nMPLS Static LSPs verification via OC verification is performed.\nStatic label verification via cli verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Triggers",
                "Procedure": "This testcase is designed to test multiple triggers and verify the functionality of MPLS Static configurations.\n\nTriggers that can be used with this test include:\n* MPLS static configuration trigger. \n\nThis test is triggered by changes made to an MPLS static configuration, which enables testing of its functionalities under various scenarios.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntc_list: \"ApData.mgbl_config['tc_list']\"",
                "Pass/Fail Criteria": "Mpls intf oc verification is performed.\nMpls lsp association oc verification is performed.\nOc mpls global interface verification is performed.\nMpls static labels verification is performed.\nOspf isis neighborship verification is performed.\nBundle port verification is performed.\nBlocked process verification is performed.\nMpls static verification is performed.\nPlatform vm final band verification is performed.\nTraffic verification is performed.\nInterface brief verification is performed.\nVerifyinterface verification is performed.\nStatic interface Binding Verification verification is performed.\nMPLS enabled interfaces via OC verification is performed.\nStatic label verification via cli verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Unconfig mgbl mpls oc configuration",
                "Procedure": "To unconfigure MPLS static interfaces, a test uses an OC delete operation. The test is designed to remove MPLS Static interface configurations.\n\nThis test is triggered by the use of an Open Connect (OC) delete operation on an MPLS Static interface configuration.",
                "Pass/Fail Criteria": "Oc mpls global interface verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "mpls_pd_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Mpls ldp lfa isis bundle",
                "Procedure": "MPLS LDP LFA with ISIS over bundle works correctly when the primary ISIS bundle goes down, directing traffic to a remote LFA path instead. The ISIS and MPLS LDP configurations are part of the module setup, while the LFA and metric are configured as part of the class setup. Traffic is started, then shut down after verifying that it flows via the expected prefix (primary bundle), which is then shut down completely. After shutting down the primary bundle, traffic is re-started and verified to be flowing via the remote LFA path.\n\nThis test is triggered by configuring ISIS and MPLS LDP as part of module setup.",
                "Pass/Fail Criteria": "Isis fast reroute verification is performed.\nStop and traffic verification is performed.\nIsis neighbors verification is performed.\nInitial expected prefix : verify if it is the primary ISIS bundle verification is performed.\nshut primary bundle and verify prefix: verify if it is the remote LFA verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa isis local bfd",
                "Procedure": "The test verifies that MPLS LDP LFA with ISIS over a bundle with BFD (locally shut) works correctly. This test is triggered by verifying that the primary, BFD-enabled ISIS bundle being taken offline causes the remote MPLS LDP LFA to come up as expected. The test involves configuring ISIS and MPLS LDP as part of the module setup, configuring the remote LFA and metric as part of the class setup, enabling BFD with relevant parameters, starting traffic flow, checking that the FRR path is via the expected prefix, shutting down the local BFD-enabled ISIS bundle, stopping and verifying the traffic flow, restarting the traffic flow, rechecking the FRR path to ensure it's still via the expected prefix, then restoring the traffic flow. Finally, BFD is unconfigured on the ISIS bundle interfaces.",
                "Pass/Fail Criteria": "Isis fast reroute verification is performed.\nStop and traffic verification is performed.\nIsis neighbors verification is performed.\nInitial expected prefix : verify if it is the primary bfd enabled ISIS bundle verification is performed.\nshut primary bfd interface and verify prefix: verify if it is the remote LFA verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa isis remote bfd",
                "Procedure": "To test that MPLS LDP Link-Fast Alternate (LFA) with ISIS over bundle with BFD (remote shutdown) works correctly, we first confirm that the primary ISIS bundle, enabled with BFD, is operational. Then, to verify that the remote LFA is up when the primary bundle goes down, we start traffic and check that it's forwarded via the expected prefix using FRR. Next, we shut the remote ISIS interface enabled with BFD, stop and verify the traffic flow, restart the traffic, re-check the FRR path to ensure it's still using the expected prefix, shut the remote ISIS interface once more, and finally, start and verify the traffic flow again after opening up the remote ISIS interface.\n\nThis test is triggered by shutting the remote bfd enabled ISIS interface.",
                "Pass/Fail Criteria": "Isis fast reroute verification is performed.\nStop and traffic verification is performed.\nIsis neighbors verification is performed.\nInitial expected prefix : verify if it is the primary bfd enabled ISIS bundle verification is performed.\nshut primary bfd interface and verify prefix: verify if it is the remote LFA verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa isis ecmp primary backup paths",
                "Procedure": "MPLS LDP LFA with ISIS works fine when there is ECMP primary paths via different neighbors. The test verifies if the MPLS LDP remote LFA (one of the ECMP path) is up when the primary ECMP ISIS path goes down, by verifying that traffic flow is restored via the expected prefix through the FRR path after shutting each of the ECMP ISIS paths in turn. This test is triggered by verifying that MPLS LDP and ISIS are configured correctly as part of the module setup, and that remote LFA and metric are properly set up as part of class configuration.",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nIsis fast reroute verification is performed.\nStop and traffic verification is performed.\nInitial expected prefix : verify if it is the first listed ECMP path prefix verification is performed.\nshut first ECMP and verify prefix: verify if it is the second listed ECMP path prefix verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut second ECMP and verify prefix: verify if it is the first listed ECMP path prefix verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa isis ldp flap",
                "Procedure": "The test verifies that MPLS LDP Loop-Free Alternate (LFA) works correctly when configured over an IS-IS bundle, even if the LDP session is flapped. This test is triggered by configuring LDP on the primary interface.\n\nNote: I removed the personal pronoun \"This\" from the original line and rephrased it to make it grammatically correct.",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nIsis fast reroute verification is performed.\nStop and traffic verification is performed.\nInitial expected prefix : verify if it is the primary ISIS bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary interface and verify prefix: verify if it is the remote LFA verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa isis primary bundle",
                "Procedure": "MPLS LDP LFA with ISIS works fine when using primary bundles through different neighbors. The test verifies that the MPLS LDP remote LFA remains up even if the primary ISIS bundle goes down. To facilitate this, ISIS and MPLS LDP are configured as part of module setup, while the remote LFA and metric are set up during class configuration. This test is triggered by configuring a shut condition on the primary ISIS bundle after traffic has been started, then verifying that the FRR path is taken via an expected prefix, followed by restoring the primary ISIS bundle to its normal operational state.",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nIsis fast reroute verification is performed.\nStop and traffic verification is performed.\nInitial expected prefix : verify if it is the primary ISIS bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the remote LFA verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa isis backup bundle",
                "Procedure": "The test verifies that MPLS LDP LFA with ISIS works correctly when the primary bundle goes down. This test is triggered by shutting down the primary ISIS bundle, which has been previously configured as part of the setup process. \n\nNote: The trigger sentence was rewritten to proper English and placed at the end of the paragraph as requested.",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nIsis fast reroute verification is performed.\nStop and traffic verification is performed.\nInitial expected prefix : verify if it is the primary ISIS bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the backup bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa isis primary vlan sub intf",
                "Procedure": "MPLS LDP LFA with ISIS functions properly with vlan subinterfaces. The test involves verifying that the MPLS LDP remote LFA via vlan subinterface remains up when the primary ISIS bundle goes down. The ISIS and MPLS LDP configurations are set up as part of the module, while the remote LFA and metric are configured within the class setup. Vlan subinterfaces are enabled with a no shut command, traffic is started, and the FRR path is checked to ensure it's via the expected prefix. Traffic flow is then stopped and verified before repeating the process with the primary ISIS bundle disabled. Once disabled, the FRR path is rechecked for the correct prefix and the traffic flow is stopped and verified again. The primary ISIS bundle is then enabled and the configurations include ISIS and MPLS LDP.\n\nThis test is triggered by a failure of the primary ISIS bundle.",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nIsis fast reroute verification is performed.\nStop and traffic verification is performed.\nInitial expected prefix : verify if it is the primary ISIS bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the vlan subinterface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa isis backup vlan sub intf",
                "Procedure": "When the primary VLAN subinterface goes down, we need to verify that MPLS LDP LFA with ISIS works properly via the backup VLAN subinterface. This test is triggered by configuring ISIS FRR on a VLAN subinterface, shutting down the main interface, and verifying that traffic flows through the expected prefix on the backup path.",
                "Pass/Fail Criteria": "Isis neighbors verification is performed.\nIsis fast reroute verification is performed.\nStop and traffic verification is performed.\nInitial expected prefix : verify if it is the primary vlan subinterface verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the backup vlan subinterface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf bundle",
                "Procedure": "MPLS LDP LFA with OSPF over bundle should work properly. The test verifies that the MPLS LDP remote LFA remains up when the primary OSPF bundle goes down, which is achieved through configurations in both module setup (OSPF and MPLS LDP) and class setup (remote LFA and metric). Traffic is started, and it's verified that the FRR path uses the expected prefix (primary bundle), then stopped. The process is repeated with the primary OSPF bundle shut down: traffic is started again, the FRR path is fetched to verify if it uses the remote LFA, and traffic flow is checked before shutting down the primary OSPF bundle. This test is triggered by configuration: OSPF and MPLS LDP.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nStop and traffic verification is performed.\nOspf neighbors verification is performed.\nTraffic verification is performed.\nInitial expected prefix : verify if it is the primary OSPF bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the remote LFA verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf local bfd",
                "Procedure": "The test verifies that MPLS LDP Local Fast ReRoute with OSPF over a bundle, utilizing BFD (local shutdown), functions correctly. This test is triggered by verifying that when the primary OSPF bundle with enabled BFD goes down, the MPLS LDP remote LFA path comes up via the expected prefix. The test includes configuring OSPF and MPLS LDP as part of the module setup, setting up the remote LFA and its metric as part of the class setup, enabling BFD and relevant parameters, starting traffic, fetching the FRR path to verify it's via the expected prefix, stopping and verifying the traffic flow, shutting down the local OSPF bundle with enabled BFD, repeating the previous steps, and finally no-shutting the local OSPF bundle.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nStop and traffic verification is performed.\nOspf neighbors verification is performed.\nTraffic verification is performed.\nInitial expected prefix : verify if it is the primary bfd enabled OSPF bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bfd interface and verify prefix: verify if it is the remote LFA verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf remote bfd",
                "Procedure": "The test verifies that MPLS LDP LFA with OSPF over bundle with BFD works as expected. This test is triggered by shutting down a primary BFD-enabled OSPF bundle, while verifying that the MPLS LDP remote LFA stays up. To replicate this scenario, the OSPF and MPLS LDP configurations are in place, the remote LFA and metric have been configured, and BFD has been enabled with relevant parameters. The test involves starting traffic, checking if the FRR path is via the expected prefix, stopping the flow, restarting it, shutting down the remote BFD-enabled OSPF interface, verifying the FRR path again, stopping the flow once more, and then enabling the interface.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nStop and traffic verification is performed.\nOspf neighbors verification is performed.\nTraffic verification is performed.\nInitial expected prefix : verify if it is the primary bfd enabled OSPF bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bfd interface and verify prefix: verify if it is the remote LFA verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf ecmp primary backup paths",
                "Procedure": "MPLS LDP LFA with OSPF works fine with ECMP primary and backup paths via different neighbors. The test verifies if the MPLS LDP remote LFA is up when another ECMP OSPF path goes down. \n\nThis test is triggered by configuring OSPF metric to establish ECMP, verifying traffic flow through FRR paths for different scenarios of shutting down ECMP OSPF paths and resetting the OSPF metric to its previous state after each test.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nStop and traffic verification is performed.\nTraffic verification is performed.\nInitial expected prefix : verify if it is the first listed ECMP path prefix verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut first ECMP and verify prefix: verify if it is the second listed ECMP path prefix verification is performed.\nshut second ECMP and verify prefix: verify if it is the first listed ECMP path prefix verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf ldp flap",
                "Procedure": "MPLS LDP LFA with OSPF over bundle works fine when the LDP session is flapped, verifying that the remote LFA remains up. The OSPF and MPLS LDP are configured as part of module setup, while the remote LFA and metric are configured as part of class setup. To test this, start the traffic, then fetch the FRR path and verify it's via the expected prefix. Stop and verify the traffic flow, then repeat the process by flapping the LDP session and shutting the primary interface, again fetching the FRR path and verifying it's via the expected prefix before stopping and verifying the traffic flow once more.\n\nThis test is triggered by configuring OSPF and MPLS LDP as part of the module setup.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nStop and traffic verification is performed.\nOspf neighbors verification is performed.\nTraffic verification is performed.\nInitial expected prefix : verify if it is the primary OSPF bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary interface and verify prefix: verify if it is the remote LFA verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf primary bundle",
                "Procedure": "MPLS LDP LFA with OSPF works fine when a primary bundle goes down, verified by checking that the MPLS LDP remote LFA is up via different neighbors. This test is triggered by configuring OSPF and MPLS LDP as part of the module setup, configuring the remote LFA and metric as part of class setup, starting traffic, fetching the FRR path to verify it's via the expected prefix, stopping and verifying traffic flow, shutting the primary OSPF bundle, and repeating the previous steps.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nStop and traffic verification is performed.\nOspf neighbors verification is performed.\nInitial expected prefix : verify if it is the primary OSPF bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the remote LFA verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf backup bundle",
                "Procedure": "To ensure that MPLS LDP LFA with OSPF functions correctly when the primary bundle fails, several steps are taken. OSPF and MPLS LDP are configured as part of module setup, while remote LFA and metric are set up in class configuration. Next, the OSPF FRR backup paths are configured, and traffic is started to verify the flow. After fetching the FRR path, it's checked if it's via the expected prefix; then, traffic is stopped and verified again for flow. The primary OSPF bundle is shut down, and the FRR path is fetched once more to verify that it's still routing through the expected prefix before shutting down the test.\n\nThis test is triggered by the failure of a primary OSPF bundle in an environment where MPLS LDP LFA with OSPF is configured and operating.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nRoute prefix verification is performed.\nStop and traffic verification is performed.\nInitial expected prefix : verify if it is the primary OSPF bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the backup bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf primary bundle backup vlan sub intf",
                "Procedure": "MPLS LDP LFA with OSPF works correctly when the primary interface is a bundle and the backup interface is a subinterface of that bundle, connected via different paths. The test verifies that when the primary OSPF bundle goes down, the MPLS LDP remote LFA via vlan subinterface comes up and uses the expected prefix to forward traffic. This test is triggered by shutting the primary OSPF bundle while traffic is flowing through it, then verifying that the traffic is being forwarded along the FRR path via the expected prefix.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nStop and traffic verification is performed.\nOspf neighbors verification is performed.\nInitial expected prefix : verify if it is the primary OSPF bundle verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the vlan subinterface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp lfa ospf primary backup vlan sub intf",
                "Procedure": "When the primary VLAN subinterface goes down, verification is needed to ensure that MPLS LDP LFA with OSPF works properly via the backup VLAN subinterface. The test checks if the MPLS LDP remote LFA (backup VLAN subinterface) remains up when the primary OSPF VLAN subinterface fails. This requires a specific setup where OSPF and MPLS LDP are configured as part of module setup, the remote LFA and metric is set as part of class setup, and certain interfaces are shut down or no shut at various points during the test to simulate different failure scenarios.\n\nThis test is triggered by a primary OSPF VLAN subinterface going down.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nStop and traffic verification is performed.\nInitial expected prefix : verify if it is the primary vlan subinterface verification is performed.\nStop and verify the traffic flow : verify if the traffic loss is less than 50 ms verification is performed.\nshut primary bundle and verify prefix: verify if it is the backup vlan subinterface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu",
                "Procedure": "The following paragraph describes the process for verifying MPLS MTU functionality:\nTo verify the operation of MPLS (Multiprotocol Label Switching) MTU (Maximum Transmission Unit), IPv4 to MPLS test cases must be run with fragmentation enabled and DF (Don't Fragment) set to 0 on physical, physical sub-interface, bundle, or bundle sub-interface connections. Additionally, the control plane and traffic should be verified for proper operation and to ensure correct handling of fragmented packets.\n\nThis test is triggered by configuring MPLS MTU on physical/physical sub/bundle/bundle sub interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nMpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nInterface accounting check for fragmentation verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu df1",
                "Procedure": "MPLS MTU functionality is verified without fragmentation by checking test cases for physical, physical subinterface, bundle, and bundle subinterface configurations where DF is set to 1. The test also verifies the LDP control plane and traffic when fragmentation occurs with MPLS MTU configured on these interfaces.\n\nThis test is triggered by configuring MPLS MTU settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nMpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nInterface accounting for non-fragment verification verification is performed.\nTraffic drop verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu mpls to mpls",
                "Procedure": "MPLS MTU functionality is verified for tests involving fragmented data frames sent over physical, physical sub, bundle, or bundle sub interfaces with the DF bit set to 0. The test also checks both the LDP control plane and traffic under conditions of fragmentation. To achieve this, an MPLS MTU is configured on specified interface types. This test is triggered by configuring the MPLS MTU.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nInterface accounting check for fragmentation verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu mpls to mpls df1",
                "Procedure": "MPLS MTU functionality is verified for MPLS to MPLS test cases with fragmentation DF set 1, tested on both physical and physical sub, bundle and bundle sub interfaces. The LDP control plane and traffic are also checked for fragmentation with an MPLS MTU configured on the specified interfaces.\n\nThis test is triggered by configuring MPLS mtu.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nInterface accounting for non-fragment verification verification is performed.\nTraffic drop verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu explicit null push",
                "Procedure": "MPLS MTU functionality is verified for explicit null push test cases, particularly those involving fragmentation where DF (Don't Fragment) is set to 0, and tested on physical and bundle interfaces. The setup involves IP traffic flowing between a Traffic Generator (TGEN), PE1, and P routers, with an MPLS packet containing an explicit NULL label being sent by TGEN to the PE1 router. The test verifies both the LDP control plane and traffic in this configuration. This test is triggered by configuring MPLS MTU on physical, sub-bundle, or bundle sub interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nInterface accounting check for fragmentation verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu explicit null swap",
                "Procedure": "MPLS MTU functionality is verified for explicit null swap test cases with fragmentation DF set to 0 on physical, physical subinterface, bundle, and bundle subinterface configurations. The test also checks the MPLS LDP control plane, traffic, and fragmentation when MPLS MTU is configured on these interfaces. This test is triggered by configuring MPLS mtu with a specific setup on physical/physical sub/bundle/bundle sub interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nInterface accounting check for fragmentation verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu bundle remove add",
                "Procedure": "MPLS configuration involves verifying the Maximum Transmission Unit (MTU) with a bundle member's removal and addition, while also checking the MPLS LDP control plane, traffic flow, and potential fragmentation. This test verifies the fragmentation process when an interface is shut down and then re-enabled with the MPLS MTU configured.\n\nThis test is triggered by configuring the MPLS MTU on an interface.",
                "Pass/Fail Criteria": "Bundle port verification is performed.\nMpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nTraffic verification verification is performed.\nInterface accounting check for fragmentation verification verification is performed.\nBundle member remove add verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu bundle member flap",
                "Procedure": "The goal of this test is to verify that the Maximum Transmission Unit (MTU) for Multiprotocol Label Switching (MPLS) is functioning correctly on a bundle interface by simulating a flap, or connection loss and reconnection. The test also involves checking the MPLS Label Distribution Protocol (LDP) control plane and verifying how traffic is fragmented under different circumstances.\n\nThis test is triggered by the event of configuring the MTU for MPLS when the bundle interface goes up or down.",
                "Pass/Fail Criteria": "Interface brief verification is performed.\nMpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nTraffic verification verification is performed.\nInterface accounting check for fragmentation verification verification is performed.\nBundle Interface shut no shut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu phy mpls rollback",
                "Procedure": "The configuration for this test involves setting up an MPLS setup, configuring the MPLS MTU, and then triggering a rollback. The test itself verifies that the MPLS LDP control plane is functioning correctly, as well as the traffic flow and fragmentation in the network.\n\nThis test is triggered by: Configuring MPLS with a configured MTU, followed by a rollback of the configuration.",
                "Pass/Fail Criteria": "Mpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nTraffic verification verification is performed.\nInterface accounting check for fragmentation verification verification is performed.\nmpls ldp remove and roll back verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu phy interface flap",
                "Procedure": "When verifying MPLS MTU, it's essential to check that the interface is flapping properly while also verifying the MPLS LDP control plane and traffic handling, including any potential fragmentation issues.\n\nThis test is triggered by a configuration change, specifically when MPLS MTU is configured.",
                "Pass/Fail Criteria": "Interface brief verification is performed.\nMpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nTraffic verification verification is performed.\nInterface accounting check for fragmentation verification verification is performed.\nPhysical Interface shut no shut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu ipv6",
                "Procedure": "To verify MPLS MTU Ipv6 functionality, a series of test cases should be run on both physical and virtual interfaces (including physical sub-interfaces, bundle interfaces, and their respective sub-interfaces). These tests must also examine the MPLS LDP control plane as well as the traffic flow and fragmentation patterns. The configuration for this verification involves setting up the MPLS MTU parameters.\n\nThis test is triggered by configuring MPLS MTU on all relevant physical/physical sub/bundle/bundle sub interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls mtu value verification is performed.\nMtu exceed verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting with uut incoming intf verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nInterface accounting for non-fragment verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu mpls ping",
                "Procedure": "The test verifies the operation of an MPLS MTU by conducting an MPLS ping test. The MPLS ping should work correctly even when the Maximum Transmission Unit is configured. This test is triggered by a configuration that includes MPLS LDP, OAM, IGP (OSPF and ISIS).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls mtu value verification is performed.\nLimit the MTU verification is performed.\nNeighbourship Verification verification is performed.\nMPLS mtu configuration verification is performed.\nMPLS Ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp mpls mtu ping",
                "Procedure": "To test the maximum transmission unit (MTU) of Multiprotocol Label Switching (MPLS), verify that an MPLS ping works when configured for IPv4 and IPv6. The configuration should include MPLS LDP, Operations, Administration, and Maintenance (OAM), and Interior Gateway Protocol (IGP) with OSPF and ISIS enabled.\n\nThis test is triggered by a verification of the maximum transmission unit for Multiprotocol Label Switching on IPv4 and IPv6 networks.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('test_mpls_mtu/tls')\"",
                "Pass/Fail Criteria": "Mpls mtu value verification is performed.\nOutgoing intf for mtu verification is performed.\nPeer intf accounting for ping verification is performed.\nNeighbourship Verification verification is performed.\nPing and fragmentation verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp discovery exp null",
                "Procedure": "MPLS LDP discovery is tested with the explicit null flag enabled to verify its proper functioning across a network topology.\n\nThis test is triggered by MPLS LDP configuration in conjunction with OSPF or ISIS as an Interior Gateway Protocol.",
                "Pass/Fail Criteria": "Mpls ldp discovery detail verification is performed.\nMpls control plane verification is performed.\nTraffic verification is performed.\nMPLS LDP Discovery and Neighbourship Verification verification is performed.\nEnd to end traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp ping",
                "Procedure": "The test of MPLS OAM Ping uses the default options to verify that it functions correctly across the network topology. This test is triggered by configuring MPLS LDP, OAM, OSPF, and ISIS.",
                "Pass/Fail Criteria": "MPLS Ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp explicit null ping",
                "Procedure": "When testing MPLS OAM Ping with the explicit-null option, it is essential to verify that the test works as expected across the network topology. This includes verifying proper operation from Label Edge Routers (LERs) and Label Switching Routers (LSRs). The configuration for this test should include MPLS LDP, OAM, IGP (OSPF and ISIS).\n\nThis test is triggered by a scenario where MPLS Ping with explicit-null option needs to be tested across various network topologies.",
                "Pass/Fail Criteria": "MPLS Ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp ping different options",
                "Procedure": "MPLS network administrators can test the functionality of OAM Ping with various options to ensure that it operates correctly across different topologies involving Label Edge Routers (LERs), Label Switching Routers (LSRs), and Intermediate System-to-Intermediate System (IS-IS) protocols. Verification is conducted by testing MPLS Ping with a range of options such as EXP, reply DSCP, padding, TTL, RA, timeout, zero destination address and mask, force-explicit-null option, and output interface.\n\nThis test is triggered by the use of MPLS LDP, OAM, IGP (OSPF and ISIS) protocols.",
                "Pass/Fail Criteria": "MPLS Ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp ping load balancing",
                "Procedure": "MPLS OAM Ping is tested in a network that employs load balancing. To verify its functionality across the topology, including connections between Label Edge Routers (LERs) and Label Switching Routers (LSRs) with load-balanced links, the destination address option 127.x.y.z is used. The configuration for this test includes MPLS LDP, OAM, and IGP protocols such as OSPF and ISIS.\n\nThis test is triggered by a network configuration that includes MPLS LDP, OAM, and IGP (OSPF and ISIS).",
                "Pass/Fail Criteria": "MPLS Ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp sweep ping",
                "Procedure": "To test MPLS OAM Ping with the sweep option, verify that it works as expected across a given topology, including connections from Label Edge Routers (LERs) and Label Switching Routers (LSRs). The following configuration is required: Multi-Protocol Label Switching (MPLS), Label Distribution Protocol (LDP), Operations, Administration, and Maintenance (OAM), and Interior Gateway Protocols (IGPs such as OSPF and ISIS).\n\nThis test is triggered by MPLS LDP, OAM, IGP (OSPF and ISIS) configuration.",
                "Pass/Fail Criteria": "MPLS sweep Ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp traceroute",
                "Procedure": "To test MPLS OAM Traceroute with default settings, verify its proper functioning across different network topologies, including connections between Label Edge Routers (LERs) and Label Switching Routers (LSRs). This test is triggered by a configuration that includes Multiprotocol Label Switching (MPLS) LDP, Operations, Administration, and Maintenance (OAM), and Interior Gateway Protocols (IGP) such as OSPF and ISIS.",
                "Pass/Fail Criteria": "MPLS Traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp traceroute different options",
                "Procedure": "The test involves running the MPLS OAM Traceroute with multiple options to verify its proper operation across various topologies. The traceroute should function correctly from both Label Edge Routers (LERs) and Label Switching Routers (LSRs) using different non-default settings, including EXP, reply DSCP, pad, TTL, RA, timeout, zero destination address and mask, force-explicit-null option, and output-interface options. This test is triggered by a configuration that includes MPLS LDP, OAM, and Interior Gateway Protocol (IGP), specifically OSPF and ISIS.",
                "Pass/Fail Criteria": "MPLS Traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp explicit null traceroute",
                "Procedure": "To test MPLS OAM Traceroute with the explicit-null option, verify that the MPLS Traceroute works properly across a given topology from Label Edge Routers (LERs) and Label Switching Routers (LSRs) while the explicit-null feature is configured. The configuration used for this test involves enabling MPLS LDP, OAM, and IGP protocols such as OSPF and ISIS.\n\nThis test is triggered by verifying that the MPLS Traceroute function operates correctly across a network topology with explicit-null option configured on various devices including Label Edge Routers (LERs) and Label Switching Routers (LSRs), utilizing protocols like MPLS LDP, OAM, and IGP (OSPF and ISIS).",
                "Pass/Fail Criteria": "MPLS Traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp traceroute multipath",
                "Procedure": "Testing of MPLS OAM Traceroute with Multipath option should be performed. This test is triggered by verifying that the MPLS Multipath Traceroute works properly across topology from Label Edge Routers (LERs) and Label Switching Routers (LSRs). Configuration includes MPLS LDP, OAM, and Interior Gateway Protocol (IGP), specifically OSPF and ISIS.",
                "Pass/Fail Criteria": "MPLS Multipath Traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp oam ra ratelimiting",
                "Procedure": "MPLS control packet throttling is being tested to verify the MPLS LDP OAM control packet rate limiting functionality. The configuration for this test includes MPLS LDP, OAM, and an Interior Gateway Protocol such as OSPF or ISIS.\n\nThis test is triggered by verifying that the MPLS LDP OAM control packets' rate limiting functionality is operational.",
                "Pass/Fail Criteria": "MPLS ping and Traceroute verification is performed.\nLPTS ratelimit checks verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp ping clear route",
                "Procedure": "To test the MPLS OAM Ping functionality with a clear route, first verify that the route is cleared by using the command 'clear route ipv4 127.0.0.0/8'. This test is triggered by an issue where lspv_server fails to reinstall the route '127.0.0.0/8' and causes MPLS OAM to fail. The test environment consists of a configuration with MPLS LDP, OAM, and IGP protocols (OSPF and ISIS) enabled.",
                "Pass/Fail Criteria": "Route prefix verification is performed.\nMPLS Ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp ping with fragmentation",
                "Procedure": "To verify the functionality of the MPLS ping test with fragmentation, ensure that it operates correctly across different network topologies, including those involving label edge routers (LERs) and label switching routers (LSRs). The necessary configuration includes enabling MPLS LDP, OAM features, as well as OSPF or ISIS as the IGP.\n\nThis test is triggered by a need to verify the correct operation of an MPLS ping with fragmentation across various network topologies.",
                "Pass/Fail Criteria": "Isis neighborship verification is performed.\nOspf neighborship verification is performed.\nMpls control plane verification is performed.\nLimit the MTU verification is performed.\nNeighbourship Verification verification is performed.\nMPLS Ping verification is performed.\nRevert the MTU verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp traffic with fragmentation",
                "Procedure": "MPLS traffic is tested with fragmentation to ensure proper functionality across a network configuration consisting of MPLS LDP, OAM, OSPF as an IGP, and ISIS as another IGP. \n\nThis test is triggered by the need to verify that the MPLS Traffic works properly across topology.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nIsis neighborship verification is performed.\nOspf neighborship verification is performed.\nMpls control plane verification is performed.\nLimit the MTU verification is performed.\nNeighbourship Verification verification is performed.\nMPLS Traffic Verification verification is performed.\nRevert the MTU verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Continuous intf flap",
                "Procedure": "When testing the continuous interface flaps of MPLS LDP forwarding, we need to ensure that interface flapping on the mpls core network does not cause any adverse effects on the overall network. Additionally, this test case verifies a specific issue related to CSCwe93323, which involves checking for object-id leaks when using the \"show cef misc\" command and verifying the in-use value afterwards. This test is triggered by configuration that includes MPLS LDP, as well as an IGP such as OSPF or ISIS.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nStop and traffic verification is performed.\nTraffic rcc blk process verification is performed.\nVerify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp interface cfg flap",
                "Procedure": "To test MPLS LDP forwarding, attempt to create situations where interface configurations are constantly changing. Specifically, verify that when interfaces are being removed and added while the MPLS LDP session is active, no problems arise. This test is triggered by an instance of MPLS LDP coupled with an IGP such as OSPF or ISIS in place.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp ospf route flap",
                "Procedure": "To test MPLS LDP forwarding with OSPF route flapping, verify that the OSPF routes flapping influence mpls ldp labels as well. This test is triggered by configuration changes involving MPLS LDP and an Interior Gateway Protocol such as OSPF or ISIS.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp isis route flap",
                "Procedure": "To test MPLS LDP forwarding, simulate ISIS route flapping and verify whether it affects MPLS LDP labels.\n\nThis test is triggered by simulating the flapping of ISIS routes to check their influence on mpls ldp label allocation.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp label flap",
                "Procedure": "MPLS LDP forwarding is tested with frequent changes in labels to simulate a \"churn\" of labels. The goal is to verify that such label flapping does not have a detrimental effect on the system's performance. This test relies on a configuration involving Multiprotocol Label Switching (LDP) and an Interior Gateway Protocol, such as OSPF or ISIS. \n\nThis test is triggered by changes in LDP forwarding information.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp bundle member flap",
                "Procedure": "MPLS LDP forwarding is tested with bundle member flapping to verify MPLS LDP protocol behavior after a bundle member has flapped. The configuration for this test includes MPLS LDP and an Interior Gateway Protocol such as OSPF or ISIS.\n\nThis test is triggered by bundle member flapping in the configuration of MPLS LDP and IGP (OSPF Or ISIS).",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nTraffic rcc blk process verification is performed.\nInterface brief verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp bundle member add remove",
                "Procedure": "To test MPLS LDP forwarding with bundle member changes, verify that the MPLS LDP protocol behaves correctly after removing and adding bundle member links. This test is triggered by configuration involving MPLS LDP and an interior gateway protocol such as OSPF or ISIS.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nBundle port verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp bundle add remove",
                "Procedure": "MPLS LDP forwarding should be tested with bundle changes to ensure it works correctly when adding or removing a bundle interface from the configuration. The test also involves verifying how mpls ldp behaves in response to these changes. To conduct this test, MPLS LDP and IGP (OSPF or ISIS) must be configured.\n\nThis test is triggered by the addition or removal of a bundle interface from the MPLS LDP and IGP configuration.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp interfaces add remove",
                "Procedure": "To test MPLS LDP forwarding with interface changes, verify the behavior of mpls ldp after removing and adding physical interfaces and sub-interfaces. This test is triggered by configuration changes involving MPLS LDP and an Interior Gateway Protocol such as OSPF or ISIS.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp clear ops",
                "Procedure": "To test MPLS LDP forwarding with clear command operations, verify the behavior by first clearing OSPF or ISIS routes in the network. The configuration should include an IGP protocol such as OSPF or ISIS and MPLS LDP.\n\nThis test is triggered by the need to verify that mpls ldp behaves correctly when IGP (OSPF or ISIS) routes are cleared.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls add remove ipv4 address",
                "Procedure": "MPLS forwarding can be tested by removing and adding an IPv4 address to verify that it doesn't cause any issues with the MPLS LDP sessions, which should remain operational. This test is triggered by bug CDTS:CSCvu08933, where MPLS traffic may fail after deleting and re-adding an IPv4 address.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nOspf neighborship verification is performed.\nIsis neighborship verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls add remove ipv6 address",
                "Procedure": "MPLS forwarding can be tested by removing and adding an IPv6 address to MPLS LDP sessions while verifying that this operation does not cause any issues with the sessions' status.\n\nThis test is triggered by removal and addition of ipv6address to mplslpd sessions.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nOspf neighborship verification is performed.\nIsis neighborship verification is performed.\nTraffic rcc blk process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cef encap share disable",
                "Procedure": "To verify the fia_driver crash after adding or removing the \"cef encap-share disable\" configuration, it's necessary to test the case that covers LDP neighborship verification across a given topology, which includes both Label Edge Routers (LERs) and Label Switching Routers (LSRs). This involves verifying that MPLS LDP and Interior Gateway Protocol (IGP) - specifically OSPF and ISIS - are correctly configured.\n\nThis test is triggered by the addition or removal of the \"cef encap-share disable\" configuration.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nStop and traffic verification is performed.\nTraffic rcc blk process verification is performed.\nNeighborship Verification verification is performed.\nConfigure and unconfigure cef encap share disable verification is performed.\nthe MPLS control plane verification is performed.\nthe MPLS data plane verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp remove rollback ospf",
                "Procedure": "To test the removal and rollback of an OSPF configuration with MPLS LDP enabled on a core network. This test is triggered by verifying that LDP operates correctly after removing and then re-adding the OSPF process on the core network. The test environment includes the use of both OSPF and ISIS as IGP protocols in conjunction with MPLS LDP.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nMpls control plane verification is performed.\nStop and traffic verification is performed.\nTraffic rcc blk process verification is performed.\nIGP Verification verification is performed.\nRemove and add OSPF Config verification is performed.\nthe MPLS control plane verification is performed.\nthe MPLS data plane verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp remove rollback isis",
                "Procedure": "MPLS LDP functionality should be checked after removing and reinstalling ISIS configuration on the core network to ensure its operation remains unaffected.\n\nThis test is triggered by changes made to the ISIS configuration in a core network environment that uses OSPF or another routing protocol alongside MPLS LDP.",
                "Pass/Fail Criteria": "Isis neighborship verification is performed.\nMpls control plane verification is performed.\nStop and traffic verification is performed.\nTraffic rcc blk process verification is performed.\nIGP Verification verification is performed.\nRemove and add ISIS Config verification is performed.\nthe MPLS control plane verification is performed.\nthe MPLS data plane verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp sac add remove",
                "Procedure": "The test involves adding and removing the Test MPLS LDP Capability State Advertisement Control (SAC) feature on routers while verifying that the LDP session with a Traffic Generator (TGEN) remains stable. A known issue with SAC-TLV encoding is also addressed in this test. To perform this test, LDP SAC must be enabled on the routers and an IGP such as OSPF or ISIS configured. The test consists of two main parts: first, the addition of LDP SAC on the routers to see if it affects the LDP session with TGEN; second, the removal of LDP SAC from the routers and verification that the LDP session recovers.\n\nThis test is triggered by CSCwb16839 which involves a flipped SAC-TLV encoding.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nStop and traffic verification is performed.\nTraffic rcc blk process verification is performed.\nMpls ldp summary verification is performed.\nLDP control plane and data plane verification verification is performed.\nLDP capabilities SAC configuration verification is performed.\nMPLS LDP Neighborship Verification verification is performed.\nUnconfigure LDP capabilities SAC verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp add remove",
                "Procedure": "MPLS LDP can be removed and added back to ensure functionality. To test this, remove the LDP configuration on the routers and verify that traffic flows normally using IGP protocols such as OSPF or ISIS. Add the LDP configuration back and confirm that traffic continues to flow with the use of LDP labels.\n\nThis test is triggered by verifying MPLS LDP and IGP (OSPF and ISIS) configurations.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nStop and traffic verification is performed.\nTraffic rcc blk process verification is performed.\nMPLS LDP Neighborship Verification verification is performed.\nLDP global config removal verification is performed.\nTraffic verification verification is performed.\nAdd MPLS LDP config verification is performed.\nLDP control plane and data plane verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp linux exposed interface",
                "Procedure": "The Linux operating system can be used to manage data ports on Lindt platforms, with support included in Cisco's SSH 732 release. By default, all data ports are managed by the XR system, allowing for configuration of IP addresses, port states, and MTU values. However, these tasks can also be performed from Linux instead, requiring a change to the ownership of the data ports through additional configuration. This setup is intended to cover verification across different network topologies, including LERs (Label Edge Routers) and LSRs (Label Switching Routers), which use MPLS LDP and IGP protocols such as OSPF and ISIS.\n\nThis test is triggered by verifying LDP neighborship across a topology involving Label Edge Routers and Label Switching Routers.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nStop and traffic verification is performed.\nTraffic rcc blk process verification is performed.\nNeighborship Verification verification is performed.\nConfiguring Linux exposed interface verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ttl propogate disable forward with rollback",
                "Procedure": "The test case is designed to verify the impact of removing or adding a specific configuration option related to MPLS TTL propagation with forwarding. It involves the removal of the \"mpls ip-ttl-propagate\" configuration along with other MPLS LDP configurations, checking for correct rollback behavior, and verifying basic MPLS LDP functionality under normal traffic conditions.\n\nThis test is triggered by removing 'mpls ip-ttl-propagate' configuration option related to MPLS TTL propagation with forwarding.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic verification is performed.\nMpls ldp neighbor verification is performed.\nLDP Neighborship Verification verification is performed.\nLSD Binding Verification verification is performed.\nConfig removal verification is performed.\nBinding removal verification verification is performed.\nRollback and check the binding and neighborship verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ttl propogate disable local with rollback",
                "Procedure": "The removal of the \"mpls ip-ttl-propagate\" feature with local configuration, along with other related MPLS LDP settings, is tested in this scenario. The test case also includes checking for correct rollback functionality after removing these configurations. Basic MPLS LDP functionality, as well as its impact on network traffic, are verified during the test. This test is triggered by the reference defect CSCvs68691, which reports an issue related to hardware programming errors when removing the \"mpls ip-ttl-propagate\" feature. The configuration used in this test includes MPLS LDP and IGP settings (OSPF and ISIS).",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic verification is performed.\nMpls ldp neighbor verification is performed.\nNeighborship Verification verification is performed.\nBinding Verification verification is performed.\nConfig removal verification is performed.\nBinding removal verification verification is performed.\nRollback and check the binding and neighborship verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mplsttlpropagation enable and disable",
                "Procedure": "MPLS labelled traffic is verified with the MPLS Label TTL set to 100. This test case covers the verification of MPLS labelled traffic by copying the \"expNull\" MPLS TTL into the IP TTL on label disposition when TTL propagation is disabled, as referenced in bug reports #41073 and CSCwh47415. The configuration used for this test includes MPLS LDP and IGP (OSPF and ISIS) protocols.\n\nTrigger sentence: \nThis test is triggered by the verification of MPLS labelled traffic with an \"expNull\" MPLS TTL copied into IP TTL on label disposition when TTL propagation is disabled, as referenced in bug reports #41073 and CSCwh47415.",
                "Pass/Fail Criteria": "Stop and traffic verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ttl zero and one",
                "Procedure": "MPLS labelled traffic with an MPLS Label TTL set to either 0 or 1 should be dropped by the Device Under Test. The test case verifies that such traffic drops as expected. In this scenario, the device is configured for MPLS LDP and one of IGP (OSPF or ISIS). This test is triggered by a packet with an MPLS Label TTL set to either 0 or 1 being sent through the DUT.",
                "Pass/Fail Criteria": "Stop and traffic verification is performed.\nDataplane traffic drop verification verification is performed.\nNPU traps verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mplsttlpropogation ip to mpls",
                "Procedure": "Traffic flows from an IP network through a series of routers, starting with R1, which forwards packets to R2 via OSPF. At R2, MPLS LDP is used to add a single value label, which is then forwarded to R3, where another MPLS LDP session adds additional labels before the traffic exits to a transit network gateway (TGN). To verify the functionality of this setup, configure MPLS IP-TTL propagation to be disabled and not configured, while also enabling MPLS LDP and IGP protocols such as OSPF and ISIS. This test is triggered by sending IP packets from R1 through R2 and R3, with single value labels being added at each hop along the way.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS IP-TTL Propagation configured and non-configured verification is performed.\nFor MPLS IP-TTL Propagation Enable and Disable TTL and TOS values verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mplsttlpropogation mpls to ip imp null",
                "Procedure": "The testcase verifies the behavior of implicit-null MPLS TTL/EXP copying into IP header TTL/DSCP during label disposition with TTL propagation enabled or disabled. The traffic flow involves MPLS-to-IP traffic passing through an ISIS network and a T-LDP link. Specifically, it follows this path: ISIS -> R1 -> LDP -> R2 -> T-LDP -> TGN. This test is triggered by verifying the behavior of implicit-null MPLS TTL/EXP copy behaviour into IP header TTL/DSCP on label disposition with TTL propagation enabled/disabled when using MPLS LDP and IGP protocols (OSPF and ISIS) in a network configuration.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS TTL Propogation configured and non-configured verification is performed.\nFor MPLS Enable - TTL and DSCP should copy to IP packet. verification is performed.\nFor MPLS Disable - TTL Disable TTL and TOS values should not copy verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mplsttlpropogation mpls to ip with dual mpls labels",
                "Procedure": "Traffic flows from R3 to R1 through the network, passing through routers R2 and R4. The path is: ISIS on R3, MPLS T-LDP to R2, MPLS LDP to R1, and then OSPF.\n\nThis test is triggered by traffic flowing from a router with ISIS enabled, over an MPLS network with both MPLS LDP and IGP (OSPF and ISIS) configured.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS TTL Propogation configured and non-configured verification is performed.\nFor MPLS Enable - TTL and TOS values should copy verification is performed.\nFor MPLS Disable - TTL and TOS values should not copy verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mplsttlpropogation mpls to ip diff exp",
                "Procedure": "The verification of MPLS IP TTL behavior is conducted through various experiments with different values. The test case focuses on the implicit-null behavior of MPLS TTL/EXP copying into the IP header's TTL/DSCP when labels are dispositioned, both with and without TTL propagation enabled. This test is triggered by an MPLS to IP traffic flow that involves IGP (ISIS) and TGN (MPLS T-LDP) protocols between R1 and R2 routers. The configuration for this test includes MPLS LDP and IGP routing protocols such as OSPF and ISIS.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS TTL Propogation configured and non-configured verification is performed.\nConfigure the EXP value to range from 0 to 6 and verify that the corresponding IP DSCP value verification is performed.\nFor MPLS Enable - TTL and DSCP should copy to IP packet. verification is performed.\nFor MPLS Disable - TTL Disable TTL and TOS values should not copy verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hw fib mplsttlpropogation ip to mpls mpls push",
                "Procedure": "The traffic flow is as follows: an OSPF or ISIS routing protocol packet travels from the Topology Gateway to router R1, then through a series of MPLS LDP-enabled routers until it reaches R2. From there, another set of MPLS LDP-enabled routers carries the packet to R3 before reaching the destination Topology Gateway. In addition, IP TTL propagation has been configured as disabled, but when enabled, only the not-configured state is allowed.\n\nThis test is triggered by configuring and enabling or disabling MPLS IP-TTL propagation with hardware FIB push on TTL.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS IP-TTL Propagation configured and non-configured verification is performed.\nConfigure hw-module fib mpls ip-ttl-propagate-disable exclude mpls-push ttl verification is performed.\nip ttl will copy to mpls ttl and ip dscp will copy to exp verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hw fib mplsttlpropogation mpls to ip imp null mpls php",
                "Procedure": "The test case verifies the behavior of MPLS IP traffic with implicit-null configuration using hardware forwarding and penultimate hop popping. The verification covers how the MPLS TTL and EXP values are copied into the IP header TTL and DSCP on label disposition, with both TTL propagation enabled and disabled. This involves an MPLS to IP traffic flow, where R1 uses ISIS as IGP and T-LDP for MPLS, then sends traffic to R2 using LDP, which is also connected through T-GN; R2 forwards the traffic back to T-GN. The configuration includes MPLS LDP and both OSPF and ISIS as IGP protocols.\n\nThis test is triggered by an explicit configuration of MPLS LDP with hardware forwarding enabled and penultimate hop popping configured.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS TTL Propogation configured and non-configured verification is performed.\nConfigure hw-module fib mpls ip-ttl-propagate-disable exclude mpls-pop-penultimate-hop ttl-and-cos verification is performed.\nmpls ttl will copy to ip ttl and mpls exp bits to ip dscp & ip ecn will copy verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hw fib mplsttlpropogation mpls to ip with dual mpls labels mpls php",
                "Procedure": "Traffic flows from R1 to R3 via MPLS LDP through R2, with the following sequence of protocols: OSPF as the IGP on the T-GN segment, MPLS T-LDP between R1 and R3, MPLS LDP between R2 and R3. The configuration used for this test includes MPLS LDP and two IGPs: OSPF and ISIS. This test is triggered by a verification of MPLS IP TTL IP to MPLS flow with dual labels using hardware forwarding information base (FIB) lookup.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS TTL Propogation configured and non-configured verification is performed.\nConfigure hw-module fib mpls ip-ttl-propagate-disable exclude mpls-pop-penultimate-hop ttl-and-cos verification is performed.\nmpls ttl will copy to ip ttl and mpls exp bits to ip dscp & ip ecn will copy verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hw fib mplsttlpropogation mpls to ip diff exp mpls php",
                "Procedure": "The verification of MPLS labelled traffic involves checking the behavior of \"Implicit-null MPLS TTL/EXP copy behaviour into IP header TTL/DSCP on label disposition with TTL propagation enabled/disabled\" in a network flow. This test is triggered by an MPLS to IP traffic flow, specifically an ISIS IGP and T-LDP routed path from R1 through R2 to the TGN, utilizing both LDP and T-LDP for MPLS control.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS TTL Propogation configured and non-configured verification is performed.\nConfigure hw-module fib mpls ip-ttl-propagate-disable exclude mpls-pop-penultimate-hop ttl-and-cos verification is performed.\nConfigure the EXP value to range from 0 to 6 and verify that the corresponding IP DSCP value verification is performed.\nmpls ttl will copy to ip ttl and mpls exp bits to ip dscp & ip ecn will copy verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hw fib mplsttlpropogation mpls to ip imp null mpls php ttl",
                "Procedure": "The test case verifies the behavior of MPLS labelled traffic with implicit-null by checking if the MPLS TTL/EXP is correctly copied into the IP header TTL/DSCP when propagation is enabled or disabled. The test covers a specific traffic flow: a packet travels from R1, which has an IGP (ISIS) and T-LDP configuration, to R2 via an LDP connection, and then back out through the same LDP connection with MPLS TTL propagation enabled/disabled.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS TTL Propogation configured and non-configured verification is performed.\nConfigure hw-module fib mpls ip-ttl-propagate-disable exclude mpls-pop-penultimate-hop ttl verification is performed.\nmpls ttl will copy to ip ttl and mpls exp bits to ip dscp will copy and verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hw fib mplsttlpropogation mpls to ip imp null mpls php cos",
                "Procedure": "The test verifies that MPLS IP traffic with implicit-null behaves correctly by copying the TTL/EXP from the MPLS label into the IP header's TTL/DSCP when propagating labels. The test case covers the verification of MPLS labelled traffic with TTL propagation enabled and disabled. The traffic flow is from an IP network to a network using MPLS, where LDP is used for label distribution between R1 and R2, which are connected by T-LDP and TGN. This test is triggered by configuring MPLS LDP and IGP protocols (OSPF and ISIS) on the routers involved in the traffic flow.",
                "Pass/Fail Criteria": "IP TTL/DSCP/ECN behaviour with MPLS TTL Propogation configured and non-configured verification is performed.\nConfigure hw-module fib mpls ip-ttl-propagate-disable exclude mpls-pop-penultimate-hop cos verification is performed.\nmpls ttl will copy to ip ttl and mpls exp bits to ip dscp will copy and verification is performed.\nDataplane traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp label 1d scale",
                "Procedure": "The verification of the MPLS LDP control plane and traffic involves ensuring that all aspects of the system are functioning correctly. The configuration being tested includes a setup with one dimension (1D) for MPLS LDP label scaling.\n\nThis test is triggered by configuring 1D MPLS LDP Label scale.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic verification is performed.\nTraffic rcc blk process verification is performed.\nLDP Neighborship and Binding Verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp reload",
                "Procedure": "Before running the Test Reload cases for lc_reload/fc_reload/rpfo/reloadall, verify that the following functionalities are working properly both before and after HA trigger: ISIS and OSPF neighboring relationships are intact, MPLS interfaces and control plane are up, IPv4 and IPv6 pings succeed, MPLS IPv4 and IPv6 pings are successful, LFA OSPF and LFA ISIS functionality is working as expected, and MPLS MTU functionality is functioning correctly. This test is triggered by configuration changes involving MPLS, ISIS, and OSPF.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.trigger_list\"",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls interfaces verification is performed.\nMpls control plane verification is performed.\nTraffic verification is performed.\nStop and traffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "System master sc reload",
                "Procedure": "To verify the Master SC's fail-over or reload functionality, ensure that various network features are operational before and after the process. These include stable ISIS and OSPF neighborhood relationships, up MPLS interfaces and control plane operations, successful IPv4 and IPv6 pings, functional LFA OSPF and LFA ISIS functionalities, and correct MPLS MTU functionality.\n\nThis test is triggered by a reload of the Master SC, which requires configurations for MPLS, ISIS, and OSPF to be in place.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls interfaces verification is performed.\nMpls control plane verification is performed.\nStop and traffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTraffic verification is performed.\nPlatform vm final band verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "System slave sc reload",
                "Procedure": "The test slave SC is intended for fail-over or reload scenarios. To ensure proper operation, verify that the following functionalities are working correctly both before and after the Slave SC reload: ISIS and OSPF neighbour relationships remain intact, MPLS interfaces and control plane functionality are maintained, IPv4 and IPv6 ping operations succeed, MPLS IPv4 and MPLS IPv6 ping tests pass, LFA OSPF and LFA ISIS functionality operates as expected, and MPLS MTU functionality is preserved. This test is triggered by Configuration: MPLS, ISIS, and OSPF.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls interfaces verification is performed.\nMpls control plane verification is performed.\nTraffic verification is performed.\nPlatform vm final band verification is performed.\nStop and traffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "System process restart",
                "Procedure": "When restarting the test process, verify that several functionalities are working correctly before and after the restart. These include ensuring that neighbor relationships with ISIS and OSPF are intact, that MPLS interfaces and the control plane are operational, and that IPv4 and IPv6 ping operations succeed. Additionally, confirm that MPLS IPv4 and IPv6 ping, LFA OSPF and LFA ISIS functionality, and MPLS MTU functionality all work as expected.\n\nThis test is triggered by configuration changes involving MPLS, ISIS, and OSPF.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ldp_pd_ap.get_proc_list(trigger='restart', ApData=ApData)\"",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls interfaces verification is performed.\nMpls control plane verification is performed.\nTraffic verification is performed.\nStop and traffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "System process crash",
                "Procedure": "The test process crash cases require verification of specific functionalities before and after the process crashes. Verification includes checking that ISIS and OSPF neighborhood is stable, MPLS interfaces and control plane are operational, IPv4 and IPv6 ping tests work correctly, MPLS IPv4 and IPv6 ping tests also pass, LFA OSPF and LFA ISIS functionality operates as expected, and MPLS MTU functionality is intact. The system under test has an MPLS, ISIS, and OSPF configuration.\n\nThis test is triggered by a simulated process crash on the system.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ldp_pd_ap.get_proc_list(trigger='crash', ApData=ApData)\"",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls interfaces verification is performed.\nMpls control plane verification is performed.\nTraffic verification is performed.\nStop and traffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp pec shut noshut",
                "Procedure": "The Port Expander Card's shutdown state is being checked and verified for its correct system behavior, especially in configurations that utilize Multiprotocol Label Switching (MPLS) Label Distribution Protocol (LDP), as well as Interior Gateway Protocols such as Open Shortest Path First (OSPF) or Intermediate System to Intermediate System (ISIS). \nThis test is triggered by the shutdown or no-shutdown state of the Port Expander Card.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nTraffic verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp pec oir",
                "Procedure": "The PEC (Port Expander Card) OIR/Reload verification involves checking the system's behavior in this specific configuration. The test is used to verify how the system behaves with a Port Expander Card that has been inserted or removed while MPLS LDP and IGP protocols such as OSPF or ISIS are enabled.\n\nThis test is triggered by a PEC insertion or removal event occurring while MPLS LDP and an IGP protocol (such as OSPF or ISIS) are configured.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nTraffic verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "mpls_pi_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Mpls ldp neighborship down by timer",
                "Procedure": "When the dead timer expires, we need to verify that the Neighbor goes down. This test covers the dead timer expiry scenario where a Hello packet is unreachable.\n\nThis test is triggered by the expiration of the dead timer in an LDP/MPLS environment with OSPF or ISIS IGP running.",
                "Pass/Fail Criteria": "Mpls ldp neighbor verification is performed.\nTraffic verification is performed.\nMPLS LDP Neighborship Verification verification is performed.\nMPLS LDP Binding Verification verification is performed.\nMPLS LDP traffic verification verification is performed.\nBringdown interface and checks for LDP timer expiry verification is performed.\nMPLS LDP LSD Binding removal verification verification is performed.\nBringup interface and check the binding verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp neighborship down by clear cli",
                "Procedure": "When verifying that a neighboring router is cleared, check if the LDP Neighbor has been successfully cleared. This test is triggered by the verification of clear neighbor commands on both LERs and LSR devices, and it checks the neighborship status in an MPLS LDP environment with IGP routing protocols such as OSPF or ISIS configured.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nMPLS LDP Neighborship Verification verification is performed.\nMPLS LDP Binding Verification verification is performed.\nClear MPLS LDP neighbor using CLI and check the bind verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Unconfig mpls ldp with rollback",
                "Procedure": "MPLS LDP is unconfigurable on core network. The test case covers all MPLS LDP configurations in a core topology setup, including physical interfaces, physical sub-interfaces, bundle interfaces, and bundle sub-interfaces between Label Edge Routers (LERs) and Label Switching Routers (LSRs). It removes and rolls back the MPLS LDP configuration to verify that the functionality returns to normal. This test is triggered by the presence of an IGP such as OSPF or ISIS along with MPLS LDP on a core network.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nMpls ldp neighbor verification is performed.\nTraffic verification is performed.\nMPLS LDP Neighborship Verification verification is performed.\nLDP and LSD Binding Verification verification is performed.\nMPLS LDP Config removal verification is performed.\nLSD Binding removal verification verification is performed.\nRollback and check the bind and neighborship verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp label allocations default route",
                "Procedure": "To verify that LDP label allocations and labels for the default route are correct, this test case checks both the MPLS LDP label allocation ranges and the default route label allocations. This test is triggered by the configuration of MPLS LDP with an Interior Gateway Protocol (IGP), specifically OSPF or ISIS.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nMPLS LDP Neighborship Verification verification is performed.\nMPLS LDP LSD Binding Verification for default route verification is performed.\nMPLS LDP Label range verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp capabilities",
                "Procedure": "To test the Multiprotocol Label Switching (MPLS) Label Distribution Protocol (LDP) capabilities, this case involves verifying the details of how MPLS LDP functions in conjunction with an Interior Gateway Protocol (IGP), specifically OSPF and ISIS.\n\nThis test is triggered by a configuration that includes MPLS LDP and IGP protocols such as OSPF and ISIS.",
                "Pass/Fail Criteria": "Mpls ldp capabilities verification is performed.\nMPLS LDP Capabilities verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp discovery",
                "Procedure": "MPLS LDP Discovery is being tested to ensure it functions correctly across various topologies. The test verifies that the MPLS LDP Discovery process operates as intended. This test is triggered by the configuration of both MPLS LDP and interior gateway protocols (IGPs), including OSPF and ISIS.",
                "Pass/Fail Criteria": "Mpls ldp discovery detail verification is performed.\nMPLS LDP Neighborship Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp discovery acl drop",
                "Procedure": "MPLS LDP Discovery packets are being dropped by an access list. This test verifies whether the access list's drop rule is correctly configured to block the MPLS LDP discovery process. To test this functionality, we have a setup that includes configuration for both MPLS LDP and IGP protocols (OSPF and ISIS), as well as an access list (ACL).",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic verification is performed.\nNo MPLS LDP Neighborship on configuring ACL verification is performed.\nRemoval of ACL and check binding and neighborship verification is performed.\nEnd to end traffic validation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp timers",
                "Procedure": "MPLS LDP default, targeted timers, non-default hold and hello timers need to be tested. The LDP timers for MPLS LDP discovery neighbors should also be verified. Configuration includes MPLS LDP with static IGP using OSPF and ISIS.\n\nThis test is triggered by the need to verify MPLS LDP configuration involving static IGP routing protocols such as OSPF and ISIS.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntls: \"ApData.zap.get_testcase_configuration('tls_list_ldp_timers')\"",
                "Pass/Fail Criteria": "Mpls ldp parameters verification is performed.\nTraffic verification is performed.\nLDP timers verification verification is performed.\nEnd to end traffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp igp sync",
                "Procedure": "The network is configured to synchronize the MPLS LDP and IGP (OSPF or ISIS) protocols. To test this synchronization, verify that the basic functionality of MPLS LDP IGP sync is operating correctly.\n\nThis test is triggered by the configuration of MPLS LDP with an IGP protocol such as OSPF or ISIS.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic verification is performed.\nNeighborship Verification verification is performed.\nSync verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp autoconfig address flap",
                "Procedure": "MPLS LDP Autoconfig can be tested by making a change to an interface's address and verifying that the MPLS LDP autoconfig functionality still operates correctly.\n\nThis test is triggered by changing an interface's address.",
                "Pass/Fail Criteria": "Binding verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nFlap ip address verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp autoconfig with ldp sync",
                "Procedure": "To test MPLS LDP autoconfiguration alongside IGP synchronization, verify that the MPLS LDP autonfiguration is functioning correctly in conjunction with LDP synchronization. The configuration for this test includes enabling MPLS LDP and an interior gateway protocol, such as OSPF or ISIS.\n\nThis test is triggered by a configuration of MPLS LDP and an Interior Gateway Protocol (IGP) like OSPF or ISIS.",
                "Pass/Fail Criteria": "Binding verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp autoconfig clear neighbor",
                "Procedure": "To test the MPLS LDP autoconfiguration feature, you should first configure it using the clear mpls neighbor command, and then verify that the autoconfiguration function is working as expected by clearing the neighboring relationship between the routers. The testing process assumes a configuration involving both MPLS LDP and an Interior Gateway Protocol (IGP) such as OSPF or ISIS.\n\nThis test is triggered by configuring MPLS LDP with OSPF or ISIS as the IGP.",
                "Pass/Fail Criteria": "Binding verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nClear neighbor with command verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp autoconfig end to end traffic",
                "Procedure": "To verify end-to-end traffic functionality for MPLS LDP sessions with autoconfig, the configuration includes OSPF and ISIS as interior gateway protocols along with MPLS LDP enabled.\n\nThis test is triggered by enabling MPLS LDP in conjunction with OSPF or ISIS as interior gateway protocols.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nTraffic verification is performed.\nNeighborship Verification verification is performed.\nBinding Verification verification is performed.\nCEF forwarding verification verification is performed.\nTraffic check at TGN verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp session protection",
                "Procedure": "MPLS LDP session protection configuration, unconfiguration, or reconfiguration is verified in this test. The test checks if the LDP session protection works as expected with different state values by enabling session protection on one of the routers, verifying neighbor details and SP values for other routers, disabling session protection, reenabling it, and finally disabling it again to restore the original configuration. This test is triggered by a verification process that MPLS LDP OSPF ISIS configuration settings are in place.",
                "Pass/Fail Criteria": "Mpls ldp neighbor detail verification is performed.\nSP value on peers after enabling SP on one of the main router verification is performed.\nSP value on peers after enabling SP on the two peer router verification is performed.\nSP value on peers after disabling SP on one of the main router verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp session protection enabling prior",
                "Procedure": "The test verifies the functionality of MPLS LDP Session Protection (SP) by enabling it before establishing a connection between two peers, then disabling it afterwards. To do this, the interface between routers pe1 and p is shut down, and the neighbor details of router pe1 are checked to ensure that p's address isn't listed; session protection is then enabled on all three routers pe1, p, and pe2, after which the neighbor details of pe1 are verified again. With SP still enabled, the interface between routers pe1 and p is restored to its operational state, and the neighbor details of both peers (pe1, p, and pe2) are checked for the presence of session protection values. Finally, session protection is disabled on all three routers to return their configuration to its original state.\n\nThis test is triggered by a specific scenario in which MPLS LDP Session Protection must be enabled prior to peer establishment.",
                "Pass/Fail Criteria": "Mpls ldp neighbor detail verification is performed.\nneighborship is not established when the interface between two routers is shut verification is performed.\nSP value isn't listed for the routers whose neighborship isn't established verification is performed.\nneighborship is established on doing no-shut of the interface between two routers verification is performed.\nSP value on peers is listed properly for the routers whose neighborship is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp session protection targeted hello",
                "Procedure": "To verify the operation of MPLS LDP Session Protection (SP), enable it on routers pe1 and pe2, then check their neighbor details for SP values. Enable target-hello on router p to add a new session, recheck the neighbor details, and then disable target-hello to restore the original configuration. Finally, disable session protection on both routers to return them to their original state.\n\nThis test is triggered by enabling session protection on two specific routers, pe1 and pe2, in an MPLS LDP environment with a target-hello feature active on one of the routers.",
                "Pass/Fail Criteria": "Mpls ldp neighbor detail verification is performed.\nSP value on peers after enabling SP on two of the routers verification is performed.\nSP value on the peers after enabling target-hello on another router to add new session verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp session protection peer acl enabled",
                "Procedure": "MPLS LDP SP is enabled with peer acl if you follow these steps. On routers pe1, p, and pe2, enable session protection on all three devices. Next, fetch the neighbor details of pe1 and check for SP values. Then, configure a peer access control list on pe1 for router p, followed by configuring mpls ldp session protection for peer acl. After these steps are complete, verify that the SP values have been updated in the neighbor details of router pe1.\n\nThis test is triggered by enabling MPLS LDP session protection with a specific peer ACL configuration.",
                "Pass/Fail Criteria": "Mpls ldp neighbor detail verification is performed.\nSP value on main router after enabling SP on all the three routers verification is performed.\nSP value on the main router after configuring acl along with SP for acl on the main router verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp session protection peer acl disable reconfig",
                "Procedure": "The test verifies if the Multiprotocol Label Switching (MPLS) Label Distribution Protocol (LDP) Session Protection (SP) is enabled with a peer Access Control List (ACL). It does this by first disabling SP for the ACL, then re-enabling it. The neighbor details of router pe1 are fetched and verified for SP values during both the unconfiguration and re-configuration processes.\n\nThis test is triggered by configuration: MPLS LDP session protection being enabled with a peer ACL.",
                "Pass/Fail Criteria": "Mpls ldp neighbor detail verification is performed.\nSP value on the main router after unconfiguring MPLS LDP SP for peer acl on main router verification is performed.\nSP value on the main router after configuring MPLS LDP SP for peer acl on main router verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp session protection change peer acl adding new peer",
                "Procedure": "MPLS LDP sessions are protected when a new peer is added to the peer ACL. To test this, the neighbor details of router pe1 are fetched and the session protection (SP) values are verified. The configuration includes enabling MPLS LDP for address family ipv6, adding a new peer (router pe2) and 99 dummy rules to the peer ACL, and configuring MPLS LDP session protection for that peer ACL. The neighbor details of router pe1 are then fetched again and the SP values are re-verified.\n\nThis test is triggered by changes to the peer ACL when a new peer is added.",
                "Pass/Fail Criteria": "Mpls ldp neighbor detail verification is performed.\nSP value on the main router initially before configuring new peer in peer acl verification is performed.\nSP value on the main router after configuring MPLS LDP SP for peer acl on main router verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp session protection change peer acl deleting peer",
                "Procedure": "The test verifies if the MPLS LDP session protection changes when a peer is deleted from the peer ACL. This test is triggered by deleting a peer in the ACL and verifying that the session protection values are updated accordingly, as well as checking that all other peers remain unaffected. The neighbor details of router pe1 are fetched before and after making these changes to ensure that the SP values have been correctly updated. To simulate this scenario, the peer ACL is configured to delete a peer (pe2) and 99 dummy rules are added, while also fetching the neighbor details of router pe1 to verify the session protection values during both steps.",
                "Pass/Fail Criteria": "Mpls ldp neighbor detail verification is performed.\nSP value on the main router initially before deleting peer in peer acl verification is performed.\nSP value on the main router after deleting peer in peer acl on main router verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp session protection with omitted peer acl",
                "Procedure": "The test verifies if the MPLS LDP session protection changes when a peer ACL is omitted from configuration. It involves fetching neighbor details of router pe1 and verifying SP values after several steps: unconfiguring a peer ACL for IPv6 address family, reconfiguring it to permit communication with peer router p, and then restoring the original configuration by disabling session protection on routers pe1, p, and pe2, and unconfiguring MPLS LDP.\n\nThis test is triggered by an MPLS LDP SP (session protection) scenario involving omitted peer ACLs.",
                "Pass/Fail Criteria": "Mpls ldp neighbor detail verification is performed.\nSP value on the main router initially before unconfiguring the peer acl verification is performed.\nSP value on the main router after unconfiguring the peer acl on main router verification is performed.\nSP value on the main router after reconfiguring the peer acl on main router verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Snmp trap mpls ldp up",
                "Procedure": "The test SNMP trap MPLS LDP up is triggered by generating a trap for the MPLS LDP up event and verifying that the trap was obtained successfully. To perform this test, get the SNMP trap output for the MPLS LDP up and verify that the management IP address, community string, and SNMP Trap OID are correct on the server. This requires configuration on both the router and the server: the input file must contain a U1 server connection, while on the router, you need to set the SNMP server host and UDP port, and configure the required traps for the MPLS LDP up event; on the server, you should set up the SNMP server path, trap port, and trap file.",
                "Pass/Fail Criteria": "the snmp_trap received after the mpls ldp up. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Snmp trap mpls ldp down",
                "Procedure": "To test the SNMP trap for an MPLS LDP down event, generate the trap and verify that it is sent correctly. The output of the trap should include the management IP address, community string, and a specific OID. To configure this test, ensure that you have set up a server connection in the input file with the required U1 credentials. On the router, configure the SNMP server host and UDP port to receive the traps for the MPLS LDP down event. Finally, on the server, set up the SNMP server path, trap port, and trap file to store the received traps. This test is triggered by receiving an SNMP trap with the OID 'mplsLdpDown' sent from the router's configured SNMP host address.",
                "Pass/Fail Criteria": "the snmp_trap received after the mpls ldp down. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp in label filter",
                "Procedure": "MPLS LDP uses an inbound label filtering test to verify that an Access Control List (ACL) rule with a deny action filters the incoming label. The configuration for this test involves enabling MPLS LDP and Interior Gateway Protocols (IGPs) such as OSPF and ISIS, while also setting up an access-list (ACL). This test is triggered by the presence of an ACL rule with a deny action in the inbound label filter configuration.",
                "Pass/Fail Criteria": "Mpls forwarding exact route verification is performed.\nTraffic verification is performed.\nMpls control plane verification is performed.\nout-lable is filtered/Unlabelled for a prefix after binding the ACL to LDP neighbor verification is performed.\nRemoval of ACL and check out-label for a prefix verification is performed.\nEnd to end traffic validation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp peer authentication md5",
                "Procedure": "To test MPLS LDP peer authentication with an encrypted password, you should also verify that LDP peer authentication is working properly using MD5. This test is triggered by configuring the necessary settings for MPLS LDP and a routing protocol such as OSPF or ISIS to be used as IGP.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp peer authentication flap",
                "Procedure": "When testing MPLS LDP peer authentication, it's essential to verify that a change in password triggers the correct response. One way to do this is by intentionally changing the configuration, causing the peer to flapping between valid and invalid states, thus testing the authentication mechanism.\n\nThis test is triggered when there is a change of password on the MPLS LDP peer.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp peer authentication negative",
                "Procedure": "MPLS LDP peer authentication can be tested by entering a wrong password in order to verify that the LDP Peer authentication function works correctly even when there's a password mismatch. This test is triggered by attempting to establish an LDP connection using incorrect credentials while MPLS LDP and IGP routing protocols, such as OSPF or ISIS, are configured.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nNeighborship Verification verification is performed.\nChange to wrong password and check the neighborship verification is performed.\nChange to correct password and check the neighborship verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp peer authentication clear password",
                "Procedure": "To test MPLS LDP Peer authentication with a clear text password, verify that the LDP peer authentication functions properly when using a clear text password.\n\nThis test is triggered by the configuration of MPLS LDP in conjunction with an Interior Gateway Protocol (IGP), such as OSPF or ISIS.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls ldp remove authentication and verify",
                "Procedure": "MPLS LDP neighbors must be tested after removing authentication to ensure that they come up successfully. The verification process involves verifying that the LDP neighborship is established and functioning properly. This test is triggered by modifying the configuration of an MPLS LDP network with an IGP such as OSPF or ISIS.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMpls control plane verification is performed.\nNeighborship Verification verification is performed.\nBinding verification verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Commit replace mpls static with rollback",
                "Procedure": "MPLS Static should be able to commit a replacement configuration while rolling back to its original state in case of failure. This test is triggered by committing a new static unconfiguration on the network followed by rollbacks of the same setup, which involves configurations for MPLS Static, LDP (Label Distribution Protocol), and IGP (Interior Gateway Protocol) routing protocols including OSPF and ISIS.",
                "Pass/Fail Criteria": "Mpls static verification is performed.\nTraffic verification is performed.\nMPLS Binding Verification verification is performed.\nCommit replace verification is performed.\nMPLS Binding check verification is performed.\nRollback verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Unconfig mpls static with rollback",
                "Procedure": "MPLS Static configuration should not be possible to configure when in rollback mode. The test case checks that attempting to configure or unconfigure MPLS Static while in this state results in an error. This test is triggered by setting the system into rollback mode with both OSPF and ISIS as Interior Gateway Protocols (IGPs).",
                "Pass/Fail Criteria": "Mpls static verification is performed.\nTraffic verification is performed.\nBinding Verification verification is performed.\nConfig removal verification is performed.\nBinding check verification is performed.\nRollback verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Remove add lsp",
                "Procedure": "Traffic should be verified after removing and adding back a label switched path (LSP) in the network configuration, which includes MPLS Static routing and Interior Gateway Protocols such as OSPF and ISIS. This test is triggered by changes made to an LSP path within the network configuration that utilizes MPLS Static routing and IGP protocols like OSPF and ISIS.",
                "Pass/Fail Criteria": "Mpls static verification is performed.\nTraffic verification is performed.\nBinding Verification verification is performed.\nMpls label removal verification is performed.\nLabel add back verification is performed.\nTraffic check at TGN verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Remove add interface",
                "Procedure": "Verifying traffic flow on an MPLS static network involves several steps. First, the interface needs to be removed and then added back in to ensure that the configuration is stable. Once this is complete, it's essential to verify that end-to-end traffic can successfully traverse the network using MPLS static routing. This test is triggered by changes to the configuration involving MPLS Static, IGP (OSPF and ISIS).",
                "Pass/Fail Criteria": "Mpls static verification is performed.\nTraffic verification is performed.\nBinding Verification verification is performed.\nMpls interface removal verification is performed.\nLabel add back verification is performed.\nTraffic check at TGN verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Config resolve options default route",
                "Procedure": "The configuration for this test case involves resolving the testcase config option and setting the default route. To verify that end-to-end traffic is successful with MPLS static, the default static route should be configured, and the ECMP core links removed to update the RIB.\n\nThis test is triggered by configuring an IGP (OSPF and ISIS) along with MPLS Static.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMpls static verification is performed.\nBinding Verification verification is performed.\nConfig static route verification is performed.\nUnconfigure the ECMP core links verification is performed.\nTraffic check at TGN verification is performed.\nUnconfigure static route and configure the ECMP core links verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls static remove add vrf",
                "Procedure": "MPLS static forwarding can be tested after removing and adding a Virtual Routing Forwarding instance. This involves verifying that MPLS static forwarding functions correctly after VRF is removed and added back again in an environment configured with MPLS static routing and Interior Gateway Protocols such as OSPF or ISIS.\n\nThis test is triggered by the removal and addition of a VRF instance in a configuration that includes MPLS static routing and IGP protocols like OSPF or ISIS.",
                "Pass/Fail Criteria": "Mpls static verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls static bvi remove add bvi intf",
                "Procedure": "To test MPLS Static forwarding, remove and then re-add the BVI interface to verify that end-to-end traffic is successful using this method. This test is triggered by an action which involves removing and adding back a BVI interface in the configuration of MPLS Static, with IGP protocols (OSPF and ISIS) enabled.",
                "Pass/Fail Criteria": "Mpls static verification is performed.\nTraffic verification is performed.\nBinding Verification verification is performed.\nMpls interface removal verification is performed.\nLabel add back verification is performed.\nTraffic check at TGN verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Stresscpu mplsstatic",
                "Procedure": "To test MPLS static functionality, verify that it continues to work properly even when the CPU is under heavy load. This test is triggered by bumping up the CPU. The configuration for this test includes a network set up with MPLS static and an Interior Gateway Protocol (IGP), such as OSPF or ISIS.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nCPU_list: \"ApData.CPU_list\"",
                "Pass/Fail Criteria": "Mpls static verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls static interface cfg flap",
                "Procedure": "MPLS static sessions can be tested by configuring interface flap scenarios to ensure there are no issues when interfaces are removed and added while the sessions are operational.\n\nThis test is triggered by the removal and addition of interfaces with MPLS static sessions in place.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls static verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Proc restart",
                "Procedure": "Before performing a test of the system's ability to restart its processes, verify that it is in a stable state at both the beginning and end of the process. The processes being tested are determined by information from an input file. The system should be configured with MPLS LDP, IGP using either OSPF or ISIS protocols.\n\nThis test is triggered by the system's configuration, which includes MPLS LDP and IGP (OSPF or ISIS).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"ldp_pi_ap.get_proc_list(trigger='restart', ApData=ApData)\"",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nMpls static verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Proc crash",
                "Procedure": "The test process crashes scenarios involve verifying that the system remains in a stable state both before and after the crash of the relevant processes. These processes are identified by data in an input file. The test configuration includes Multiprotocol Label Switching Label Distribution Protocol (MPLS LDP) and Interior Gateway Protocols such as OSPF or ISIS.\n\nThis test is triggered by the list of processes derived from the input file.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"ldp_pi_ap.get_proc_list(trigger='crash', ApData=ApData)\"",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nMpls static verification is performed.\nTraffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Master sc reload",
                "Procedure": "The test involves reloading or performing a failover on the Master SC of an MPLS System, followed by verification that the network converges correctly. This process should be repeated for both the Label Edge Router (LER) and Label Switching Router (LSR) nodes. The configuration used in this scenario includes MPLS LDP and static IGP routing using either OSPF or ISIS protocols.\n\nThis test is triggered by a reload of the Master SC or a failover event affecting the LER or LSR Nodes.",
                "Pass/Fail Criteria": "Platform vm final band verification is performed.\nMpls control plane verification is performed.\nMpls interfaces verification is performed.\nMpls static verification is performed.\nTraffic verification is performed.\nBinding verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Slave sc reload",
                "Procedure": "To test the MPLS system's reliability when its slave node fails over or is reloaded, verify that it does not have any impact on the convergence of the MPLS network after performing a reload or fail-over of either a Label Edge Router (LER) or a Label Switching Router (LSR). This test should be triggered by an event in which the slave SC fails to establish a connection with its master, causing it to automatically attempt a fail-over or reload. The configuration required for this test includes MPLS LDP and IGP protocols such as OSPF or ISIS.",
                "Pass/Fail Criteria": "Platform vm final band verification is performed.\nMpls control plane verification is performed.\nMpls interfaces verification is performed.\nTraffic verification is performed.\nMpls static verification is performed.\nBinding verification is performed.\nStop and traffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "System reload",
                "Procedure": "To test the MPLS system's ability to handle reload scenarios such as router process (RP) failover or RP reload, verify that the network converges after reloading or failing over a Label Edge Router (LER) or Label Switching Router (LSR). The configuration for this test should include MPLS LDP and an Interior Gateway Protocol (IGP), which could be either OSPF or ISIS. This test is triggered by the occurrence of a router process failover or reload event.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.trigger_list\"",
                "Pass/Fail Criteria": "Platform vm final band verification is performed.\nMpls control plane verification is performed.\nMpls interfaces verification is performed.\nMpls static verification is performed.\nTraffic verification is performed.\nBinding verification is performed.\nInterface brief status verification is performed.\nIsis neighborship verification is performed.\nOspf neighborship verification is performed.\nStop and traffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls static ldp lc oir",
                "Procedure": "MPLS static forwarding can be tested by making configuration changes to a line card using online insertion and removal or a reload operation, while ensuring that MPLS static sessions remain operational. The goal is to verify that such operations do not cause any issues. Configuration: MPLS static routing with an Interior Gateway Protocol (IGP) such as OSPF or ISIS.\n\nThis test is triggered by making changes to the line card configuration while MPLS static sessions are active.",
                "Pass/Fail Criteria": "Ospf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls static verification is performed.\nMpls interfaces verification is performed.\nMpls control plane verification is performed.\nTraffic verification is performed.\nPlatform vm final band verification is performed.\nVerifyinterface verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpls static ldp fc oir",
                "Procedure": "MPLS static forwarding can be tested by performing a Field Change Overboard Insertion and Removal (FC OIR) or reload operation on the device while an MPLS static session is active to ensure that this does not cause any issues. This test is triggered when an OSPF or ISIS IGP protocol is also configured in conjunction with the MPLS static sessions.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nOspf neighborship verification is performed.\nIsis neighborship verification is performed.\nMpls control plane verification is performed.\nMpls interfaces verification is performed.\nMpls static verification is performed.\nStop and traffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Continuous intf flap",
                "Procedure": "When testing continuous interface flaps with Multiprotocol Label Switching (MPLS) static forwarding, it's essential that these flaps do not have an adverse effect on the overall network performance. To achieve this, a configuration consisting of MPLS Label Distribution Protocol (LDP), MPLS Static, and Interior Gateway Protocols (IGPs) such as Open Shortest Path First (OSPF) or Intermediate System to Intermediate System (ISIS) should be implemented.\n\nThis test is triggered by testing continuous interface flaps with MPLS static forwarding.",
                "Pass/Fail Criteria": "Mpls control plane verification is performed.\nMpls static verification is performed.\nTraffic verification is performed.\nRcc lcc verification is performed.\nBlocked process verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "scale_slm_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Downmep scale slm 250 bund local xc",
                "Procedure": "To verify bundle SLM sessions, ensure that the system is configured for Ethernet SLA with a one-way-loss-sd of 250 meps and a one-way-loss-ds of 100ms. The local cross-connect (XC) should use Synthetic Loss Measurement Message (SLM) to measure the following: one-way-loss-sd and one-way-loss-ds. The process involves configuring an Ethernet SLA profile globally, applying the configuration under each interface, verifying that parameters are displayed correctly with the show ethernet sla operations command, checking for correct display of statistics with the show ethernet sla statistics command, and finally unconfiguring the SLA from both the interface and globally. \n\nThis test is triggered by enabling Ethernet SLA along with scaling and interface-level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm bund 250 local xc",
                "Procedure": "To verify bundle SLM sessions, we configure a bundle with 250 UP meps and CCM as 100ms - local XC. We also need to verify an Ethernet SLA with synthetic loss measurement messages covering one-way-loss-sd and measure one-way-loss-ds. The steps for configuring and verifying this include setting up an Ethernet SLA profile globally, applying the configuration under an interface, and checking that the configured parameters are displayed correctly in the 'show ethernet sla operations' CLI command as well as the statistics information in the 'show ethernet sla statistics' CLI command. After verifying everything, we unconfigure the Ethernet SLA from both the interface and globally. This test is triggered by configuring Ethernet sla along with scaling and interface level sla configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm shut unshut add remove",
                "Procedure": "To verify Ethernet SLA, use Synthetic Loss Measurement (SLM) to measure one-way-loss-sd and one-way-loss-ds. Configure an Ethernet SLA profile globally, then apply it under the interface. Check that configured parameters display correctly using the 'show ethernet sla operations' CLI command and verify that statistics information is also correct in the 'show ethernet sla statistics' CLI output. To test that the configuration is robust, perform various actions such as removing and rolling back SLA configurations from interfaces, shutting down and then unshutting the interfaces, and removing CFM (Connectivity Fault Management) configurations. After these tests, recheck that the parameters display correctly using the 'show ethernet sla operations' CLI command, and verify the statistics information in the 'show ethernet sla statistics' output. Finally, remove the Ethernet SLA configuration from both the interface and globally.\n\nThis test is triggered by performing actions such as removing and rolling back SLA configurations from interfaces, shutting down and then unshutting the interfaces, and removing CFM (Connectivity Fault Management) configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"shut_unshut_interface\" and \"remove_interface\"\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nCfm summary verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart slm",
                "Procedure": "To verify Ethernet SLA, a Synthetic Loss Measurement (SLM) is used to measure one-way-loss-sd and one-way-loss-ds. The process involves configuring an Ethernet SLA profile globally, applying the configuration under the interface, verifying that configured parameters are displayed correctly with the show ethernet sla operations CLI command, and checking that Ethernet SLA statistics information is displayed accurately under the show ethernet sla statistics CLI command. After these initial steps, a trigger is performed - typically by restarting or crashing a process - and it is then verified that the configured parameters remain displayed correctly after the trigger using the show ethernet sla operations CLI command, as well as ensuring that the Ethernet SLA statistic information remains accurate with the show ethernet sla statistics CLI command. Finally, the Ethernet SLA configuration is unconfigured from both the interface and globally.\n\nThis test is triggered by a process restart or crash.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"SlmApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm unsupport meps",
                "Procedure": "To verify Ethernet SLA with Synthetic Loss Measurement (SLM), the following measures must be taken into account: one-way loss-sd and one-way loss-ds. The process involves configuring an Ethernet SLA profile globally with unsupported MEPs, applying the configuration to a specific interface, verifying that configured parameters are displayed correctly using the 'show ethernet sla operations' CLI command, checking that Ethernet SLA statistics information is shown correctly in the 'show ethernet sla statistics' CLI output, and then unconfiguring the SLA from both the interface and globally. This test is triggered by configuring Ethernet SLA along with scaling and interface-level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with unsupported meps with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm phy 800 local xc",
                "Procedure": "To verify the Ethernet SLA with Synthetic Loss Measurement, we cover one-way loss metrics including standard deviation (sd) and downstream (ds). The process involves configuring an Ethernet SLA profile globally, then applying it under a specific interface. We verify that configured parameters are displayed correctly using the 'show ethernet sla operations' CLI command. Next, we check that the Ethernet SLA statistics information is also shown accurately under the 'show ethernet sla statistics' CLI command. Finally, we unconfigure the Ethernet SLA from both the interface and globally. This test is triggered by an Ethernet SLA along with scaling and interface-level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm phy shut unshut add remove",
                "Procedure": "To verify Ethernet SLA using synthetic loss measurement, you need to measure one-way-loss-sd and one-way-loss-ds. To do this, follow these steps: configure an Ethernet SLA profile globally, apply the configuration under the interface, verify that configured parameters are displayed correctly with \"show ethernet sla operations\" CLI, and verify that Ethernet SLA statistics information is displayed correctly under \"show ethernet sla statistics\" CLI. Then, perform a trigger to remove and roll back SLA configurations, CFM configurations from the interface, shut down interfaces and unshut them. Finally, verify configured parameters are displayed correctly again with \"show ethernet sla operations\" CLI and Ethernet SLA statistics information is displayed correctly under \"show ethernet sla statistics\" CLI. The test is triggered by removing and rolling back SLA configurations, CFM configurations, shutting down and unshutting interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"shut_unshut_interface\" and \"remove_rollback_interfaces\"\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nCfm summary verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm phy 2k local xc",
                "Procedure": "To verify the accuracy of Ethernet SLa measurements, you can use Synthetic Loss Measurement (SLM) to measure one-way loss in both directions - sd and ds. This is triggered by a series of steps including configuring the Ethernet SLa profile globally, applying it under an interface, verifying that the configured parameters are displayed correctly with the \"show ethernet sla operations\" CLI command, checking that the Ethernet SLa statistics information is also shown correctly under \"show ethernet sla statistics\", and finally unconfiguring the SLa from both the interface and globally.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm bund 250 vpws",
                "Procedure": "To verify bundle SLM sessions with 250 UP meps and CCM as 100ms - VPWS, the following steps should be performed. First, an ethernet sla profile is configured globally, then this configuration is applied under each interface. Next, it's verified that the parameters are displayed correctly using the show ethernet sla operations CLI command, followed by verifying that ethernet sla statistics information is also displayed correctly under the same CLI command. Finally, the ethernet sla should be unconfigured from both the interface and globally. This test is triggered by having Ethernet SLa configured along with scaling and interface-level SLa configurations in place.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm phy 800 vpws",
                "Procedure": "To verify the Ethernet Service Level Agreement (SLA) using Synthetic Loss Measurement (SLM), we measure one-way loss in both directions, namely one-way-loss-sd and one-way-loss-ds. The following steps are involved in this process: First, configure an Ethernet SLA profile globally; second, apply the SLA configuration under the interface; third, verify that the configured parameters display correctly with the show ethernet sla operations CLI command; fourth, check that the Ethernet SLA statistics information displays correctly under the show ethernet sla statistics CLI command. Finally, unconfigure the SLA from both the interface and globally.\n\nThis test is triggered by verifying an Ethernet Service Level Agreement (SLA) using Synthetic Loss Measurement (SLM).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm phy 2k vpws",
                "Procedure": "To verify the Ethernet Service Level Agreement (SLA) using Synthetic Loss Measurement (SLM), measures such as one-way loss-sd and one-way-loss-ds are covered. The process involves configuring an Ethernet SLA profile globally, then applying it to a specific interface. Subsequent steps include verifying that configured parameters display correctly with the show ethernet sla operations command line instruction, checking that Ethernet SLA statistics information displays properly under show ethernet sla statistics, and finally unconfiguring the SLA from both the interface and globally. This test is triggered by configuring Ethernet SLA along with scaling and interface level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bfd with cfm",
                "Procedure": "To verify the Ethernet SLa with Synthetic Loss Measurement (SLM), covering one-way loss measurements in both directions, follow these steps: configure an Ethernet SLa profile globally, verify that BFD sessions are up and collecting data, apply the configuration to a specific interface, check that configured parameters are displayed correctly using the show ethernet sla operations command, and then verify that SLa statistics are correct under show ethernet sla statistics. Additionally, ensure that BFD sessions remain up throughout this process and that the number of time-ups is collected accurately. Finally, remove the Ethernet SLa configuration from both the interface and globally.\n\nThis test is triggered by verifying that Ethernet SLa with Synthetic Loss Measurement (SLM) can correctly measure one-way loss in both directions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nBfd session detail interface verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Slm xc ac to ac pop push translate rewrite vlan tag",
                "Procedure": "To verify Ethernet SLA, synthetic loss measurement messages (SLM) cover one-way-loss-sd and one-way-loss-ds measurements. The process involves configuring an Ethernet SLA profile globally, applying the configuration to an interface, verifying that configured parameters display correctly using the show ethernet sla operations CLI command, testing VLAN tag combinations by popping, pushing, or translating tags, checking that Ethernet SLA statistics information is displayed accurately under the show ethernet sla statistics CLI command, and finally unconfiguring Ethernet SLA from both the interface and globally. This test is triggered by Ethernet SLA along with scaling and interface level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrewrite_mode: \"pop\" and \"push\" and \"translate\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Slm xc ac to ac pop rewrite vlantag remove add",
                "Procedure": "To verify Ethernet SLA, use Synthetic Loss Measurement (SLM) to measure one-way-loss-sd and one-way-loss-ds. This test is triggered by configuring an Ethernet SLA profile globally and applying it under a specific interface.\n\nNote: I removed the steps 1-7 as they are implied in the initial configuration and verification process, making the paragraph more concise and natural-sounding.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_rollback_interfaces\"\nrewrite_mode: \"pop\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nCfm peer meps verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale slm lc restart",
                "Procedure": "To verify Ethernet Sla, you use Synthetic Loss Measurement (SLM) to measure one-way-loss-sd and one-way-loss-ds. You configure an Ethernet SLA profile globally, then apply the configuration under a specific interface. Next, you check that the configured parameters display correctly with the \"show ethernet sla operations\" command. After that, verify that the SLA statistics information displays correctly under the \"show ethernet sla statistics\" command. Finally, unconfigure the SLA from both the interface and globally.\n\nThis test is triggered by the presence of Ethernet SLA along with scaling and interface-level SLa configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale slm rp reloads active standby switchover",
                "Procedure": "To verify the Ethernet SLM, we measure one-way-loss-sd and one-way-loss-ds. The process involves configuring an Ethernet SLa profile globally, applying it under the interface, verifying that configured parameters are displayed correctly using the show ethernet sla operations CLI, and checking that Ethernet SLa statistics information is displayed correctly with the show ethernet sla statistics CLI. We also perform a trigger - rp reload to verify that configured parameters remain correct after the reload. After this, we unconfigure the Ethernet SLa from both the interface and globally.\n\nThis test is triggered by performing a \"rp reload\" command.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"\ntrigger_mode: \"active_rp\" and \"standby_rp\" and \"switchover_rp\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm phy 1k vpws",
                "Procedure": "To verify the Ethernet SLM, you can use the Synthetic Loss Measurement (SLM) function to measure one-way loss with a scale of 1k on the PHY sub-module and set a timer of 1 second. This is done by configuring the Ethernet SLM profile globally, then applying its configuration under each interface, checking that the configured parameters are displayed correctly using the show ethernet sla operations CLI command, verifying that the Ethernet SLA statistics information is also displayed correctly under the show ethernet sla statistics CLI command, and finally unconfiguring the Ethernet SLM from both the interface and globally. This test is triggered by having an Ethernet Sla along with scaling and interface level Sla configurations in place.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm profiles phy 2k vpws",
                "Procedure": "To verify the Ethernet Service Level Agreement (SLA) with Scaling and Load Management (SLM), we configure an SLA profile on a global scale that uses physical interfaces to measure one-way-loss in both directions, denoted by \"sd\" and \"ds\". The configuration involves several steps: first, we apply the SLA profile globally; second, we apply it under each interface with 2K sessions over Virtual Private Wire Service (VPWS); third, we verify that the configured parameters are displayed correctly using the `show ethernet sla operations` CLI command. We also use the same command to verify that the Ethernet SLA statistics information is being displayed accurately. Finally, after completing these tests, we unconfigure the SLA from both the interface and globally.\n\nThis test is triggered by configuring an Ethernet SLA with Scaling and Load Management (SLM) on a network with physical interfaces supporting 2K sessions over Virtual Private Wire Service (VPWS).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_slm_measure\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nsla opertaion details are updated under show ethernet sla statistics verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "cfm_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Cfm basic verification",
                "Procedure": "The test for basic verifications of HWOffload on a Bun Sub (Up & Down Mep) network involves configuring and verifying various aspects of Continuous Forwarding Maintenance (CFM). This includes setting up CFM on both Processing Engines (PEs) in a Virtual Private Wire Service (VPWS) network, where Access Circuits (AC) are connected to peer pseudo-wires. The test also verifies that peer multi-point encapsulation protocols (meps), local maintenance points, and the display of local mep details via the show ethernet cfm local meps detail command are functioning correctly. Additionally, it pings and performs a traceroute on the CFM network to ensure connectivity, and checks that traffic is flowing properly.\n\nThis test is triggered by the need to verify basic hardware offload functionality for CFM in a specific network configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ping",
                "Procedure": "CFM is tested by pinging a BGP VPN Service (VPWS) network. The test verifies that a Continuity Check Message (CCM) can be sent from one endpoint to another and received correctly. To do this, configure CFM on both Provider Edge (PE) devices in the VPWS network and verify that the CCM is transmitted with a source Maintenance Endpoint Identifier (MEP-ID) and interface. Then, verify the transmission of the CCM with just the source interface, ensuring that traffic is flowing properly through the network.\n\nThis test is triggered by the configuration of CFM on both Provider Edge devices in the VPWS network.",
                "Pass/Fail Criteria": "CFM: Verify CFM ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm traceroute",
                "Procedure": "CFM traceroute with BGP VPWS testing involves verifying that the CFM traceroute works correctly. To do this, configure Continuity Fault Management (CFM) on both Provider Edge (PE) devices in a Virtual Private Wire Service (VPWS) network, and then use CFM to perform a traceroute from a source Maintenance Association End Point Identifier (MEP-ID) and interface, as well as a source interface. The test also checks that traffic is flowing properly throughout the network.\n\nThis test is triggered by configuring Continuity Fault Management on both Provider Edge devices in a VPWS network.",
                "Pass/Fail Criteria": "CFM: Verify CFM traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config",
                "Procedure": "CFM Global Unconfiguration and Configuration with BGP VPWS testing involves verifying the correct configuration of CFM. This process includes configuring CFM on both Provider Edge (PE) devices in a Virtual Private Wire Service (VPWS) network, then unconfiguring it globally on both PEs. The test proceeds by reconfiguring CFM globally on both PEs and checking if the CFM session is restored. Additionally, the test verifies that traffic flows properly throughout the network. This test is triggered by a need to validate CFM configuration in a BGP VPWS environment.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Global Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm config unconfig int",
                "Procedure": "The test for configuring and unconfiguring CFM (Connectivity Fault Management) on a VPWS network involves several steps. It starts with setting up CFM on both Provider Edge (PE) devices that form the network, followed by unconfiguring it at the interface level on both PEs. Next, CFM is reconfigured at the interface level on both devices. The test then verifies whether the CFM session has been successfully restored and that traffic is flowing properly through the network.\n\nThis test is triggered when a device attempts to restore CFM configuration after it has been unconfigured.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config domain",
                "Procedure": "To configure and verify the operation of a CFM (Connectivity Fault Management) domain on a VPWS (Virtual Private Wire Service) network, it is necessary to first set up CFM on both Provider Edge (PE) devices. Next, unconfigure the CFM domain on both PEs and then reconfigure it to restore the CFM session. The final step is to verify that traffic flows properly through the network.\n\nThis test is triggered by a request to configure the Unconfiguration Configuration of cfm domain with BGP VPWS.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of cfm domain verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm with unconfig config ospf",
                "Procedure": "Configuration of OSPF with BGP VPWS involves verifying CFM on the unconfigured configuration. To do this, configure CFM on both Provider Edge (PE) routers in a Virtual Private Wire Service (VPWS) network, then unconfigure OSPF on both PE and Provider (P) routers before reconfiguring OSPF. After these steps, verify that the CFM session is restored and traffic flows properly.\n\nThis test is triggered by OSPF being configured with BGP VPWS.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of ospf on both PE's and P verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm with unconfig config mpls",
                "Procedure": "Configuration of CFM on a multi-protocol label switching (mpls) network with Border Gateway Protocol (BGP) Virtual Private Wire Service (VPWS) involves verifying that the CFM service is operational even after mpls configuration changes. This test triggers when an mpls configuration change occurs, including: Configure CFM on both Provider Edge routers on a VPWS network, unconfigure mpls on both PE's and the Provider router, reconfigure mpls on both PE's and the Provider router, verify that the CFM session is restored to operational status, and confirm that traffic flows properly.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of mpls on both PE's and P verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm with unconfig config l2vpn",
                "Procedure": "Configuration of Layer 2 VPN (l2vpn) with BGP Virtual Private Wire Service (VPWS) involves verifying the operation of Connectivity Fault Management (CFM). To test this, configure CFM on both Provider Edge routers in a VPWS network. Next, unconfigure the l2vpn on all relevant devices and then reconfigure it. Once this is done, verify that the CFM session has been successfully restored. Finally, confirm that traffic flows properly through the network.\n\nThis test is triggered by configuring Layer 2 VPN (l2vpn) with BGP Virtual Private Wire Service (VPWS).",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of l2vpn on both PE's and P verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ccm 10m",
                "Procedure": "The test uses CFM (Connectivity Fault Management) to verify its operation with a 10 millisecond time-to-live value for the Continuity Check Message (CCM). To run this test, CFM must be configured on both PEs (Provider Edge devices) with a 1 millisecond CCM. Once configured, it should be verified that the CFM session is up and functioning properly, and that traffic is flowing as expected between the two endpoints.\n\nThis test is triggered by configuring CFM on both Provider Edge devices with a Continuity Check Message time-to-live of 10 milliseconds, using BGP (Border Gateway Protocol) VPWS (Virtual Private Wire Service).",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ccm 1m",
                "Procedure": "CFM is tested with a 1m CCM, and BGP VPWS is configured. This test verifies that CFM works when configured on both PEs with a 1m CCM. It checks if the CFM session is up and working, and if traffic flows properly.\n\nThis test is triggered by verifying all required configurations are in place for testing 1m CCM with BGP VPWS.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 1m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ccm timer swap",
                "Procedure": "CFM tests are run with multiple CCM timer values using BGP VPWS. The configuration involves configuring CFM on both Provider Edge (PE) devices with a 10 millisecond CCM, verifying that the CFM session is up and working, then reconfiguring CFM on both PEs to use a 1 minute CCM while verifying continued operation. Next, the timers are changed again to 10 seconds CCM, and once more the functioning of the CFM session is verified. Finally, it's confirmed that traffic is flowing properly. This test is triggered by configuring CFM with different CCM timer values on both PEs.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with multiple CCM timer values verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm maid string",
                "Procedure": "CFM is tested with a MAID string using BGP VPWS. The test verifies that when configured to use the MAID string, the CFM session between both PEs is established and functioning correctly, allowing traffic to flow properly.\n\nThis test is triggered by configuring CFM on both Provider Edge (PE) devices with a MAID string in a BGP Virtual Private Wire Service (VPWS) environment.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with MAID string verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm maid dns",
                "Procedure": "CFM (Connectivity Fault Management) is tested with MAID (Multicast Address Independent Interface Definition) DNS using BGP VPWS (Virtual Private Wire Service). This test verifies that CFM is functioning correctly when configured on both Provider Edge routers (PEs) to use MAID dns. The configuration involves setting up CFM on the PEs, ensuring a working CFM session, and verifying that traffic flows properly.\n\nThis test is triggered by the selection of the \"CFM with MAID dns\" option in BGP VPWS.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with MAID dns verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm maid mac",
                "Procedure": "CFM is tested with a specific MAC address using the BGP Virtual Private Wire Service (VPWS) feature. This involves verifying that communication framework maintenance (CFM) sessions are established between two provider edge (PE) devices configured to use the designated MAC address. The test confirms that these sessions are functioning correctly and that traffic is flowing freely between them, ensuring a smooth operation of the CFM setup. This test is triggered by the configuration of CFM on both PEs with a unique MAID MAC address.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with MAID mac verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm maid swap",
                "Procedure": "The test involves verifying that Ethernet Connectivity Fault Management (CFM) functions correctly with multiple Maintenance Association Identifier (MAID) values in a BGP Virtual Private Wire Service (VPWS) network. The test configures CFM on both Provider Edge (PE) devices, initially setting the MAID to null. It then verifies that the CFM session is up and working as expected. Next, it reconfigures the CFM settings on both PEs with a string-based MAID, checks again for an operational CFM session, and repeats this process with a MAC address-based MAID. After testing all these scenarios, it ensures that traffic continues to flow properly through the network.\n\nThis test is triggered by verifying the configuration of CFM in a BGP VPWS network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with multiple MAID values verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm interface flap",
                "Procedure": "CFM with interface flap testing involves verifying the proper operation of a CFM (Connectivity Fault Management) session when an interface is brought down and then back up. To test this, first configure CFM on both endpoints, then verify that the CFM session is operational. Next, bring down the interface in the peer router and check if the CFM session is successfully terminated. After bringing the interface back online, confirm that the CFM session resumes its normal operation and traffic continues to flow properly.",
                "Pass/Fail Criteria": "Ipv4 interface detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM with interface flap verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm process restart",
                "Procedure": "The CFM system is tested with process restart. To verify its functionality, the test first configures CFM on both points of entry (PEs). It then checks to see that the CFM session is operational. Next, a process restart is performed. Finally, the test confirms that the CFM session remains up and working.\n\nThis test is triggered by configuration: CFM\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm process restart rp",
                "Procedure": "CFM testing involves verifying the functionality of CFM with a process restart. This test is triggered by configuring CFM on both PEs, verifying that the CFM session is operational, performing a process restart, and then confirming that the CFM session remains active and functioning as expected. Configuration: CFM\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers",
                "Procedure": "The test verifies the operation of CFM with triggers on both PEs by configuring CFM on each router, verifying that a CFM session is established and functional, performing various triggers such as reloading or unconfiguring the CFM configuration, and then checking to see if the CFM session remains up and working. This test is triggered by a timer set at 100ms, specifically for ASR9k sessions with VPWS enabled and bundle scaling configured, including Bundle Scale with MEP and CFM UP configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\" and \"unconfig_rollback_cfm\" and \"removeaddintf\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm summary verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps",
                "Procedure": "CFM is tested with a 10ms cycle time and a 10m (millisecond) clock management protocol for down MEPs. The test verifies that the device has been correctly configured to use this protocol. To set it up, configure CFM on both ends of the connection with a 1m clock management protocol. Once configured, verify that the CFM session is up and functioning as expected, and check that traffic is flowing properly through the network.\n\nThis test is triggered by configuring CFM on both PEs with 1m CCM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"CfmApBase.get_hw_offload_timers(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff dnx up meps",
                "Procedure": "CFM UP MEPs are tested with hardware offloading using various timer values. The test verifies that CFM sessions are established and functioning correctly when configured on both Provider Edge (PE) devices with a CCM interval of 10ms and 3.3ms, utilizing hardware offloading. This test is triggered by configuring CFM on both PEs with specific CCM intervals for upstream MEPs, then verifying that the CFM session is operational and show commands display accurate information about the timer values and session type as hw-offload. Additionally, the test confirms that traffic flows properly through the established CFM sessions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"CfmApBase.get_hw_offload_timers(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps detail verification is performed.\nCFM: Verify CFM with 10ms and 3.3ms CCM interval for up meps verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff a9k up meps",
                "Procedure": "CFM is tested on asr9k UP Mep with hardware offloading and a 10ms CCM for up meps. This test verifies that CFM works correctly with a 10ms CCM when there are down meps, but also with up meps where the CCM interval is set to 10m. To achieve this, configure both PEs with CFM using hardware offloaded CCM intervals for up meps. Verify that the CFM session comes online and works as expected. Additionally, check that the show ethernet cfm local meps detail and show ethernet cfm peer meps detail commands update properly with the timer and session type set to hardware offload. Lastly, confirm that traffic is flowing correctly through the network.\n\nThis test is triggered by a configuration of CFM on both Provider Edge (PE) devices.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"CfmApBase.get_hw_offload_timers(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 10ms and 3.3ms CCM for up meps verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps hw sw sessions",
                "Procedure": "CFM is tested with hardware offloading using a 3.3ms CCM and a 10s CCM for down meps. The test involves configuring CFM on both PEs with a 1m CCM, verifying that the session is up and working, and ensuring that traffic flows properly. This test verifies CFM with a 10m CCM. This test is triggered by the selection of hardware offloaded sessions (CCM interval < 10s), non-offloaded sessions (CCM interval >= 10s), or software-offloaded sessions for bundle ports.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps detail verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps hw sw sessions process restart",
                "Procedure": "The system tests the CFMhw-offload feature, which combines a 10ms clock cycle management (CCM) with process restart at level c. This test verifies that continuous forwarding (CFM) works correctly with a 10m CCM. To set up this test, configure CFM on both processing engines (PEs) to use 1m CCM. Once configured, verify that the CFM session is operational and functioning as expected. Then, check that traffic is flowing through the system properly.\n\nThis test is triggered by configuring CFM with a 10ms clock cycle management (CCM) period.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_hwoff_proc_list(ApData=CfmApBase.zap, process_list='hw_off_process_list_lc')\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps detail verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps hw sw sessions process restart rp",
                "Procedure": "The CFM hw-offload with 3.3 ms CCM test verifies the process restart at rp, while also testing CFM with a 10 millisecond CCM setting. To start, configure CFM on both Provider Edge (PE) devices using a one millisecond CCM, and then verify that the CFM session is established and functioning correctly. This test is triggered by verifying that traffic is flowing properly through the configured path.\n\nThis test is triggered when verifying that traffic flows properly through the configured path.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_hwoff_proc_list(ApData=CfmApBase.zap, process_list='hw_off_process_list_rp')\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps detail verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps hw sw sessions process crash",
                "Procedure": "CFM sessions are verified to be up and working, and traffic flows properly, in the following configuration: both PEs have CFM configured with a 1ms Cycle Cell Multiplication (CCM) timer. This test verifies that when one of the PEs crashes due to a process failure within 10 seconds, the remaining PE continues to operate successfully while triggering the test with a 3.3ms CCM setting.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_hwoff_proc_list(ApData=CfmApBase.zap, process_list='hw_off_process_list_lc')\"",
                "Pass/Fail Criteria": "Cfm local meps detail verification is performed.\nCfm peer meps verification is performed.\nCfm peer meps detail verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps hw sw sessions process crash rp",
                "Procedure": "CFM hardware offload was tested with a response time of 3.3ms and 10-second Connectivity Fault Management (CCM) with a process crash on the remote peer. The test also verifies that CFM works with a 10-minute CCM. To configure this, CFM is set up on both processing elements (PEs) using a 1-minute CCM. It's then verified if the CFM session is established and operational, and if traffic is flowing correctly.\n\nThis test is triggered by configuring Connectivity Fault Management (CCM) to be down for an extended period of time on the remote peer.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_hwoff_proc_list(ApData=CfmApBase.zap, process_list='hw_off_process_list_rp')\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps detail verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff a9k ccm different timers for up and down meps",
                "Procedure": "CFM hardware offloading is tested with different timers for up and down Maintenance Entity Groups (MEPs). The test verifies CFM operation with a 10ms Control and Monitoring Message Interval (CCMI) timer for down MEPs, but uses a 10-minute timer for up MEPs. To set this up, configure CFM on both Provider Edge switches with a 1-minute CCMI timer for the up MEP and a 10ms CCMI timer for the down MEP. Verify that the CFM session is established and functioning correctly. Check the output of the show ethernet cfm local meps detail and show ethernet cfm peer meps detail commands to ensure they display the correct timers and session type, which should be hw-offload. Finally, verify that traffic continues to flow properly through the network.\n\nThis test is triggered by verifying CFM operation with a 10ms CCMI timer for down MEPs but using a 10-minute timer for up MEPs.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps detail verification is performed.\nCFM: Verify CFM with 10m CCM for up meps and 10ms for down meps. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff mep timeout shut interface cscvv83783",
                "Procedure": "When the interface shuts down, a test checks that the CFM session goes down. The process involves shutting down the interface, verifying that the CFM session is indeed down, unshutting the interface, and then checking that the CFM session comes back up.\n\nThis test is triggered by the shutdown of the interface with CSCvv83783.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps detail verification is performed.\nCFM: Verify CFM with 10m CCM for up meps and 10ms for down meps. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ccm maid icc based teacscvf94217",
                "Procedure": "CFM testing involves verifying its functionality with a 1-microsecond CCM interval using an ICC-based service ID. This test confirms that CFM is set up correctly on both endpoints, and that it's functioning as expected by checking for established connections, proper traffic flow, and successful ICC-based ping requests.\n\nThis test is triggered by configuration settings indicating the use of a 1-microsecond CCM interval with an ICC-based service ID.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 1m CCM comes up with icc based service id. verification is performed.\nCFM ping works fine with icc based service id verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps crosscheck mismatch",
                "Procedure": "CFM sessions were configured on both PEs with a CCM of 1ms, then verified to ensure they were up and working as expected. Traffic was also confirmed to be flowing properly under these conditions. Next, an incorrect MEP crosscheck configuration was applied, which caused the down meps to go down. The correct MEP crosscheck configuration was re-applied, after which all meps were once again verified to be up. This test is triggered by a 10ms CCM on both PEs, and it verifies CFM with this longer interval.",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nincorrect mep crosscheck is brings down the cfm session verification is performed.\nreconfiguring correct mep brings up the cfm session verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps mac crosscheck",
                "Procedure": "CFM sessions are verified for down MEPs using a 10ms CCM, with cross-checking enabled through MAC addresses. To set this up, Configure CFM on both Provider Edge (PE) devices with a 1ms CCM interval. Ensure that the CFM session is established and functioning correctly by verifying its status. Additionally, confirm that traffic is flowing normally over the network. The MAC address should be configured as the cross-checking mechanism; upon doing so, verify that the CFM session comes online.\n\nThis test is triggered when configuring a MAC address for cross-checking on a 10ms CCM-enabled CFM session.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"10ms\" and \"3.3ms\"",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\ncfm session comes up with mac crosscheck verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps mac crosscheck change",
                "Procedure": "CFM with a 10ms CCM is tested by verifying that traffic flows properly when the mac address is correctly configured for crosscheck, but not when an incorrect mac address is used. This test verifies how CFM functions under these conditions, triggering if the CFM session comes up and down as expected according to the given scenarios.",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\ncfm session comes up with mac crosscheck verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps efd",
                "Procedure": "CFM with a 10 millisecond CCM interval for down MEPs is tested, verifying that it works as expected. To do this, both PEs are configured with CFM using a 10 millisecond CCM interval with EFD enabled. It's then verified if the CFM session comes up and is working properly, and traffic is flowing correctly. Next, the interface on the remote peer is shut down to simulate an issue, after which it's checked that the show efd interface command displays the correct information. This test is triggered by a configuration that includes CFM with EFD enabled.",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nEfd interface verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps dmm",
                "Procedure": "CFM is tested with a hw-offload using a 10ms CCM for down meps with ethernet sla DMM. The test verifies that CFM is functioning correctly with a 10ms CCM. To perform the test, configure CFM on both PEs with a 10ms CCM and EFD enabled. Then verify that the CFM session is up and working properly by checking for flowing traffic. Additionally, configure an ethernet sla DMM profile and verify that sla statistics are being reported correctly. \n\nThis test is triggered by enabling hw-offload in the CFM configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla statistics interface verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nsla statistics are reported verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoff down meps slm",
                "Procedure": "CFM is tested for hw-offload with a 10ms CCM, specifically in scenarios where there's down meps with ethernet sla SLM. The test verifies that CFM works correctly under these conditions by configuring CFM on both PEs with a 10ms CCM, checking that the CFM session is up and functioning properly, verifying that traffic flows as expected, and finally setting up an ethernet sla SLM to ensure that sla statistics are accurately populated.\n\nThis test is triggered by the configuration of CFM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla statistics interface verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nsla statistics are reported verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm asr9k rewrite pop1 up meps",
                "Procedure": "The test verifies the functionality of CFM (Connectivity Fault Management) in a scenario where two PEs (Provider Edge devices) are configured with a CCM (Clocking and Control Message) interval for an UP MEP (Maintenance Entity Group End Point). The configuration involves setting up CFM on both PEs, rewriting POP1 on an interface, and verifying that the CFM session is established and working properly. This test is triggered by configuring CFM on both Provider Edge devices with a CCM interval for an up mep and rewrite pop1 on an interface.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM with 1s CCM for up meps verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm dnx hwoffload rewrite pop1 up meps",
                "Procedure": "CFM is configured on both endpoints (PEs) with a CCM interval suitable for upstream MEPs, and rewrite POP1 is enabled on the interface. This test verifies CFM functionality with 3.3ms CCM using upstream MEPs. To confirm the session is operational, ping and traceroute checks are performed to ensure traffic flows properly.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM with 3.3ms CCM for up meps verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm asr9k rewrite pop2 up meps",
                "Procedure": "CFM testing of the asr9k UP Mep is performed using POP2 with a rewritten configuration, verifying CCM with a 1 second interval on up meps. Configure CFM on both PEs with a CCM interval for up mep and rewrite pop2 on interface. Verify that the CFM session is up and functioning correctly by checking ping and traceroute results, as well as ensuring proper traffic flow.\n\nThis test is triggered by configuring CFM on both PEs with a CCM interval for an up MEP and rewriting POP2 on the interface.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM with 1s CCM for up meps verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm dnx hwoffload rewrite pop2 up meps",
                "Procedure": "CFM is tested with UP Meps using POP2 and a 3.3ms internal CCM. This test verifies that CFM works with a 3.3ms CCM interval when used on both PEs, one of which has its interface configured for an up mep and rewrite pop2. The session is checked to be active and functioning properly by verifying that pings and traceroutes are successful, indicating that traffic is flowing correctly, as per the given configuration settings. This test is triggered by the presence of CCM on both PEs with a 3.3ms interval.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM with 3.3ms CCM for up meps verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm asr9k rewrite push1 up meps",
                "Procedure": "The test, named \"Tests CFM asr9k UP Mep with rewrite PUSH1\", verifies that the CFM function works correctly with a CCM interval for an up MEP and a rewritten push1 on an interface. The configuration involves setting up CFM on both processing engines with the specified interval and rewriting the push1 on the interface, while ensuring a functioning CFM session by verifying its up status and checking for proper traffic flow through ping and traceroute tests.\n\nThis test is triggered by the configuration of CFM on both PEs with CCM interval for up mep and rewrite push1 on interface.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM with 1s CCM for up meps verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm dnx hwoffload rewrite push1 up meps",
                "Procedure": "The configuration involves setting up CFM on both points of entry (PEs) with a CCM interval for an up MEP, as well as rewriting PUSH1 on the interface. To verify that the CFM session is functioning correctly, it should be checked to ensure it's up and running properly. Additionally, pinging and tracerouting should be performed to confirm network connectivity. Finally, it's necessary to verify that traffic is flowing freely.\n\nThis test is triggered by configuring CFM with a 3.3ms CCM interval for an UP MEP on both PEs.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM with 3.3ms CCM for up meps verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm cos cscvy42343",
                "Procedure": "The test checks that COS (Class of Service) values are correctly configured on a Virtual Private LAN Service (VPLS) environment using Carrier's Frequency Mask (CFM). It specifically verifies that the COS value is set to 2, and then changed from 2 to 3. This test is triggered by verifying the configuration of cos value on CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ncos_value: \"CfmApBase.get_cos_value_cfm(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify cos value configured on CFM domain verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm basic verification",
                "Procedure": "This paragraph and the trigger sentence that follows are:\n\nTests using CFM over vpls basic verifications with BGP VPLS to verify that the configuration is correct. This test is triggered by the presence of a configured CFM setup on both PEs within a VPLS network, which includes configuring CFM on both points of exit, verifying peer multipoint endpoints, checking local maintenance points, and confirming that traffic flows properly.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm ping",
                "Procedure": "The test verifies CFM ping by configuring CFM on both provider edge (PE) devices in a virtual private LAN service (VPLS) network, then verifying that a CFM ping sent from a specified maintenance association endpoint ID and interface reaches its destination. Additionally, the test verifies that the same CFM ping can be sent directly from the source interface, as well as checks to ensure that data traffic is flowing correctly through the network.\n\nThis test is triggered by configuring CFM on both PEs in a VPLS network configured with Border Gateway Protocol (BGP) VPLS.",
                "Pass/Fail Criteria": "CFM: Verify CFM ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm traceroute",
                "Procedure": "To verify that CFM traceroute functions correctly over a VPLS network supported by BGP, the following steps are taken. The configuration involves enabling CFM on both Provider Edge (PE) devices within the Virtual Private LAN Service (VPLS). Verification of the CFM traceroute is then performed from two different perspectives: first with the source MEP-ID and interface specified, and second with just the source interface identified. Once the verification steps are complete, it must be confirmed that traffic is flowing properly through the network.\n\nThis test is triggered by verifying that CFM traceroute functionality operates as expected over a VPLS infrastructure supported by BGP VPLS.",
                "Pass/Fail Criteria": "CFM: Verify CFM traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm unconfig config",
                "Procedure": "CFM (Connectivity Fault Management) is tested over a VPLS (Virtual Private LAN Service) global unconfiguration configuration with BGP (Border Gateway Protocol). The test verifies that CFM can be globally unconfigured and then reconfigured on both PE's (Provider Edge devices) of a VPLS network. The test involves configuring CFM on both PEs, then globally unconfiguring it on both devices, followed by reconfiguring CFM globally and verifying that the CFM session is restored and traffic is flowing properly.\n\nThis test is triggered by the configuration of BGP-enabled CFM for Global Unconfiguration Configuration with VPLS.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Global Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm interface rewrite ingress pop",
                "Procedure": "CFM configuration is tested over a VPLS interface. To do this, both PEs on the VPLS network are configured with CFM. It's then verified that MEPS (Multi-Endpoint Path Selection) are up and functioning over the VPLS connection. Next, the AC (Access Concentrator) is configured to rewrite the ingress tag by popping 1 symmetric. The test continues by verifying whether a CFM session is restored after this configuration change. Finally, it's checked that traffic is flowing properly across the network.\n\nThis test is triggered when configuring CFM on both PEs on a VPLS network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM peer MEP before and after rewrite ingress configuration on Interface verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm config unconfig int",
                "Procedure": "CFM must be configured on both PEs in a VPLS network, then unconfigured at the interface level on both devices, reconfigured again at the interface level, and finally verified to ensure that the CFM session is restored and traffic is flowing correctly.\n\nThis test is triggered by verifying that a configuration has been made for the Control and Forwarding (CFM) Interface Unconfiguration Configuration over VPLS with BGP.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm unconfig config domain",
                "Procedure": "The test verifies the unconfiguration and reconfiguration of a CFM (Connectivity Fault Management) domain over a VPLS (Virtual Private LAN Service) network. To do this, CFM is first configured on both Provider Edge routers in the VPLS network, then unconfigured, and finally reconfigured again. The test checks that a CFM session is restored and that traffic continues to flow properly after each configuration change.\n\nThis test is triggered by manual or automated actions taken within the network management system.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of cfm domain verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm with unconfig config ospf",
                "Procedure": "CFM is tested over a VPLS network in an unconfigured OSPF configuration. This test verifies that CFM is functioning as expected when OSPF is not configured on both PE's and P. It does this by first configuring CFM on both provider edge (PE) devices, then removing the OSPF configuration from both PE's and the switch, and finally reconfiguring OSPF on both PE's and the switch. The test continues to verify that the CFM session is restored after OSPF is reconfigured, and also checks for proper traffic flow.\n\nThis test is triggered by an unconfigured OSPF configuration in a VPLS network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of ospf on both PE's and P verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm with unconfig config mpls",
                "Procedure": "Configuring CFM on a VPLS network with MPLS and BGP involves verifying the operation of CFM in an unconfigured state for the MPLS setup. To do this, first configure CFM on both Provider Edge (PE) devices on the VPLS network. Next, unconfigure the MPLS settings on both PE devices and the provider router (P). Then reconfigure the MPLS settings on both PE devices and the P. Verify that the CFM session is restored and that traffic is flowing properly between the PE devices.\n\nThis test is triggered by configuring CFM on a VPLS network with unconfigured MPLS, verifying the operation of CFM in an unconfigured state for the MPLS setup.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of mpls on both PE's and P verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm with unconfig config l2vpn",
                "Procedure": "A test to verify CFM over VPLS verifies the operation of Connectionless OAM for VPLS networks by testing the recovery of a CFM session after an unconfiguration and reconfiguration of the l2vpn. This test is triggered by configuring CFM on both Provider Edge (PE) routers in a VPLS network, then disabling and re-enabling the VPLS configuration on both PE's and the provider router.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of l2vpn on both PE's and P verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm ccm 10m",
                "Procedure": "When testing the interaction between CFM and VPLS with BGP, configure both provider edges (PEs) with a 10m cycle count multiplier (CCM). The PEs should initially be configured to run at 1m CCM. Verify that the CFM session is operational and that traffic flows smoothly through the network. \n\nThis test is triggered by configuring the PEs to switch from 1m CCM to 10m CCM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm ccm 1m",
                "Procedure": "The configuration for this test involves setting up CFM (Connectionless OAM) on both Provider Edge (PE) devices, utilizing a 1-microsecond Cycle and Control Message (CCM) interval. BGP VPLS (Virtual Private LAN Service) is also in place to facilitate the test. The verification steps consist of ensuring that the CFM session is functioning properly and that traffic is flowing correctly.\n\nThis test is triggered by configuring CFM on both Provider Edge devices with a 1-microsecond CCM interval, utilizing BGP VPLS as the underlying transport mechanism.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 1m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm ccm 10s",
                "Procedure": "CFM (Connectivity Fault Management) sessions were set up over a VPLS (Virtual Private LAN Service) network with BGP (Border Gateway Protocol). One test verified the operation of CFM with a cycle timer of 10 seconds, while another used a 1-minute cycle timer. In both tests, traffic was flowing properly through the connections. The equipment was configured to maintain CFM sessions for a cycle timer of 1 minute. This test is triggered by verifying that a CFM session remains up and functioning after an initial configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 10s CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm ccm 1s",
                "Procedure": "Configuration for this test involves configuring CFM on both Provider Edge (PE) devices with a 1-microsecond (μs) Continuous Connectivity Monitoring (CCM). The test verifies that the CFM session is operational and functioning as expected. Traffic flow is also verified to ensure it is proceeding normally. This test is triggered by the configuration of BGP Virtual Private LAN Service (VPLS) with 1-second CCM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 1s CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm ccm timer swap",
                "Procedure": "CFM (Connectivity Fault Management) tests are run over VPLS (Virtual Private LAN Service) networks that use BGP (Border Gateway Protocol) for signaling. The test verifies the operation of multiple CCM (Continuity Check Message) timer values with CFM configured on both Provider Edge (PE) devices. Initially, CFM is set up with a 10m CCM timer value on both PEs, and it's verified that the session comes up and works correctly. The configuration is then modified to use a 1m CCM timer value, after which it's checked if the CFM session remains operational. This test is triggered by verifying that CFM sessions are consistently established with different CCM timer values on BGP VPLS networks, while also ensuring that traffic continues to flow properly throughout the network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with multiple CCM timer values verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm interface flap",
                "Procedure": "CFM sessions are verified with an interface flap on VPLS. This test checks that the configuration works as expected when the PE interfaces are flapped, starting by configuring CFM on both PEs to verify the session comes up and is working correctly. It then brings down an interface in the PW of the P router, verifies that the CFM session is properly brought down, brings it back up, checks that the session is once again operational, and finally verifies that traffic flows properly through the network.\n\nThis test is triggered by a BGP VPLS interface flap event.",
                "Pass/Fail Criteria": "Ipv4 interface detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM with interface flap verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm process restart",
                "Procedure": "CFM tests are performed over VPLS with a process restart triggered by BGP VPLS. The test verifies the functionality of CFM with process restart, which involves configuring CFM on both Provider Edge (PE) devices. This test is triggered by the occurrence of a BGP VPLS event. The configuration for this test is set up as follows: CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm process restart rp",
                "Procedure": "The test checks the functionality of CFM over VPLS, specifically when a BGP VPLS process is restarted. This test is triggered by restarting the BGP VPLS process with the command \"rp with\". The verification process involves configuring CFM on both Provider Edge (PE) devices, checking that the CFM session is operational, performing a process restart of the BGP VPLS, and then verifying once again that the CFM session remains up and functioning.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm triggers",
                "Procedure": "CFM over VPLS with triggers configuration involves testing the operation of CFM. The test verifies that a CFM session is established between both PEs, then simulates triggers such as rpfo (remote protocol fault), reload, and lcoir. The goal is to confirm that the CFM session remains operational after these trigger events.\n\nThis test is triggered by various operations including remote protocol fault, reload, and loss of control plane IS-IS connectivity via BGP VPLS.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_oir\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls scale 100ms",
                "Procedure": "A test verifies that Customer Facing Messaging (CFM) works properly over Virtual Private LAN Service (VPLS) with a scale of 100ms. To set this up, configure scaled subinterfaces, globally set 1600 domains and services for CFM, and also set 1600 CFM under each subinterface. Then verify that the CFM session is active and functioning as expected.\n\nThis test is triggered by performing triggers (rpfo, reload, lcoir).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_oir\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle scale 100ms vpws",
                "Procedure": "The test verifies that the CFM configuration scales correctly on the ASR9k sessions when using bundle scale with VPWS. The test case timer is set to 100ms for this test, which involves R1 and R2 communicating through scaled sessions configured in the setup. To verify the correctness of the CFM configuration, various checks are performed, including verifying the CFM summary, peer MEPs, local MEPs, and that traffic is flowing properly. Additionally, a CFM ping with a specific source MEID and interface is sent to further test the configuration. This test is triggered by the Configure Bundle Scale with VPWS option.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nGet ethernet cfm summary verification is performed.\nEthernet cfm session verification is performed.\nCfm summary verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 100ms commit replace cscvy03169",
                "Procedure": "This text appears to be a test configuration, which verifies that all Meps are up and running before executing the commit_replace rollback process. The test checks for a CFMD Crash in the system log and fails if one is found. This test is triggered by the 'commit_replace_rollback' trigger.\n\n(Note: I removed the \"Configuration\" line as it seemed redundant, but if you'd like to keep it, please let me know!)",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\ncfmd crash should not happen after commit replace rollback verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm no domain service id",
                "Procedure": "This paragraph is empty, there's nothing to rewrite. However, if you provide the original text, I'll be happy to help.\n\nAssuming you meant to provide a different original text, please go ahead and share it so I can assist you accordingly. \n\nIf I had the original text, here's how the response would look:\n\nThe paragraph is: CFM basic verifications are verified by this test. This test verifies that Configure CFM without domain and service id on both PEs on VPWS network is properly configured.\n\nAnd the rewritten trigger sentence is: This test is triggered by verifying CFM basic verifications.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm no domain service str id",
                "Procedure": "This paragraph is empty. However, I can create a new text based on your requirements.\n\nThe test for verifying CFM (Connectivity Fault Management) basic verifications involves configuring CFM on a VPWS (Virtual Private Wire Service) network without a domain and service ID on both Provider Edge (PE) devices. This setup is meant to simulate a basic configuration. \n\nThis test is triggered by the absence of a domain and service ID in the Configuration: CFM setup.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service str id",
                "Procedure": "The VPLS configuration for the CFM str domain service includes a unique string ID of 48 bytes, which is used in the Maid (Maintenance Access Indication Data) string. The test verifies basic CFM verifications by configuring CFM without specifying a domain or service ID on both provider edge routers in a VPWS network. This test is triggered when configuration for CFM without specifying a domain and service id on both PEs on VPWS network is done.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service no id",
                "Procedure": "This text describes a verification process for Cisco Fabric Messaging (CFM) basic operations on a Virtual Private LAN Service (VPLS) network.\n\nThe test verifies the CFM basic verifications. It is triggered by configuring Cisco Fabric Messaging without domain and service ID on both Provider Edge devices in a Virtual Private Wire Service network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service icc id",
                "Procedure": "This paragraph is blank as there was no original text provided. If you'd like to provide the original text, I can assist with rewriting it according to your specifications.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm no domain service icc id",
                "Procedure": "CFM is configured without a domain and service ID on both Provider Edge (PE) devices in the Virtual Private Wire Service (VPWS) network.\n\nThis test verifies that the basic CFM verifications are functioning correctly, triggered by the configuration of CFM without domain and service ID on both PEs.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm pop str domain service str id",
                "Procedure": "This paragraph and trigger sentence are the rewritten version:\n\nWhen configuring CFM on a VPWS network, it is necessary to configure the protocol without specifying a domain and service ID on both provider edge (PE) devices. This test verifies that basic CFM verifications are successful in this configuration.\n\nThis test is triggered by the absence of a domain and service id specified during CFM configuration on both PEs on a VPWS network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm push str domain service str id",
                "Procedure": "The configuration for this test involves setting up CFM (Connectivity Fault Management) without a domain or service ID on both Provider Edge (PE) routers in a Virtual Private Wire Service (VPWS) network. This is used to verify the basic verifications of CFM, which confirms that the configuration is correct and there are no connectivity issues.\n\nThis test is triggered by configuring CFM without domain and service id on both PEs on VPWS network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service id efd",
                "Procedure": "The test verifies Communication Function Message (CFM) with a 10 millisecond Control and Monitoring Connection (CCM). It checks that CFM sessions are set up and functioning correctly between two Provider Edge routers, configured to use EFD and a 10ms CCM. The configuration includes CFM on both devices.\n\nThis test is triggered by the fact that it verifies CFM with a specific CCM value (10 ms) that has been configured for Communication Function Messages.",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nEfd interface verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service id dmm",
                "Procedure": "The test verifies the operation of a service with a specific domain, utilizing a 48-byte string to identify it. It checks that the Continuous Forwarding Message (CFM) system is functioning correctly with a 10ms cycle communication method. The configuration involves setting up CFM on both endpoints with 10ms CCM and Ethernet Service Levels (SLA) with Dual-Connected MAC Address Identification, verifying that traffic flows properly and SLA statistics are reported.\n\nThis test is triggered by the activation of a specific service, utilizing a 48-byte string for identification.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla statistics interface verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nsla statistics are reported verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service id slm",
                "Procedure": "This test verifies the operation of Connectionless Operations, Administration, and Maintenance (OAM) protocols by checking that a specified Ethernet Service Instance (ESI) on each peer edge device can send and receive traffic over a path with a specific link delay.\n\nThis test is triggered by configuring both peer edge devices with 10ms CFM (Connectivity Fault Management) and verifying that the corresponding OAM traffic is sent between them, along with populating the Service Level Monitoring (SLM) statistics for the specified ESI.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla statistics interface verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nsla statistics are reported verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service id timers",
                "Procedure": "When configuring VPWS, the timers for verifying CFM (Connectivity Fault Management) need to be checked. This involves setting the cfm str domain service and id to specific values, such as 48 bytes for the maid string. The test also verifies that CFM with a 10-minute CCM (Clock Management) is working properly on both provider edge routers. To do this, we first configure CFM on both routers with a 1-minute CCM. Then, we check if the CFM session is active and functioning correctly by verifying traffic flow. The configuration of CFM should be set up as described.\n\nThis test is triggered by configuring VPWS timers for cfm str domain service and id to specific values, such as 48 bytes for the maid string, on both PEs (provider edge routers) with a 1m CCM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"CfmApBase.get_hw_offload_timers(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service triggers",
                "Procedure": "The test verifies the operation of Connectionless CFM (CFM) between two provider edge (PE) devices by configuring CFM on both PEs, establishing a connection, performing triggers such as reload and unconfig_rollback_cfm, and then verifying that the session remains up and functioning. This test is triggered by a configuration change involving the removal of an interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"removeaddintf\" and \"lc_reload\" and \"rpfo\" and \"unconfig_rollback_cfm\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm str domain service process restart",
                "Procedure": "The VPWS verify process restart test confirms that CFM (Connectionless Operations, Administration, and Maintenance) functions properly with a process restart. This involves configuring CFM on both participating edge devices, verifying that the CFM session is operational, performing a process restart, and then checking if the CFM session remains up and working. The specific configuration required for this test is CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bfd doamin service string",
                "Procedure": "The VPWS test verifies the BFD flap scenario by configuring BFD and CFM on both PEs. It checks whether the BFD session is up and records the number of times it comes up. The test then removes the CFM configuration, re-applies it, and again verifies that the Down MEP status is up with a BFD session. Finally, it compares the number of times the BFD session came up with its previous value to check for any BFD flap.\n\nThis test is triggered by changes in a 48-byte MAID string in the CFM domain service.",
                "Pass/Fail Criteria": "Bfd session detail interface verification is performed.\nOspf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nCfm peer meps verification is performed.\nOSPF, MPLS LDP, Xconnect , CFM verification is performed.\nBFD Flap after removing and re-applying CFM verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers maid string",
                "Procedure": "This test verifies the operation of a CFM network with triggers by configuring CFM on both peer endpoints, checking that a CFM session is established and functioning correctly, performing various trigger actions including reloads and unconfigurations, and then verifying that the CFM session remains operational. This test is triggered by verifying the configuration: CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\" and \"removeaddintf\" and \"unconfig_rollback_cfm\"",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 1k 100ms maid string flap members",
                "Procedure": "The test procedures involve testing the system's ability to handle a high volume of traffic, specifically 1 kilocubic foot per minute (Kcfm), and verifying that it can be scaled up without any issues. The configuration for this test includes configuring the Common Flow Message (CFM) framework to use VPWS (Virtual Private Wire Service). This test is triggered by VPWS being configured with a scale of over 1 kilocubic foot per minute (Kcfm), with a delay of 100 milliseconds.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nFlap Tests cfm over VPWS - scale over vpws with 100ms and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 1k 100ms maid string add remove scale 100ms",
                "Procedure": "This test verifies connectivity for a 1 kilowatt (kW) customer who has an add-remove (a/r) configuration, but does not have domain services or a MAC ID. This test is triggered by the presence of a 48-byte \"maid string\" in the VPWS (Virtual Private Wire Service) configuration.\n\n(Note: The last sentence was rewritten as instructed to be a proper English sentence with a clear and concise description of when this test would be triggered.)",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 1k 100ms maid string unconfig config",
                "Procedure": "To verify the unconfiguration and reconfiguration of a Global CFM config, follow these steps: Configure CFM on both PEs and then unconfigure it on both devices. Reconfigure the CFM domain on both points of expansion (PEs), and check that the CFM session has been restored. Finally, confirm that traffic is flowing properly.\n\nThis test is triggered by a change in Global CFM configuration.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers maid both string domain",
                "Procedure": "The test verifies that the CFM (Connectivity Fault Management) service is functioning correctly on a network with 500 cfm. It involves configuring CFM on both peer equipment (PEs), verifying that the CFM session is established, and then triggering various actions such as reloading the configuration, rolling back changes, or removing and re-adding interfaces to see if the session remains active.\n\nThis test is triggered by the verification of a 48-byte string in the MAID (Management Access Information Domain) protocol.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\" and \"removeaddintf\" and \"unconfig_rollback_cfm\"",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 500 maid both string domain flap members",
                "Procedure": "The VPWS verifies a scale of 500 cubic feet per minute. The test procedures involve tests conducted over the VPWS at a scale with a delay of 100 milliseconds. Additionally, configuration includes control flow measurement.\n\nThis test is triggered by VPWS verifying a scale of 500 cubic feet per minute in a domain service with a string identifier of 48 bytes and a maid string value.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nFlap Tests cfm over VPWS - scale over vpws with 100ms and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 500 maid both string domain add remove scale 100ms",
                "Procedure": "This test verifies the operation of a CFM (Connectivity Fault Management) session over a VPWS (Virtual Private Wire Service) with a scale of 500 cfm, including adding and removing members from the str domain service. The configuration is done in setup, using an Add Remove interface for scaling over VPWS. The test checks if the CFM session is up and working, verifies ping responses, and examines local MEP details and traffic.\n\nThis test is triggered by: Tests cfm over VPWS - scale over vpws with 100ms",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 500 maid both string domain unconfig config",
                "Procedure": "The test verifies the unconfiguration and configuration of a global Connectionless Operations, Administration, and Maintenance (COAM) function with scale 500, which includes configuring COAM on both Provider Edge routers, then unconfiguring it, reconfiguring it, verifying that any affected sessions are restored, and confirming that traffic is flowing properly.\n\nThis test is triggered by verification of the VPWS configuration.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers maid no domain string",
                "Procedure": "To verify the scale of a network device, this test triggers by verifying that the Control And Management Protocol (CFM) is functioning properly between two devices. It does this by configuring CFM on both points of presence (PEs), checking to make sure the session comes up and is working correctly, performing specific triggers such as reinitializing or reloading a connection, undoing a previous configuration rollback for CFM, and removing an interface that was previously added. The test then checks again to confirm the CFM session remains up and operational.\n\nTriggered by verifying that the Control And Management Protocol (CFM) is functioning correctly between two devices.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\" and \"removeaddintf\" and \"unconfig_rollback_cfm\"",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 500 maid no domain string flap members",
                "Procedure": "To test VPWS scalability, a flow of 500 cubic feet per minute is established between two endpoints. The FLAP members are verified to ensure they can handle the increased traffic without domain service interruptions. A unique identifier (str id 48) is used for each test string, with a maximum length of 100 bytes. When testing the VPWS configuration over a network with significant latency, such as one with 100ms delay, performance metrics are monitored to verify that the system can handle increased load.\n\nThis test is triggered by establishing a flow of 500 cubic feet per minute between two endpoints in the VPWS.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nFlap Tests cfm over VPWS - scale over vpws with 100ms and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 500 maid no domain string add remove scale 100ms",
                "Procedure": "This test verifies the operation of a CFM (Connectivity Fault Management) system by sending tests with a large amount of data (500 cfm) over a VPWS (Virtual Private Wire Service) connection, which has been scaled up with an add/remove interface to simulate a network configuration change. The test checks that the CFM session remains active and functioning correctly after this change, by verifying the response time, local MEP details, and traffic flow.\n\nThis test is triggered by VPWS verify scale 500 cfm add remove members no domain service str id 48 byte maid string.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 500 maid no domain string unconfig config",
                "Procedure": "The test verifies the unconfiguration and reconfiguration of global CFM configuration on two Provider Edge (PE) devices, which involves configuring and then unconfiguring CFM domains on both devices, restoring a CFM session, and verifying that traffic flows properly. This test is triggered by the Configuration: CFM line.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers maid no string no domain",
                "Procedure": "The test verifies that the CFM (Connectivity Fault Management) feature is functioning as expected. To accomplish this, both Provider Edge routers must have CFM configured on them. The test then checks to see if a CFM session has been established and is operational. Next, it performs various triggers such as \"rpfo\", \"lc-reload\", \"unconfig_rollback_cfm\", and \"removeaddintf\". After these triggers are executed, the test verifies that the CFM session remains up and working.\n\nThis test is triggered by VPWS verify scale 500 cfm.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"unconfig_domain_cfm_uut\" and \"unconfig_domain_cfm_peer\" and \"rpfo\" and \"removeaddintf\" and \"unconfig_rollback_cfm\" and \"lc_reload\"",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 500 maid no string no domain flap members",
                "Procedure": "The VeriWave Protocol Walk-String (VPWS) verifies a scale of 500 cubic feet per minute for FLAP members that do not have domain service or an ID, using a 48-byte maid string. Tests are conducted to see how the VPWS performs in scenarios where cfm values exceed those specified by the standard. The configuration is set up with CFM.\n\nThis test is triggered by the need to verify the performance of VPWS under extreme flow conditions, where cfm rates exceed the recommended scale of 500 cubic feet per minute.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nFlap Tests cfm over VPWS - scale over vpws with 100ms and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 500 maid no string no domain add remove scale 100ms",
                "Procedure": "This test verifies the operation of CFM (Connectivity Fault Management) over VPWS (Virtual Private Wire Service), including adding and removing members, when no domain service or ID is present. It checks for CFM with Tests cfm over VPWS - scale over vpws with 100ms Add Remove - CFM Tests cfm over VPWS - scale over vpws with 100ms Configuration done in setup - Add Remove interface  scale over vpws - Verify if CFM session is up and working - Verify ping, local MEP (Management Entity Portal) details and traffic. This test is triggered by a configuration of CFM with 500 cfm add remove members no domain service no id 48 byte maid string.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Teacat cscvu25670",
                "Procedure": "The test for Teacat CSCvu25670 verifies that a network is configured correctly. It involves configuring Continuity Fault Management (CFM) on both processing engines (PEs) of two interfaces, setting up Service Level Agreements (SLAs) with Loss Measurement Monitoring (LMM) globally and attaching them to the interfaces, and configuring loss measurement aggregates on the interfaces. The test then checks that CFM sessions are active and that packet loss is 0% and the result count matches the packet count.\n\nThis test is triggered by verifying Teacat CSCvu25670 - Configure CFM on both PEs on 2 interfaces - Configure SLA LMM globally and attach to the interfaces - Configure Loss Measurement Aggregate on interfaces.",
                "Pass/Fail Criteria": "Ethernet sla statistics interface verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify if CFM session is up for both interfaces on both PE's verification is performed.\nwhether packet loss is 0 and result count is equal to packet count or not verification is performed.\nshow command used :- show ethernet sla statistics <int> statistic operation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfd cscvm04081",
                "Procedure": "The test verifies the BFD flap on a CFD CSCvm04081 by verifying that a BFD session is up after re-applying CFM config. This test is triggered by configuring BFD and CFM on both PEs, checking the Down Mep Status, removing and re-adding CFM config, and comparing the number of times the BFD session is up before and after applying CFM config again.",
                "Pass/Fail Criteria": "Bfd session detail interface verification is performed.\nOspf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nCfm peer meps verification is performed.\nOSPF, MPLS LDP, Xconnect , CFM verification is performed.\nBFD Flap after removing and re-applying CFM verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfd cscvj04698",
                "Procedure": "This test verifies that SNMP statistics for a specific OID are correct after bringing down 1000 CCM sessions using CFM. To test this, an SNMP walk is performed on the OID -1.3.111.2.802.1.1.8.1.7.1.1.7 to verify that the statistics are accurate.\n\nThis test is triggered by a user bringing down 1000 CCM sessions using CFM.",
                "Pass/Fail Criteria": "Snmp statistics slow oid verification is performed.\nOspf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nCfm peer meps verification is performed.\nSnmp community verification is performed.\nOSPF, MPLS LDP, Xconnect , CFM , SNMP verification is performed.\nsnmp statistics slow oid verification is performed.\nIf any oids are present in snmp statistics slow oid, test case will fail, else pass verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bugcscvj72944",
                "Procedure": "The test checks if a problem is fixed by verifying the cfmd process can be restarted. The configuration for this test involves setting up cfm with sla, noting down the number of times the cfmd process should respawn when it crashes, reloading the system, and then checking that the respwan count value is correct.\n\nThis test is triggered by CSCvj72944.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_oir\"",
                "Pass/Fail Criteria": "Process info verification is performed.\nOspf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nCfm peer meps verification is performed.\nOSPF, MPLS LDP, Xconnect , CFM verification is performed.\nCFM: Verify cfmd process it is restarted or not verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bugcscvp00991 bugcscvr70937",
                "Procedure": "To verify that show efd interfaces and down mep status displays correctly after a Local Control (LC) and Router reload, configure C-FORCE (CFM) on subinterfaces with ingress pop1, and enable Enhanced Flexible Fabric Services (EFD). This test is triggered by the presence of bugs CSCvp00991 and CSCvr70937.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_oir\" and \"router_reload\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nOspf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nEfd interface verification is performed.\nospf, mpls ldp , xconnect , cfm , efd interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfd cscvr89623",
                "Procedure": "To verify the resolution of CDETS CSCvr89623, the test verifies that a device configured for CFM UP MEP and with Sla can be properly monitored using an SNMP walk. After removing the domain from the CFM configuration and reconfiguring the UP MEPP, another SNMP walk is performed to confirm correct SNMP output.\n\nThis test is triggered by the bug CSCvr89623.",
                "Pass/Fail Criteria": "Ospf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nSnmp community verification is performed.\nCfm peer meps verification is performed.\nSnmp output verification is performed.\nCFM: Verify SLA MIB returns output verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle main basic verification",
                "Procedure": "CFM Bundle Main verification involves configuring CFM on both PEs, verifying session types for timers, including a 1-second timer, and checking peer and local MIP details. Additionally, it verifies the offload types of local MEPs, runs Cfm ping and traceroute to ensure proper communication, and confirms that traffic is flowing correctly.\n\nThis test is triggered by configuration changes in the CFM Bundle Main.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nCfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM peer meps and local meps verification is performed.\nCFM: Ping and traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers bundle main downmep",
                "Procedure": "The CFM bundle main down test verifies the functionality of a CFM setup that includes triggers for active preloading and resource pool fetching operations. The configuration, which was already set up in a previous test case, involves performing these triggers while checking if the CFM session is established and working properly.\n\nThis test is triggered by the configuration of CFM with active preload and rpfo (resource pool fetching operation) triggers already performed.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"activerpreload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers bundle main upmep",
                "Procedure": "The CFM Bundle Main UpMep performs tests using the following triggers: xrvmreload and hwmodulereload. This test verifies that CFM is functioning properly when these triggers are used, building on the configuration already established in a previous testcase. It does this by first executing the triggers, and then verifying that the CFM session has been successfully started and is working as expected.\n\nTrigger sentence: This test is triggered by using xrvmreload and hwmodulereload to verify the operation of the CFM session with previously completed configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"xrvmreload\" and \"hwmodulereload\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm process restart bundle main",
                "Procedure": "CFM Bundle Main with process restart tests the configuration of a network. To verify that it's functioning correctly, configure CFM on both Processing Engines, then check to see if the CFM session is established and active. Next, perform a process restart, after which you should confirm that the CFM session remains intact. This test is triggered by verifying that the CFM configuration on both PEs remains operational even after a process has been restarted.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_name: \"CfmApBase.get_proc_list_bundle(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap bundle members main",
                "Procedure": "When flapping the bundle members, you should also check the CFM session status for both UPMEP and DOWNMEP. The test procedures involve flapping the bundle members and verifying the CFM session status. In terms of configuration, it is essential that the CFM is done.\n\nThis test is triggered by changes to either the UPMEP or DOWNMEP bundle member configurations.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nFlap the bundle members and check cfm is up and working verification is performed.\nCFM ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check bundle members add remove main",
                "Procedure": "The configuration for testing the Connection Framework Manager (CFM) bundle main with bundle members involves adding and removing bundle members. This test verifies that CFM works correctly when these operations are performed in a specific sequence, including checking that the CFM session remains active throughout. It is triggered by CFM Bundle Main Configuration done.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bundle main",
                "Procedure": "The configuration and unconfiguration of the CFM (Connectivity Fault Management) domain are tested in this scenario. The test involves configuring CFM on both Provider Edge (PE) devices, then unconfiguring the CFM domain on both PE's and reconfiguring it afterwards. Verification steps include checking if a CFM session is restored and confirming that traffic flows properly.\n\nThis test is triggered by configuration of the CFM domain on the PEs.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of cfm domain verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bundle main int",
                "Procedure": "The test involves verifying the configuration of a network with CFM (Connectivity Fault Management) bundles. To begin, CFM must be configured on both peers and then unconfigured at the interface level. After this, CFM should be reconfigured at the interface level, after which it's necessary to verify that any dropped CFM sessions are restored and that traffic is flowing normally through the network.\n\nThis test is triggered by a change in the CFM configuration settings.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm with unconfig config l2vpn bundle main",
                "Procedure": "The test checks the operation of CFM (Connectivity Fault Management) on a specific configuration of L2VPN, which involves Unconfiguration and re-Configuration of L2VPN services between two Provider Edge devices. This process includes disabling and then re-enabling L2VPN on both PE's, and verifying that the CFM session is restored and traffic continues to flow properly.\n\nThis test is triggered by a specific combination of configuration settings related to Unconfiguration Configuration within an l2vpn context.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of l2vpn on both PE's verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm 100ms bundle main",
                "Procedure": "CFM Bundle Main 100ms interval verification involves configuring CFM on both PEs, verifying session types for a timer of 100ms, and checking CFM peer MEPs. Additionally, verify CFM peer MEP detail, CFM local MEP detail, offload types, Cfm ping and traceroute, and ensure that traffic is flowing properly.\n\nThis test is triggered by configuration changes to the CFM settings on both PEs.",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM peer meps and local meps verification is performed.\nCFM: Ping and traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle member links",
                "Procedure": "CFM on Bundle Member Links tests verify the operation of Ethernet CFM (Connectivity Fault Management) on bundle member links. To do this, it first unconfigures any previous global and interface level CFM configurations. It then configures CFM on bundle member links on both Provider Edge devices, verifies that the CFM session is up, and checks details for ethernet peer Maintenance End Point Entity (MEP) and local MEP.\n\nThis test is triggered by the Configuration: CFM on Bundle Member Links.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify if CFM session is up verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle sub verification",
                "Procedure": "The test verifies the basic functionality of a CFM Bundle Subinterface, both when sending and receiving traffic. To do this, it configures CFM on both PEs, then checks for correct session types, including a timer of 1 second, and verifies peer and local MEP details, as well as offload types. Additionally, it uses Cfm ping and traceroute to test connectivity, and confirms that traffic is flowing properly throughout.\n\nThis test is triggered by the Configuration: CFM done in setup.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nCfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps verification is performed.\nL2VPN verification is performed.\nCFM: Verify CFM peer meps and local meps verification is performed.\nCFM: Ping and traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle upmep with rewrite ingress ping traceroute check cscvw01064",
                "Procedure": "CFM is configured to use a rewritten ingress configuration, which has been set up on both Provider Edge (PE) devices. The ingress configuration on the Bundle Subgroup Access Circuit (AC) and other ACs has also been modified accordingly. To ensure that the CFM peers are functioning correctly, a verification of the peer Multi-Point Encapsulation (MEP) is performed, followed by pinging and tracerouting to test connectivity.\n\nThis test is triggered by the presence of a Configuration: CFM with rewrite ingress config.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM status verification is performed.\nCFM: Ping and traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers bundle sub downmep",
                "Procedure": "The CFM configuration has been previously set up, and this test checks the functionality of the CFM system by performing two specific triggers: activepreload and rpfo. It then verifies that a valid CFM session is established and operational.\n\nThis test is triggered by the execution of the 'activerpreload' and 'rpfo' events.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"activerpreload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nL2vpn xconnect summary verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers bundle sub upmep",
                "Procedure": "The CFM Bundle Sub UpMep with triggers test verifies the functionality of CFM with triggers by reloading the xrv module and the hwmodule, then checking that the CFM session is up and working. This test is triggered by a pre-existing configuration for CFM that was already set up in a previous testcase.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"xrvmreload\" and \"hwmodulerelaod\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm process restart bundle sub",
                "Procedure": "To verify CFM with process restart, configure CFM on both Process Engines. Then, verify that the CFM session is established and functioning correctly. Next, perform a process restart. Finally, check again that the CFM session remains operational.\n\nThis test is triggered by the configuration of CFM on two Process Engines.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_name: \"CfmApBase.get_proc_list_bundle(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap bundle members sub",
                "Procedure": "When checking the status of a bundle member, be sure to verify the cfm status for both upmep and downmep configurations. Additionally, test procedures involve flapping the bundle members and confirming that the cfm session is intact for all bundle subscribers. The configuration has also been checked, with cfm successfully completed.\n\nThis test is triggered by checking the cfm status of a bundle member's configuration in both upmep and downmep scenarios.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nFlap the bundle members and check cfm is up and working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check bundle members add remove sub",
                "Procedure": "The tests verify the CFM bundle's functionality in combination with bundle members, specifically for adding and removing both upstream (upmep) and downstream (downmep) members. The test checks if a CFM session is established and functioning properly after configuration of the main CFM bundle and addition or removal of bundle members.\n\nThis test is triggered by: Configuration: CFM",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bundle sub",
                "Procedure": "The test verifies the unconfiguration and reconfiguration of a CFM domain, ensuring that a CFM session is successfully restored and traffic flows properly after unconfiguring and then reconfiguring the domain on both PEs. This test is triggered by the need to verify the proper functioning of the CFM configuration process when it is intentionally disabled and re-enabled.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of cfm domain verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bundle sub int",
                "Procedure": "The CFM Bundle Sub Interface Unconfiguration Configuration test involves verifying the unconfiguration and reconfiguration of CFM on two PEs, ensuring that CFM sessions are restored and traffic flows properly.\n\nThis test is triggered by a Configuration change for upmep & downmep.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm with unconfig config l2vpn bundle sub",
                "Procedure": "The configuration includes verification that the CFM (Connectivity Fault Management) feature is operational on an L2VPN in a specific test setup. To perform this test, the L2VPN is first unconfigured on both Provider Edge routers, and then reconfigured again. Following this, it is verified that the CFM session has been successfully restored and that traffic is flowing as expected.\n\nThis test is triggered by verification of proper CFM functionality after changes to L2VPN configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of l2vpn on both PE's verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm 100ms bundle sub",
                "Procedure": "CFM Bundle Sub 100ms interval verifies the functionality of CFM on both PEs. The test begins by configuring CFM on both devices, followed by verifying session types for timers at a 100ms interval. It then checks the CFM peer meps and their details, as well as the CFM local meps detail and offload types. Additionally, it conducts CFM ping and traceroute tests to ensure that traffic is flowing properly.\n\nThis test is triggered by verifying the correct operation of the CFM Bundle Sub 100ms interval configuration on both PEs, which involves configuring CFM with a sub-LACPM timer interval set to 100ms.",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM peer meps and local meps verification is performed.\nCFM: Ping and traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main basic verification",
                "Procedure": "The CFM basic verifications are performed for both physical and bundle main. This test verifies that the configuration, which includes setting up CFM on both PEs, allows peer MEPS to be verified in detail, as do local MEPS with their offload types. Additionally, traffic flows properly when configured according to CFM settings. This test is triggered by a configuration of CFM.",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM peer meps verification is performed.\nCFM peer meps detail verification is performed.\nCFM local meps detail and offload types verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main ping",
                "Procedure": "The test confirms that the CFM (Connectivity Fault Management) ping is functioning correctly, verifying connectivity between network devices. This test is triggered by a configuration of CFM on both PEs (Provider Edge routers) set up beforehand and involves checking that CFM pings are successfully initiated from both the source MEP-ID (Maintenance Association End Point Identifier) and interface.",
                "Pass/Fail Criteria": "CFM: Verify CFM ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main traceroute",
                "Procedure": "CFM (Connectivity Fault Management) traceroute tests for l3 physical and bundle main connectivity. This test verifies that the CFM traceroute function works as expected, first by configuring CFM on both ends of the connection in the setup phase, then verifying that a traceroute is successful when the source MAC endpoint ID matches an interface, and again when it does not match, ensuring that traffic flows properly throughout the process. Configuration: CFM\n\nThis test is triggered by the need to verify proper CFM connectivity between two devices.",
                "Pass/Fail Criteria": "CFM: Verify CFM traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config l3 main",
                "Procedure": "The test for unconfiguring and reconfiguring a CFM domain involves several steps. Initially, the physical and bundle main interfaces are configured to support CFM, but this configuration is then undone on both peers (PEs). Next, the CFM domain is reconfigured on both PEs. The test then verifies that the CFM session has been successfully restored by checking if traffic flows properly through the network.\n\nThis test is triggered by a Configuration event.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of cfm domain verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main interface flap",
                "Procedure": "To verify the operation of C-FM (Connectivity Fault Management) with an interface flap, configure it on both endpoints and confirm that a CFM session is established. Then, manually bring down the interface, check that the CFM session recovers successfully, and ensure data transmission continues unimpeded.\n\nThis test is triggered by the need to verify C-FM connectivity in scenarios where network interfaces are subject to manual disconnection or flap events.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with interface flap verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 flap bundle members main",
                "Procedure": "Flap the bundle main members and check the cfm status. The test procedures call for flapping the bundle members to verify that everything is functioning properly, with a particular focus on checking the cfm session status. In order for the configuration to be complete, the CFM Bundle Main Up Mep must first be implemented.\n\nThis test is triggered by flapping the bundle main members and checking the cfm status.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nFlap the bundle main members and check cfm is up and working verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 bundle members add remove main",
                "Procedure": "This test verifies that the Content Flow Manager (CFM) is properly configured to add and remove bundle members, and that the CFM session is operational. The configuration for this test includes enabling CFM with bundle members Add Remove - CFM Bundle Main Configuration done - Add Remove Bundle Members - Verify if CFM session is up and working.\n\nTriggered by: This test is triggered by the main down state of the Mep with Bundle Members Add/Remove.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 process restart main",
                "Procedure": "CFM physical and bundle main processes are tested with process restart by configuring CFM on both processing engines as part of the setup. The test then verifies that a CFM session is active and functioning correctly before restarting the process, after which it checks again to confirm that the session remains operational.\n\nThis test is triggered by the verification that all necessary configuration steps have been completed.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_name: \"CfmApBase.get_proc_list_bundle(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main triggers",
                "Procedure": "This paragraph and the rewritten trigger sentence are below:\n\nTo verify the Level 3 Content Flow Management (CFM) system with triggers, we first assume that the CFM configuration has already been set up in a previous test case. We then perform the triggers, specifically activating the active preloading feature and the request processing for objects (RPFo). Finally, we check if the CFM session is functioning correctly.\n\nThis test is triggered by performing the activation of the active preload and RPFo features.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"activerpreload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main ccm 1m",
                "Procedure": "The configuration checks that the CFM (Connectivity Fault Management) service on both physical elements (PEs) is set up to use 1 meter of connectivity management (CCM). To achieve this, configure CFM on both PEs with 1m CCM, verify that a CFM session is active and functioning, and confirm that traffic flows properly. This test is triggered by the need to configure CFM on both PEs with 1m CCM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 1m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main ccm 10s",
                "Procedure": "This paragraph and the trigger sentence are:\n\nCFM Physical Main with 10s CCM is verified in this test. The configuration involves configuring CFM on both processing engines (PEs) to use a 10-second continuous control and management protocol (CCM) period, verifying that a CFM session is up and working, and checking if traffic is flowing properly.\n\nThis test is triggered by the need to configure CFM on both PEs with 10s CCM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10s CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main ccm 100ms",
                "Procedure": "CFM is configured on both physical main and bundle main with a CCM interval of 100 milliseconds. The configuration involves setting the CCM interval to 10 seconds on both points of Ethernet (PEs). The test verifies that a CFM session is established and functioning, as well as checks for proper traffic flow. Configuration: Configure CFM on both PEs with 10s CCM.\n\nThis test is triggered by configuring CFM on both physical main and bundle main with a CCM interval of 100 milliseconds.",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM with 100ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 main ccm 10ms",
                "Procedure": "To verify the operation of a CFM (Connectivity Fault Management) physical main with a 10ms cycle cell management, configure the CFM on both ends of the network to use a 10ms CCM (cycle cell management). Then check that a CFM session is established and functioning correctly. Next, confirm that traffic is flowing properly through the connection. The test setup includes configuration information for CFM.\n\nThis test is triggered by configuring CFM on both physical entities with a 10ms cycle cell management.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config l3 main int",
                "Procedure": "When verifying the configuration of the CFM Interface Unconfiguration, the following steps are taken: Configure CFM on both PEs and ensure it is done successfully. Then, unconfigure CFM at the interface level on both devices, followed by reconfiguring it in the same manner. The test then checks if a CFM session is restored after these operations. Finally, verification is made that traffic is flowing properly. This test is triggered by the configuration of CFM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub basic verification",
                "Procedure": "This paragraph describes a test that verifies the basic functionality of CFM (Connectivity Fault Management) on two physical entities. The test assumes that the necessary configuration has already been set up, and it checks several specific aspects of CFM, including peer maintenance entity pointers (meps), MEP detail, local MEPs, and offload types. To complete this test, traffic must be flowing properly between the two PEs.\n\nThis test is triggered by a configuration: CFM",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps verification is performed.\nCFM peer meps detail verification is performed.\nCFM local meps detail and offload types verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub ping",
                "Procedure": "To verify CFM functionality, configure CFM on both PEs according to the setup, then check that a ping from one device's source MAC address to another device's interface ID works correctly. Also test pinging an interface as the source and ensure normal traffic flow is maintained throughout these operations.\n\nThis test is triggered by verifying the configuration of CFM on both Provider Edge (PE) devices in the setup.",
                "Pass/Fail Criteria": "CFM: Verify CFM ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub traceroute",
                "Procedure": "To perform this test, the equipment must be configured for physical and bundle sub interfaces using CFM traceroute. This test verifies that CFM traceroute is functioning correctly. It is triggered by configuring CFM on both PEs in the setup, then verifying that traffic is flowing properly between them using several different methods: first, with a source mep-id and interface; second, with just a source interface; and finally, confirming that all components are working as expected with the configuration set to use CFM.",
                "Pass/Fail Criteria": "CFM: Verify CFM traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config l3 sub",
                "Procedure": "When the configuration of a cfm domain becomes unconfigured, then reconfigured, this test verifies that all CFM sessions are successfully restored and traffic continues to flow normally between devices.\n\nThis test is triggered by an event in which the configuration of a cfm domain becomes unconfigured, then reconfigured.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of cfm domain verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config l3 sub int",
                "Procedure": "When verifying the CFM Interface Unconfiguration Configuration, we configure CFM on both PEs, unconfigure it at the interface level on both devices, and then reconfigure it again. We also verify that a CFM session has been successfully restored and that traffic is flowing properly. This test is triggered by the configuration of CFM settings for physical and bundle sub-interfaces.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub interface flap",
                "Procedure": "The test for L3 CFM Physical & Bundle Sub with interface flap verifies the correct operation of a Critical Function Module. It involves configuring CFM on both PEs, verifying that a session is established and functioning as expected, triggering it by performing an interface flap to simulate a network disturbance, and then checking that traffic continues to flow properly.\n\nThis test is triggered by an interface flap.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with interface flap verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 flap bundle members sub",
                "Procedure": "When checking the status of a CFM bundle in main engine power (MEP) configuration, first flap the bundle members. Then, verify that the CFM session is active. This test is triggered by a change to the system's CFM bundle configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nFlap the bundle main members and check cfm is up and working verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 bundle members add remove sub",
                "Procedure": "The test for the L3 CFM Bundle Sub Down MEP with Bundle Members Add/Remove verifies that a CFM session is set up and functioning properly. This involves checking that the main configuration of the CFM bundle has been done, that bundle members can be added and removed, and that the CFM session is operational. This test is triggered by verifying if the CFM session is up and working with Bundle Members Add/Remove - CFM Bundle Main Configuration done - Add Remove Bundle Members.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 process restart sub",
                "Procedure": "CFM physical and bundle sub with process restart is verified through a series of steps. This test first confirms that CFM has been configured on both PE devices as set up in the initial configuration, then verifies that a CFM session is established and functioning properly. Next, it triggers a process restart to simulate an unexpected system failure, after which it checks again to ensure the CFM session remains active and operational.\n\nThis test is triggered by performing a process restart on the PE devices configured for CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_name: \"CfmApBase.get_proc_list_bundle(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub triggers",
                "Procedure": "The test verifies L3 CFM with triggers, assuming the configuration has already been completed in a previous test case. The test proceeds by performing triggers, specifically reloading XRVM and HW module. It then checks that the CFM session is active and functioning correctly.\n\nThis test is triggered by an existing CFM configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"xrvmreload\" and \"hwmodulerelaod\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub ccm 1m",
                "Procedure": "The test verifies the operation of CFM Physical Sub with a CCM of 1 meter. It involves configuring CFM on both peer elements (PEs) using a CCM of 1 meter, then verifying that the CFM session is established and functioning correctly. Traffic flow is also checked to ensure it's proceeding as expected. This test is triggered by the need to confirm proper operation of CFM Physical Sub with 1m CCM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 1m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub ccm 10s",
                "Procedure": "The test verifies the operation of CFM (Connectionless OAM) in a Physical Sub Layer scenario, specifically with a 10 second Configuration Change Management (CCM) period. This involves configuring CFM on both ports of an entity, verifying that the session is up and working, and confirming that traffic flows properly between them.\n\nThis test is triggered by the need to verify the proper functioning of CFM Physical Sub Layer with 10s CCM configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10s CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub ccm 100ms",
                "Procedure": "CFM Physical Sub and Bundle Sub are tested with a 100ms Cycle Composition Measurement (CCM) period. The test verifies that the configuration works as expected, where CFM is configured on both Provider Edge (PE) devices with a 10-second CCM. This test is triggered by: Configure CFM on both PEs with 10s CCM to verify if the CFM session is up and working, and that traffic flows properly through the network, which is set up according to the specified Configuration: CFM",
                "Pass/Fail Criteria": "Cfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM with 100ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm l3 sub ccm 10ms",
                "Procedure": "CFM sessions are verified between two physical switches with a delay of 10 milliseconds for the CCM (Clock Management) protocol. This test involves configuring CFM on both physical edge ports, confirming that the session comes online, and ensuring that data flows normally through it.\n\nThis test is triggered by the configuration of the network devices to enable CFM with a specific clock management interval.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm peer meps detail verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with 10ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 100ms",
                "Procedure": "The test verifies that configured CFM (Connectivity Fault Management) settings are correctly applied to scaled sessions between R1 and R2, which have been set up beforehand. The verification involves checking the CFM summary, peer MEPs, local MEPs, CFM ping with source MEP-ID and interface, and ensuring that traffic is flowing properly.\n\nThis test is triggered by a configuration change involving the Configure CFM down-MEPS setting for scaled sessions between R1 and R2.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 100ms triggers",
                "Procedure": "The test involves verifying that the CFM (Connectivity Fault Management) feature with triggers is functioning correctly. To achieve this, the setup includes configuring the CFM already, and then performing a series of actions: executing triggers such as activerpreload and rpfo. The verification process checks if the CFM session has been established and is working properly by examining ping responses, local Mep details, and network traffic levels.\n\nThis test is triggered by activating the 'activerpreload' and 'rpfo' triggers in the setup.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"activerpreload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nL2vpn xconnect summary verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 100ms process restart",
                "Procedure": "CFM Bundle Down Meps Scale with process restart testing involves verifying the configuration of CFM on both Processing Engines (PEs) during setup, ensuring a functioning CFM session. The test proceeds by restarting the process, then verifying that the CFM session remains operational and functional. Further checks are made to confirm proper network connectivity via ping, local MEP details, and ongoing traffic.\n\nThis test is triggered when the configuration of CFM on both PEs done in setup changes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_name: \"CfmApBase.get_proc_list_bundle(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 100ms flap members",
                "Procedure": "To check the CFM status of the bundle members, first flap the CFM Down Mep Scale Bundle and then check the CFM status. \n\nThis test is triggered by checking the CFM status after flapping the Down Mep Scale Bundle.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nFlap the bundle members and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle members add remove downmeps scale 100ms",
                "Procedure": "The test checks the operation of CFM with bundle members that have been added or removed, confirming that the CFM session is active and functioning properly. This test is triggered by a configuration change involving the bundle scale, particularly when adding or removing members from the bundle, as well as any changes to the CFM bundle scale configuration.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bundle downmeps scale 100ms",
                "Procedure": "The test verifies the unconfiguration and reconfiguration of a global CFM configuration, which involves configuring and then unconfiguring CFM on both Provider Edge (PE) devices, and verifying that the CFM sessions are restored and traffic flows normally. This test is triggered by the requirement to verify the proper handling of CFM configuration changes in an unconfigured state.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 1s",
                "Procedure": "CFM Bundle Down Meps scale sessions with 1s timer. This test verifies the configuration of CFM (Connectivity Fault Management) for scaled sessions between R1 and R2, which are done in setup. It checks the CFM summary, peer meps, and local meps to ensure proper connectivity. Additionally, it verifies that a ping from the source MEP-ID is successful on the specified interface, and that traffic is flowing as expected. The configuration being tested includes CFM settings. This test is triggered by scaling Meps in bundle sessions with a 1s timer.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 1s triggers",
                "Procedure": "The test confirms that the CFM bundle with triggers is functioning correctly. The configuration has already been set up, including CFM setup. To perform the test, the system executes the triggers by running xrvmreload and hwmodulereload commands. Once the triggers are executed, the test verifies whether the CFM session is established and operational by checking for a working ping, local Mep details, and traffic. \n\nThis test is triggered by performing the 'xrvmreload' and 'hwmodulereload' commands.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"xrvmreload\" and \"hwmodulerelaod\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 1s process restart",
                "Procedure": "The test verifies the operation of CFM Bundle Down Meps Scale with a process restart. This is triggered by configuring CFM on both PEs as part of setup, verifying that the CFM session is up and working, performing a process restart, re-verifying the session, and checking for proper ping, local mep details, and traffic configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_name: \"CfmApBase.get_proc_list_bundle(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 1s flap members",
                "Procedure": "To use the CFM Down Mep Scale Bundle members, you need to flap them and check their CFM status. The test procedure involves flapping the bundle members and checking the CFM session. For configuration, the CFM is used.\n\nThis test is triggered by flapping the CFM Down Mep Scale Bundle members.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm local meps detail verification is performed.\nFlap the bundle members and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle members add remove downmeps scale 1s",
                "Procedure": "A test to verify the operation of a CFM (Connectivity Fault Management) bundle, which consists of multiple members that can be added or removed. The configuration includes setting up the CFM bundle scale, adding and removing members as needed, verifying that the CFM session is functioning correctly, and checking local Mep details, traffic, and ping.\n\nThis test is triggered by a change in the Bundle Members Add/Remove Configuration for the Connectivity Fault Management (CFM) Bundle Scale.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bundle downmeps scale 1s",
                "Procedure": "The test for the configuration of global CFM involves verifying that a CFM session can be successfully re-established after being unconfigured. This process includes configuring and unconfiguring CFM on both PEs, then reconfiguring it, and confirming that traffic flows properly throughout.\n\nThis test is triggered by the Unconfiguration Configuration of Global CFM config.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vpls cfm ccm 100ms",
                "Procedure": "CFM (Connectivity Fault Management) is tested over VPLS (Virtual Private LAN Service) with a 100ms Cycle and Transmission (CCM). The test verifies that the CFM session comes up and is functioning correctly, and that traffic flows normally. To accomplish this, CFM must be configured on both Provider Edge routers with a 100ms CCM, after which it should be verified that the CFM session is operational.\n\nThis test is triggered by CFM being enabled on both provider edge routers with 100ms cycle and transmission timers.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 100ms CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Baseline verification hwoffload phy",
                "Procedure": "The test performs basic verifications on OSPF, L2VPN, and MPLS for physical subcarrier CFM hardware. It checks that OSPF is operational, MPLS is active, and L2VPN is up and running.\n\nThis test is triggered by the completion of the OSPF, L2VPN, and MPLS configuration in the setup class.",
                "Pass/Fail Criteria": "Ospf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nOSPF, MPLS and L2VPN to be up verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload 100ms 3 3ms timers",
                "Procedure": "The test verifies the basic functions of Hardware Offload on Physical Sublayers for both uplink and downlink Meps, using timers of 100ms and 3.3ms. This test confirms that CFM (Connectivity Fault Management) is functioning correctly by configuring it on both endpoints of a VPWS network, checking peer Multipoint Endpoints, local maintenance points, and detailed information about local Multipoint Endpoints via the 'show ethernet cfm local meps detail' command. The test also verifies connectivity by pinging and performing traceroutes, as well as ensuring that traffic is flowing properly over the CFM connection.\n\nThis test is triggered by configuring CFM on both PEs of a VPWS network with AC-to-pw and AC-AC connections.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"100ms\" and \"3.3ms\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload reloads",
                "Procedure": "The test verifies the basic functions of CFM (Connectivity Fault Management) by configuring it on both Provider Edge routers in a Virtual Private Wire Service network, verifying peer maintenance points, local maintenance points, and detailed information about local maintenance points. It also checks for proper traffic flow using ping and traceroute commands and verifies that connectivity fault management is functioning correctly.\n\nThis test is triggered by the verification of CFM basic functions on a VPWS network.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload_upmep\" and \"lc_reload_downmep\" and \"router_reload\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload process restart",
                "Procedure": "CFM (Connectivity Fault Management) is tested on Physical Substrate with Hardware Offload for both up and down MEPs during process restart. The test first configures CFM on both ports of each PE on a VPWS network, connecting AC to PW and AC-AC. It then verifies the existence of peer MEPs, local maintenance points, and displays details about local MEPs with the \"show ethernet cfm local meps detail\" command. Finally, it performs ping and traceroute tests using CFM and confirms that traffic is flowing correctly.\n\nThis test is triggered by a process restart on a network device configured for hardware offload of Connectivity Fault Management (CFM) functionality on Physical Substrate with both up and down Multi-Point End Points (MEPs).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_hwoff_proc_list(ApData=CfmApBase.zap, process_list='process_list2')\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload process crash",
                "Procedure": "CFM basic verifications are tested by verifying that it can be configured on both PEs in a VPWS network, where both AC to PW and AC-AC configurations are used. The test also checks for CFM peer MEPs, local maintenance points, and the details of local MEPs shown in 'show ethernet cfm local meps detail'. Additionally, ping and traceroute tests are performed using CFM, and it is verified that traffic is flowing properly throughout the network.\n\nThis test is triggered by the configuration of CFM on both PEs in a VPWS network.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_hwoff_proc_list(ApData=CfmApBase.zap, process_list='process_list2')\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload triggers",
                "Procedure": "CFM is tested on a physical subnetwork with up and down MEPs, verifying its basic functions. This test confirms that CFM performs as expected by configuring it on both PEs of a VPWS network for AC-to-PW and AC-to-AC traffic, checking peer MEPs, local maintenance points, and the details of local MEPs shown in 'show ethernet cfm local meps detail'. It also verifies that ping and traceroute operations work over CFM and ensures that traffic flows correctly. Configuration: CFM is used for this test.\n\nThis test is triggered by configuring the system to verify the basic functionality of CFM on a physical subnetwork with up and down MEPs.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_readd_intf\" and \"remove_readd_global_cfm\" and \"remove_cfm_intf\" and \"remove_readd_l2vpn\" and \"flap_interfaces\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hw offload diff rewrite encap combos",
                "Procedure": "CFM basic verifications for HWOffload on Phy Sub (Up & Down Mep) with diff rewrite and encap combos verify the proper functioning of a VPWS network. This test is triggered by configuring CFM on both PEs, setting up a connection between AC to pw and AC-AC ports, verifying peer meps and local maintenance points, checking the details of show ethernet cfm local meps, and ensuring that ping and traceroute commands work properly while also confirming that traffic flows uninterrupted.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrewrite_diff_encap: \"dot1ad_dot1q_rewrite_tag_pop\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload phy main",
                "Procedure": "The test_cfm_hwoffload_phy_main test verifies the basic verifications of HWOffload on Phy Main (Up & Down Mep) for CFM. It involves configuring CFM on both PEs in a VPWS network with AC to pw and AC-AC connections, verifying CFM peer MEPs, local maintenance points, and show ethernet cfm local meps detail commands, as well as performing ping and traceroute tests with CFM enabled to ensure proper traffic flow.\n\nThis test is triggered by configuration of CFM.",
                "Pass/Fail Criteria": "Ospf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Baseline verification hwoffload bunsub",
                "Procedure": "The test performs basic verifications on various protocols, including OSPF, L2VPN, and MPLS for Bundle Sub-CFM Hardware. It verifies that OSPF, MPLS, and L2VPN are all up and running correctly. The configuration is set up in the setup class with OSPF, L2VPN, and MPLS enabled.\n\nThis test is triggered by verifying OSPF to be up, verifying MPLS to be up, and verifying L2VPN to be up.",
                "Pass/Fail Criteria": "Ospf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nOSPF, MPLS and L2VPN to be up verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload bundlesub 10ms 3 3ms timers",
                "Procedure": "CFM basic verifications for HWOffload on Bundle Sub (Up & Down Mep) are tested with timers of 10ms and 3.3ms. This test verifies CFM basic verifications by configuring CFM on both PEs in a VPWS network, where all ACs are connected to a peer-to-peer connection or point-to-point, and then verifying the CFM peer maintenance points, local maintenance points, and show ethernet cfm local meps detail outputs. Additionally, ping and traceroute tests with CFM are performed, and it is confirmed that traffic is flowing properly. Configuration: CFM\n\nThis test is triggered by configuring HWOffload for Bundle Sub (Up & Down Mep) on a VPWS network with CFM enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"10ms\" and \"3.3ms\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload bundlesub ha",
                "Procedure": "CFM HWOffload on Bundle Sub (Up & Down Mep) with HA Triggers verifies the basic functionality of CFM. It involves configuring CFM on both PEs in a VPWS network, where AC connections are established to peer and peer-to-peer connections. The test then checks for CFM peer MEPs, local maintenance points, and details of local MEPs displayed by 'show ethernet cfm local meps detail'. Additionally, it performs ping and traceroute tests on the CFM connection to ensure proper flow of traffic. This test is triggered by the configuration of CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"activerpreload\" and \"standbyrpreload\" and \"router_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload bundlesub process restart",
                "Procedure": "CFM is tested on a Bundle Sub (Up & Down Mep) with Process Restart. The configuration involves setting up CFM on both PEs on a VPWS network, where AC connects to PW and AC-AC connections are also made. Verification of CFM peer Meps, local maintenance points, and show ethernet cfm local meps detail is conducted. Ping and Traceroute operations over CFM are performed. Additionally, the test ensures that traffic flows properly in the network.\n\nThis test is triggered by configuring CFM on both PEs on a VPWS network where AC connects to PW and AC-AC connections are also made.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_hwoff_proc_list(ApData=CfmApBase.zap, process_list='process_list2')\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload bundlesub process crash",
                "Procedure": "To test the Hardware Offload feature on Bundle Subinterfaces with Process Crash, we verify basic CFM (Connectivity Fault Management) verifications. This includes configuring CFM on both Processing Engines on a VPWS network with all AC to PW and AC-AC connections. We then verify that CFM peer MEPs are functioning correctly and check the local maintenance points. The show ethernet cfm local meps detail command is also used for verification. Traffic flow is checked using ping and traceroute, and it's verified that traffic is flowing properly. This test is triggered by a process crash in the Hardware Offload feature on Bundle Subinterfaces with Mep (Maintenance Association End Point) Up and Down states.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_hwoff_proc_list(ApData=CfmApBase.zap, process_list='process_list2')\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload bundlesub triggers",
                "Procedure": "This test verifies the basic operation of CFM. It is configured on both PEs in a VPWS network with all-to-one and one-to-one configurations, then checks that peer MEPs are correctly established, local maintenance points are verified, and the show ethernet cfm local meps detail output is as expected. The test also pings and runs traceroutes through CFM, confirming proper traffic flow. \n\nThis test is triggered by configuration of CFM on both Provider Edge routers in a VPWS network.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_readd_intf\" and \"remove_readd_global_cfm\" and \"remove_cfm_intf\" and \"remove_readd_l2vpn\" and \"flap_interfaces\" and \"flap_bundle_members\" and \"remove_readd_bundle_members\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hw offload bundlesub diff rewrite encap combos",
                "Procedure": "CFM basic verifications for HWOffload on Bundle Sub (Up & Down Mep) with diff rewrite and encap combos are tested. This test is triggered by a configuration that includes configuring CFM on both PEs on a VPWS network, with active connections between AC-to-pw and AC-AC interfaces. It then verifies the presence of peer MEPs, local maintenance points, and displays details about local MEPs using the \"show ethernet cfm local meps detail\" command. Additionally, it checks that CFM can be pinged and tracerouted, and ensures that traffic is flowing properly between the two devices.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrewrite_diff_encap: \"dot1ad_dot1q_rewrite_tag_pop\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwwofload bundlesub with cos",
                "Procedure": "This test verifies the basic function of CFM on a VPWS network, both with access to pseudo-wires (AC to PW) and between access circuits (AC-AC). To set this up, configure CFM on both provider edge routers. Then, verify that the peer multi-point encap points are established, local maintenance points are functioning correctly, and the show ethernet cfm local meps detail command is displaying the expected information. Next, perform ping and traceroute tests on the CFM-enabled interfaces to confirm connectivity, and finally check that traffic continues to flow properly.\n\nThis test is triggered by configuring CFM on both provider edge routers in a VPWS network with AC to PW and AC-AC connections.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ncos_value: \"CfmApBase.get_cos_value_cfm(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload bundle main",
                "Procedure": "The test for HWOffload on Bundle Main (Up & Down Mep) verifies the basic verifications of CFM. This test is triggered by the configuration of CFM on both PEs in a VPWS network, with connectivity established between AC to pw and AC-AC links. It then checks that CFM peer Multi-Egress Points (meps), local maintenance points, and show ethernet cfm local meps detail are functioning correctly. Additionally, it verifies that traffic is flowing properly through the network by performing ping and traceroute tests for CFM.",
                "Pass/Fail Criteria": "Ospf status verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nCfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload bundle members downmep",
                "Procedure": "CFM HWOffload on Bundle Members Down Mep, Level 0 tests the basic verifications of CFM. It verifies that CFM is configured correctly on both PEs for Bundle Members down mep level 0 and checks if traffic is flowing properly. The test also includes verifying CFM peer meps, local maintenance points, and show ethernet cfm local meps detail. Additionally, it pings and performs a traceroute to ensure connectivity. This test is triggered by the presence of CFM in the configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"100ms\" and \"10ms\" and \"3.3ms\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Basic combined 1s vpws",
                "Procedure": "The test verifies the configuration of CFM (Connectivity Fault Management) on scaled sessions between two nodes (R1 and R2). The test case timer is set to 1 second. Verification steps include checking the CFM summary, peer MIPs, local MIPs, and CFM ping with a source MEP ID and interface. Additionally, it verifies that traffic is flowing properly.\n\nThis test is triggered by the configuration of CFM on scaled sessions between R1 and R2 in setup.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm config combined 1s unconfig cfm",
                "Procedure": "This paragraph verifies the CFM Interface Unconfiguration Configuration by configuring and reconfiguring CFM on two PEs in a VPLS network, unconfiguring it at the interface level, and then verifying that traffic flows properly and a CFM session is restored. This test is triggered by an action that involves a timer of 1 second, specifically the Combined Upmep and downmep Testcase.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers combined 1s",
                "Procedure": "The combined Upmep and downmep test case verifies the operation of CFM with triggers. This test is triggered by performing a series of actions on both PEs, including configuring CFM, reloading the link, unconfiguring the rollback for CFM, removing an interface, and adding another interface. The test then verifies that the CFM session remains up and working throughout this process.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\" and \"unconfig_rollback_cfm\" and \"removeaddintf\"",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm combined main 1s interface flap",
                "Procedure": "The test combines Upmep and downmep, running for 1 second with an interface flap. It verifies that CFM is functioning correctly on both PEs when the interface is flapped. The configuration involves configuring CFM on both devices, verifying the session is up and working, then flapping the interface to ensure the session remains stable, and finally checking if traffic flows properly.\n\nThis test is triggered by the configuration of CFM on two PEs with an interface flap.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with interface flap verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Basic combined 100ms vpws",
                "Procedure": "The test verifies CFM configuration, including upmep and downmep settings, for scaled sessions between R1 and R2. The setup involves configuring CFM on both devices with a timer of 100ms. After setup, the test verifies various aspects of CFM operation, including the summary, peer MEPs, local MEPs, and ping responses from a specific source MEP ID and interface. It also checks that traffic is flowing properly.\n\nThis test is triggered by verifying the successful configuration of CFM on two devices with scaled sessions using an inter-node timer of 100ms.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm combined 100ms config unconfig cfm",
                "Procedure": "This test verifies the proper operation of the CFM Interface Unconfiguration/Configuration feature by configuring and unconfiguring CFM at the interface level on two Provider Edge (PE) devices in a Virtual Private LAN Service (VPLS) network. The configuration involves setting up CFM on both PEs, then removing it, reapplying it, verifying that the session is restored, and checking for proper traffic flow.\n\nThis test is triggered by: Configuring and unconfiguring CFM at the interface level on two PE devices in a VPLS network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers combined 100ms",
                "Procedure": "CFM with triggers is tested by configuring CFM on both PEs, verifying that the CFM session is up and running, performing triggers including rpfo, lc-reload, unconfig_rollback_cfm, and removeaddintf, and then verifying again if the CFM session remains up and working. This test is triggered by the configuration of CFM in a network setup.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\" and \"unconfig_rollback_cfm\" and \"removeaddintf\"",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm combined 100ms interface flap",
                "Procedure": "The Combined Upmep and downmep Testcase timer is set to 100ms with an interface flap. The test verifies that CFM (Connectivity Fault Management) functions correctly with the interface flap enabled, by configuring CFM on both PEs (Provider Edge routers), verifying that the session is up and working, flapping the interface, verifying again that the session is still up and working, and ensuring traffic is flowing properly. The test configuration includes CFM.\n\nThis test is triggered by the need to verify the operation of CFM with an interface flap enabled on both PEs.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with interface flap verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bgp ad bundle vpls",
                "Procedure": "The test verifies that CFM (Connectivity Fault Management) is configured correctly between two devices, R1 and R2, with scaled sessions using a 100ms timer. It involves checking the CFM summary, peer MEPs, local MEPs, CFM ping with source MEID and interface, and ensuring that traffic is flowing properly.\n\nThis test is triggered by the activation of Bundle interfaces with BGP AD (Address Family) with VPLS (Virtual Private LAN Service), CFM UP MEP scale with a 100ms timer.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bgp ad vpls triggers",
                "Procedure": "The test for verifying CFM with triggers involves configuring CFM on both Provider Edge (PE) devices, checking that the CFM session is established and functioning properly, triggering a list of specific events including rapid per-flow indication (rpfo), link reload, unconfiguration rollback for CFM, and interface removal and addition, then verifying once again that the CFM session remains up and working. This test is triggered by the following conditions: Configure CFM on both PEs - Verify if CFM session is up and working - Perform triggers rpfo ,lc-reload ,unconfig_rollback_cfm,removeaddintf.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\" and \"unconfig_rollback_cfm\" and \"removeaddintf\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm summary verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle bgp ad flap members vpls",
                "Procedure": "The CFM UP MEP scale is implemented with VPLS, BGP AD, and bundle interfaces that have a 100ms timer. The configuration includes flap bundle members and checking the CFM status.\n\nThis test is triggered by the need to verify that the CFM up MEP scale functions correctly within a VPLS environment when configured with BGP autonomous domain boundaries and bundle interfaces having a 100ms timer, and involves flapping the bundle members to check the CFM session.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nFlap the bundle members and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle members add remove bgp ad vpls",
                "Procedure": "The test measures the performance of a network using the CFM protocol, specifically with bundle members that can be added or removed. It verifies that the configuration for scaling with bundle members has been set up correctly, including checking if the CFM session is active and functioning properly, and if local MEP details and traffic are working as expected. This test is triggered by a 100ms timer on the Bundle interface, which monitors changes to the bundle members.\n\nTrigger: This test verifies the performance of a network using the CFM protocol with a 100ms timer on the Bundle interface monitoring changes to bundle members.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bgp ad vpls",
                "Procedure": "The test verifies the unconfiguration, configuration, and re-configuration of global CFM (Connectivity Fault Management) settings with a 100ms timer, including bundle interfaces and BGP AD with VPLS. This test is triggered by configuring CFM on both provider edge routers, then removing it, re-configuring it, verifying that the session is restored, and checking that traffic flows properly throughout the process.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nBgp sessions verification is performed.\nBgp neighbor state verification is performed.\nBgp all all summary verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle bgp ad vpls with rewrite ingress ping traceroute",
                "Procedure": "CFM Bundle Sub Up Mep with Rewrite Ingress Config is verified. This test is triggered by a configuration where CFM (Connectivity Fault Management) is enabled on both Provider Edge routers, using VPLS (Virtual Private LAN Service) with BGP AD (Autonomous System Number), bundled interfaces, and a 100ms timer; the ingress configuration has been rewritten for Bundle Sub and all other access circuits; and the peer MEPs are verified through CFM ping and traceroute.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM status verification is performed.\nCFM: Ping and traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle downmeps scale 100ms 25738",
                "Procedure": "When testing the CFM (Connectivity Fault Management) functionality, there can be issues with session flapping after changing the primary interface, which may be related to CSCvx88556. This test triggers when a CFM Bundle Down MEPs scale sessions with a 100ms timer.\n\nThis test verifies that CFM works properly by checking for 4k sessions, shutting and unshutting the primary interface, configuring CFM down MEPs, scaling sessions between R1 and R2, verifying the CFM summary, peer MEPs, local MEPs, CFM ping with source MEID and interface, and ensuring that traffic is flowing correctly.",
                "Pass/Fail Criteria": "Spio vi location verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle vpls scale 100ms basic verification",
                "Procedure": "CFM UP MEP over Bundle VPLS scale sessions are tested with a 100ms timer. The verification process involves configuring CFM downmeps for scaled sessions between R1 and R2, which were set up earlier. It then verifies the CFM summary, peer meps, and local meps. Additionally, the test checks that CFM pings occur from the source MEP-ID and interface, and ensures that traffic is flowing properly.\n\nThis test is triggered by configuration: CFM",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle vpls scale 100ms flap members",
                "Procedure": "The CFM UP MEP over Bundle VPLS scale sessions include a 100ms timer. The sessions involve flap bundle members checking the cfm status, and this can be done by repeatedly flapping the bundle members to test the cfm session.\n\nThis test is triggered by repeated attempts by Flap Bundle members to check the cfm status of CFM VPLS Scale Bundle members.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nFlap the bundle members and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle members vpls add remove scale 100ms",
                "Procedure": "The test checks that CFM (Connectivity Fault Management) works correctly when bundle members are added or removed. This involves verifying the CFM configuration, ensuring a CFM session is established and functioning with the updated bundle membership, checking if ping responses and local MEP details are correct, and confirming that traffic flows as expected within the configured setup.\n\nThis test is triggered by a change in the bundle VPLS scale sessions with a 100ms timer.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bundle vpls scale 100ms",
                "Procedure": "Global CFM configuration involves verifying the unconfiguration of a global CFM configuration, which is achieved by configuring and then unconfiguring CFM on both provider edges (PEs). This process includes configuring CFM on both PEs, followed by unconfiguring it, reconfiguring it again, and finally verifying that traffic flows properly.\n\nThis test is triggered by the verification of a successfully configured and then reconfigured global CFM configuration.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle vpws rewrite ingress ping traceroute",
                "Procedure": "The test case is designed to verify the operation of CFM (Connectivity Fault Management) in a specific configuration. The setup involves configuring CFM on both PE (Provider Edge) devices, rewriting the ingress configuration for Bundle Sub and other ACs (Access Concentrators), and verifying the establishment of peer MEPs (Maintenance Association End Points). Additionally, the test involves running Cfm ping and traceroute operations to ensure connectivity.\n\nThis test is triggered by a timer set to 100ms, which initiates a series of configurations involving CFM with rewrite ingress configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM status verification is performed.\nCFM: Ping and traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpa reload with bundle configured",
                "Procedure": "The test verifies the reload of an MPA card on a router, checks if the bundle is brought up correctly, and tests network traffic using OSPF, IPv6, and IPv4 protocols. This test is triggered by the configuration provided for it, which includes OSPF, IPv6, and IPv4 routing protocols.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nTraffic Stats : Checks TGEN Traffic by comparing the values of RX/TX packet counts on the transmitted and received ports verification is performed.\nBundle Basic Checks verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpa shut noshut with bundle configured",
                "Procedure": "The test for the MPA card flap with a bundle configured involves verifying three main aspects. The first is that the shut/no-shut state of the MPA card on the router can be successfully toggled. Secondly, when this toggle occurs, it triggers a bringup of the bundle. Finally, once the bundle is established, it should allow traffic to flow through it. This test is triggered by changing the OSPF/IPv6/IPv4 configuration of the traffic.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nTraffic Stats : Checks TGEN Traffic by comparing the values of RX/TX packet counts on the transmitted and received ports verification is performed.\nBundle Basic Checks verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle member links cscvy91004",
                "Procedure": "When testing CFM on bundle member links, the process involves verifying that it's working correctly. To do this, previous global and interface level CFM configurations are unconfigured, and then CFM is reconfigured on both PE's for bundle member links. The test verifies that a CFM session is up, shows the correct Ethernet CFM peer MEP details, displays the correct local MEP details, and indicates whether any stale CFM configurations remain.\n\nThis test is triggered by testing CFM on Bundle Member Links Configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify if CFM session is up verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle mac main downmep",
                "Procedure": "The test, which bundles the Main Down Mep with triggers active preload and rpfo, verifies that CFM is working with triggers. It assumes that the CFM configuration has already been completed in a previous test case. The test then performs the triggers, specifically activerpreload and rpfo, and checks if the CFM session is up and functioning correctly.\n\nThis test is triggered by: CFM config already done in previous testcase.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 1k 100ms asr9k flap members",
                "Procedure": "Tests for scaling 1,000 CFM (cubic feet per minute) over Virtual Private Wire Services (VPWS) involve checking the status of the CFM in 100 millisecond intervals. Test procedures include testing CFM over VPWS by scaling over VPWS with a time interval of 100ms and monitoring the cfm status.\n\nThis test is triggered by the need to verify that the system can handle increased traffic levels of 1,000 CFM over Virtual Private Wire Services (VPWS).",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nFlap Tests cfm over VPWS - scale over vpws with 100ms and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 1k 100ms asr9k add remove scale 100ms",
                "Procedure": "The test verifies connectivity between a large number of devices over VPWS links with a 100 millisecond delay. This test is triggered by configuration done in the setup, where the Add Remove interface is configured to scale over VPWS. It checks that a CFM session is established and functioning correctly, by verifying its status, local MEP details, and traffic flow.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm vpws 1k 100ms asr9k unconfig config",
                "Procedure": "The test verifies the unconfiguration and reconfiguration of global Connection-Focused Maintenance (CFM) configuration between two provider edge devices. To achieve this, a high scale of 1,000 connections over Virtual Private Wire Service (VPWS) with an unconfigured delay of 100 milliseconds is tested. The steps involved in this test include configuring CFM on both providers' equipment, unconfiguring the CFM domain on both devices, reconfiguring the CFM domain to restore sessions, and verifying that traffic flows properly between them.\n\nThis test is triggered by a high scale of VPWS connections with an unconfiguration delay.",
                "Pass/Fail Criteria": "Cpu check verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle vpws scale 100ms flap members",
                "Procedure": "The CFM (Common Flow Measurement) test involves a scale with VPWS (Virtual Private Wire Service) on the MEP (Multiprotocol Extensions for Policy-based Routing) scale, with a timer set to 100ms. The test case also includes flapping the bundle members and checking the CFM status, as well as checking the cfm session.\n\nThis test is triggered by the configuration of the CFM UP MEP scale with Bundle Scale with VPWS.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nFlap the bundle members and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle members vpws add remove scale 100ms",
                "Procedure": "The test for checking the continuity of frames (CFM) protocol with bundle members add/remove functionality involves verifying several configurations. It starts by confirming that the CFM protocol has been set up correctly, specifically in relation to its scale configuration. The test then adds and removes bundle members as per the setup. Once this process is complete, it checks if the CFM session is functioning properly by verifying that a ping is successful and that local multi-point ether-type network (MEP) details are correct. Finally, the test monitors traffic related to the CFM protocol. This test is triggered by a timer set to 100 milliseconds.\n\nThis test verifies CFM with Bundle Members Add Remove - CFM Bundle Scale Configuration done in setup - Add Remove Bundle Members - Verify if CFM session is up and working - Verify ping , local mep details and traffic",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bundle vpws scale 100ms",
                "Procedure": "The test verifies the unconfiguration, reconfiguration, and proper functioning of a CFM (Connectivity Fault Management) domain across two Provider Edge (PE) devices. This involves configuring CFM globally, then unconfiguring it on both PEs, followed by reconfiguring the CFM domain on both devices. To ensure functionality, the test checks if the CFM session is restored and verifies that traffic flows properly between the devices. The test configuration includes setting a timer to 100ms for the testcase and utilizing the VPWS (Virtual Private Wire Service) bundle scale with MEP (Maintenance Association End Point). This test is triggered by configuring or unconfiguring CFM globally on all PEs in the network.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bgp ad bundle vpws",
                "Procedure": "The test verifies the configuration for Connectionless Operations, Administration, and Maintenance (OAM) using CFM. It involves scaling sessions between R1 and R2, verifying CFM summary, peer MEPs, and local MEPs, as well as ensuring that traffic is flowing properly. The setup includes configuring CFM downmeps with a scaled number of sessions.\n\nThis test is triggered by the configuration for Connectionless OAM using CFM on Bundle interfaces with BGP Address Family (AF) advertisement enabled, along with VPWS running with a 100ms timer.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bgp ad vpws triggers",
                "Procedure": "The test verifies the operation of CFM with triggers by configuring CFM on both PEs and verifying that the CFM session is established and functioning correctly. This involves performing a series of triggers, including rpfo, lc-reload, unconfig_rollback_cfm, and removeaddintf, while continuously verifying the status of the CFM session.\n\nThis test is triggered by configuring CFM on both Provider Edge (PE) devices in an IP/MPLS network with Virtual Private Wire Service (VPWS), Border Gateway Protocol (BGP) Auto-Discovery (AD), and Bundle interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\" and \"unconfig_rollback_cfm\" and \"removeaddintf\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm summary verification is performed.\nVerify verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle bgp ad flap members",
                "Procedure": "The Configuration for Connectionless OAM (CFM) Universal Protection (UP) Maintenance Entity Group (MEP) scale with Virtual Private Wire Service (VPWS) with Border Gateway Protocol (BGP) Autonomous System (AS) Number Advertisement (AD) using Bundle interfaces involves flapping the bundle members and checking the CFM status. Test procedures include flapping the bundle members and checking the CFM session. This test is triggered by flapping the CFM UP MEP scale Bundle members to verify proper operation of the system under fault conditions.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nFlap the bundle members and check cfm is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle members add remove bgp ad",
                "Procedure": "The configuration involves setting up a CFM bundle scale with bundle members that can be added or removed. This test verifies the operation of CFM with bundle members when they are added or removed, checking if the CFM session is functioning properly and showing correct local MEP details while also allowing traffic to pass through.\n\nThis test is triggered by the addition or removal of a Bundle Member in a Bundle Interface configuration using BGP Auto Discovery (AD) with VPWS.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM is up and working verification is performed.\nping , local mep details and traffic verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config bgp ad",
                "Procedure": "The test verifies the configuration and unconfiguration of CFM globally, including configuring CFM on both PEs, then unconfiguring and reconfiguring the CFM domain on both devices to ensure a CFM session is restored and traffic flows properly.\n\nThis test is triggered by verifying that the CFM configuration on both Provider Edge (PE) devices is set up with VPWS with BGP AD using Bundle interfaces.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nBgp sessions verification is performed.\nBgp neighbor state verification is performed.\nBgp all all summary verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of Global CFM config verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm bundle bgp ad with rewrite ingress ping traceroute",
                "Procedure": "The test checks the operation of a CFM bundle sub-up MEP with a rewritten ingress configuration. It involves configuring CFM on both provider edges (PEs), rewriting the ingress configuration on the bundle subinterface and other attachment circuits, verifying that the peer multi-point endpoints are connected, and conducting CFM ping and traceroute tests.\n\nThis test is triggered by CSCvw01064.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM status verification is performed.\nCFM: Ping and traceroute verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "cfm_bnm_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Check g8013nm bnm message",
                "Procedure": "To test G.8013 BNM messaging, send a G.8013 BNM message to the system under test and verify that the received message is in the correct format.\n\nThis test is triggered by the sending of a G.8013 BNM message.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nShow event manager environment verification is performed.\nSend G.8013BNM message and check received message format verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check bw vsm bnm message",
                "Procedure": "When sending a BW-VSM message, it's necessary to check that the received message is in the correct format. The test procedure involves sending BW-VSM traffic on the device under test (dut) and verifying the message format. No special configuration is required.\n\nThis test is triggered by the need to ensure proper formatting of BW-VSM messages sent to a device.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nShow event manager environment verification is performed.\nSend BW-VSM message and check received message format verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check bnm bandwidth less than threshold",
                "Procedure": "When sending a BNM, the test checks how the system's performance degrades when its current bandwidth is below the set threshold. This is done by running the same test at multiple levels of bandwidth restriction (levels other than one).\n\nThis test is triggered by sending a BNM with a current bandwidth less than the specified threshold.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nShow event manager environment verification is performed.\nSend BNM with current bandwidth less than threshold and check degradation behavior for different level(other than 1) by show cli & tcl script verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check bnm bandwidth more than threshold",
                "Procedure": "When sending a BNM, the current bandwidth should be above the threshold but below the normal range. The system's behavior is then checked for levels other than one. \n\nThis test is triggered by conditions where the current bandwidth exceeds the threshold but falls short of its normal operating value.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nShow event manager environment verification is performed.\nSend BNM with current bandwidth more than threshold but less than normal and check behavior by invoking EEM tcl script and show cli verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check different interfaces types degrade behaviour",
                "Procedure": "To test the physical interfaces, configure them and their subinterfaces as degraded links. Next, verify how they behave in this state. This test is triggered by a Change Firmware Message (CFM) bandwidth notification, which indicates that the network's available bandwidth has decreased.\n\n(Trigger sentence rewritten to proper English: 'This test is triggered by a change in the firmware message (CFM) bandwidth notification.')",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nCheck degraded link behaviour by show cli and logs verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check degraded bandwidth diff rbw value",
                "Procedure": "The link bandwidth should be degraded using different Radio Bandwidth Width (RBW) values, either less or more than normal. This test is triggered by degrading a previously degraded link with different reported bandwidths, rather than the original bandwidth.\n\nTrigger sentence:\nThis test is triggered by attempting to degrade a previously degraded link with different reported bandwidths, rather than the original bandwidth.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nShow event manager environment verification is performed.\nEEM Script should invoke when the reported bandwidth is less than threshold verification is performed.\nEEM Script should not invoke when the reported bandwidth is more than threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check hold in timer run state",
                "Procedure": "The system checks its current state to see if it is in the Hold-off timer run state. In this case, it receives a Bandwidth Notification Message (BNM) with a nominal bandwidth. Test procedures require that this situation be checked, and configuration settings include enabling hold off timers for cfm bandwidth notifications.\n\nThis test is triggered by receiving a BNM with nominal bandwidth while in the Hold-off timer run state.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nBandwidth should remain in OK state when nominal bandwidth is received in hold off run state and hold-off timer should stop verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check hold off timer behaviour",
                "Procedure": "The check for the hold-off timer is based on its value, which can be either zero or non-zero. This test procedure involves checking the hold-off timer's status and verifying how it behaves accordingly. To configure this scenario, you need to set up the hold-off timer and the \"Wait to restore\" timers in the cfm interfaces' bandwidth notifications.\n\nThis test is triggered by whether the value of the hold-off timer is zero or non-zero.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nBandwidth should degrade after the hold off timer expires when the hold-off timer is non-zero verification is performed.\nBandwidth should be immediately degraded when hold-off timer is zero verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Send bnm wait to restore time run state",
                "Procedure": "When the system is in a wait-to-restore timer run state, it sends both degraded and nominal batch number maps. The test procedures for this condition involve sending these two types of batch number maps, while configuration settings include holding off and waiting for restoration timers.\n\nThis test is triggered by the system being in a wait-to-restore timer run state.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nSend degraded BNM when in wait-to-restore timer run state and check wait-to-restore timer stops and links remains degraded verification is performed.\nSend nominal BNM when in wait-to-restore timer run state and link remains degraded till wait to restore timer expires verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Configure wtr timer",
                "Procedure": "To test the Wait To Restore (WTR) timer, configure it with a value of zero and a non-zero value. Verify its behavior using the 'show cli' command. The WTR timer is configured as part of the Ethernet CFM bandwidth notification settings to wait for restoration in these cases.\n\nThis test is triggered by configuration changes to the Wait To Restore (WTR) timer within the Ethernet CFM bandwidth notifications settings.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nConfigure WTR timer with value non-zero (already configured in setup) and check bandwidth should become normal after the wait-to-restore timer ends verification is performed.\nConfigure WTR timer with value zero and check bandwidth should become normal immediately verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check bnm nominal current bw diff values",
                "Procedure": "The test checks the handling of batch nominal meters (BNMs) in two scenarios: where the nominal value is greater than zero but the current bandwidth is zero, and where both the nominal value and current bandwidth are zero. The test procedures for this scenario include checking how the system handles these conditions. This test is triggered by holding off and waiting to restore timers in a specific configuration.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nShow event manager environment verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nFor Nominal>0 and Current BW=0 , It should be treated as Degraded state and EEM should take action . verification is performed.\nFor Nominal=0 and Current BW=0 , It should be treated as OK state and EEM should not take action . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove cfm global config bnm enable",
                "Procedure": "The system checks for changes in the Ethernet CFM global configuration, ensuring that interfaces are removed from CFM-enabled mode and that it no longer responds to BNM (Broadcast Notification Message) messages. The test procedure involves adding or removing the global configuration, waiting for a period, and then restoring it while also verifying that any associated timers, such as hold-off and wait-to-restore, function correctly during this process.\n\nThis test is triggered by changes in the Ethernet CFM global configuration settings.",
                "Pass/Fail Criteria": "After removing cfm global config , it should remove the interfaces from CFM enabled and should not respond to BNM messages verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove interface bnm enable",
                "Procedure": "To test the functionality of adding or removing a bnm enabled interface, follow these procedures: add and remove the interface while checking for any changes, ensuring that the system does not respond to BNM messages. The configuration involves holding off and waiting to restore timers, as well as configuring the bnm enabled interface.\n\nThis test is triggered by modifications made to the BNM (bridge network management) settings or the presence of a new or removed interface.",
                "Pass/Fail Criteria": "After removing bnm enabled interface , it should not respond to BNM messages verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap cfm interfaces",
                "Procedure": "To test the interfaces that have been enabled with Customer Facing Module (CFM), follow these steps. First, you need to flap the interfaces, which means turning them on and off again, to see how they behave under normal conditions. Additionally, check your system's configuration settings for 'Hold Off' and 'Wait-to-restore' timers, which are used in specific situations.\n\nThis test is triggered by testing a network fault condition using the Customer Facing Module (CFM) enabled interfaces.",
                "Pass/Fail Criteria": "Ipv4 interface detail verification is performed.\nFlap the interfaces enabled with CFM and check whether BNM logs are seen or not, it should re-appear verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check malformed packets",
                "Procedure": "Malformed packets should be dropped and counted. Test procedures involve sending such packets, which should also be dropped and counted. Configuration requires holding off on and waiting for the restore timers.\n\nThis test is triggered by sending a malformed packet.",
                "Pass/Fail Criteria": "Malformed packets should be dropped and counted , logs will indicate that malformed packets are received. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bnm process restart",
                "Procedure": "After a process restart (CFMD, cgm, eem_ed_generic, fib_mgr), the state of BNM enabled links' should not change. To test this, degrade the bandwidth first, perform process restarts, and then verify that the link remains degraded. The configuration to use is Hold Off and Wait to restore timers.\n\nThis test is triggered by a process restart (CFMD, cgm, eem_ed_generic, fib_mgr)",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nAfter process restart (CFMD, cgm, eem_ed_generic, fib_mgr) the state of BNM enabled links' should not change verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Inject bnm corrupted value",
                "Procedure": "To test the system's behavior when a corrupted Business Network Manager (BNM) is injected, follow these steps. The BNM should be injected with a corrupted value and the response monitored. Specifically, it should be checked that packets are indeed dropped due to the corruption. To configure the environment for this test, disable the Hold off timer and set the Wait-to-restore timer accordingly.\n\nThis test is triggered by injecting the Business Network Manager with a deliberately corrupted value.",
                "Pass/Fail Criteria": "Inject the BNM with corrupted value and check the packets should be dropped and BNM/GNM messages should not be seen verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bnm reload router",
                "Procedure": "When degrading the bandwidth to a point where it is no longer sufficient, the router should automatically send new BNM (Bandwidth Notification Message) notifications. This test is triggered by intentionally reducing the available bandwidth until services are impacted.\n\nTriggered by: Intentionally degrading the bandwidth until network services are significantly impaired.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nReload router should send new BNM notifications and link should remain degraded verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bnm hw reload router",
                "Procedure": "The HW-Module Reload router should send new BNM notifications. When the test is triggered by the user degrading the bandwidth, reloading the router, and checking if it sends new BNM notifications, the following conditions apply: Configuration settings include holding off on sending notifications for a period of time and waiting to restore connectivity.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nReload router should send new BNM notifications and link should remain degraded verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap bundle members",
                "Procedure": "The test procedures recommend flapping the bundle members and checking their status. This process is part of the configuration, which involves holding off and waiting to restore the timers when necessary. The test is triggered by a specific condition or event that requires this particular set of actions to be taken.",
                "Pass/Fail Criteria": "Ipv4 interface detail verification is performed.\nFlap the bundle members and check the bnm logs should come fresh & hold off timer should re-start verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Run traffic degraded state long time",
                "Procedure": "To test the system's ability to recover from a degraded state, run traffic under those conditions for an extended period. The test procedure involves continuing to generate traffic even as the system begins to degrade, then verifying that it returns to a normal operating state once the traffic stops. This requires configuring hold-off and wait to restore timers, allowing the system sufficient time to stabilize before attempting to resume normal operation. \n\nThis test is triggered by a prolonged period of degraded network performance caused by running excessive traffic for an extended duration.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nIt should come back to OK state as the wait to restore timer expires verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check diff loss threshold behaviour",
                "Procedure": "To assess how a system responds to changes in loss thresholds, adjust these values and monitor its behavior. The test procedures involve modifying the hold-off period, wait-to-restore settings, and loss-threshold values. \n\nThis test is triggered by modifying configuration parameters such as Hold-Off, Wait-to-restore, and Loss-Threshold values.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nAfter stopping traffic , state should change from degraded to OK after configured loss threshold value plus watr timer expires verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check degraded subinterface affect",
                "Procedure": "To ensure that a degraded state on one sub-interface does not affect other sub-interfaces of the same main interface, we need to test how the system responds. The test procedure involves degrading one sub-interface and verifying its effect on another sub-interface sharing the same main interface. This requires configuring Hold Off, Wait-to-restore, Loss-threshold, and logging changes.\n\nThis test is triggered by degrading a single sub-interface.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nDegrade state of one sub-interface should not affect the other sub-interface of the same main interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check degraded bundle subinterface affect",
                "Procedure": "When degrading a single sub-interface within a bundle, it's essential to verify whether this change affects the operational state of any other sub-interfaces that belong to the same bundle. To test this scenario, first degrade one sub-interface and then check the state for all other sub-interfaces associated with the same main interface. This test is triggered by modifying the configuration settings to Hold Off, Wait-to-restore, Loss-threshold, or logging changes on a per-bundle basis.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nDegrade state of one Bundle sub-interface should not affect the other Bundle sub-interface of the same main Bundle interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check max unique bnm enabled links",
                "Procedure": "During test procedures, up to 200 unique links that have been learned from Border Gateway Protocol (BGP) notifications are sent as degraded links and verified through the display of CLI output.\n\nThis test is triggered by sending BGP notifications for up to 200 unique links learned from such notifications.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\n200 unique BNM enabled links learned from BNMs received per LC should be seen in show cli output verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check max bnm enabled links per lc negative",
                "Procedure": "Traffic is sent to 201 BNM-enabled degraded links, but no more than 200 of these links are stored. This test is triggered by sending traffic to a large number of degraded links that have been configured with the BNM feature.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCheck for not more than 200 BNM enabled links are stored per LC using show ethernet cfm summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Interface status expired loss threshold timer",
                "Procedure": "The interface's status should be checked in relation to its expired loss threshold timer. To do this, you stop the traffic and verify whether the loss threshold timer has expired, taking into account both hold-off and wait-to-restore scenarios. This is triggered by a test that checks for the expiration of the loss-threshold timers, which are configured for hold-off, wait-to-restore, and loss-threshold settings.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nHold Off timer should be cancelled after loss-threshold timer expires verification is performed.\nWait-to-restore timer should start as loss-threshold timer expires verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check bnm scale one interface 20 port ids",
                "Procedure": "To trigger this test, send a G.8013BNM message for one interface where all 20 port IDs match, then verify that the EEM script is invoked as indicated in the logs.\n\nConfiguration: The environment variables must be set accordingly for this test to run properly.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nEEM script should be invoked 20 times for each 20 port-ids for one interface verification is performed.\nshow cli also verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check bnm full scale",
                "Procedure": "To test the system, send a G.8013BNM message for 10 interfaces that have 20 port-ids each. The test procedure is to then verify the output of the show cli command. This test is triggered by sending a generic G.8013BNM notification message.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\noutput in show ethernet cfm interfaces bandwidth notifications cli. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bnm rp failover",
                "Procedure": "To test the RP (Route Processor) failover procedure, first intentionally reduce the bandwidth to a point where it is near failure. Then trigger an RP failover, which should be triggered by an anomaly in BGP or IGP convergence, such as excessive CPU usage or routing table instability, and verify that the BNM link remains degraded even after the failover occurs. Next, configure the Hold-Off and Wait-to-Restore Timers according to the device's specifications.",
                "Pass/Fail Criteria": "Ethernet cfm interfaces bandwidth notifications verification is performed.\nIpv4 interface detail verification is performed.\nBNM Packets should be processed after RPFO and link should remain degraded for physical interface. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Configure cfm vpws network",
                "Procedure": "To configure the Connectionless Operations, Administration, and Maintenance (CL OAM) protocol for a Virtual Private Wire Service (VPWS), first set up the VPWS configuration. Then, enable CL OAM on both ends of the network, sending Bridge Neighbourship Message (BNM) messages to establish the connection. Check the logs to verify that the Connectionless Operations, Administration, and Maintenance (CL OAM) protocol has been successfully enabled. This test is triggered by the receipt of a BNM message from the other end of the VPWS, which indicates the completion of the Connectionless OAM configuration process.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nOspf neighbors verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn xconnect verification is performed.\nShow event manager environment verification is performed.\nGNM/BNM messages should be received for up mep verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Configure cfm vpls network",
                "Procedure": "In a VPLS network, configure CFM and verify the BNM messages related to the CFM up MEP. To do this, follow these steps: CFM must be configured in the setup part of the process, after which BNM messages should be sent and their presence confirmed in the logs through the CLI display.\n\nThis test is triggered by configuring CFM in a VPLS network with specific configuration settings for BNM timers.",
                "Pass/Fail Criteria": "Show event manager policy registered verification is performed.\nEthernet cfm interfaces bandwidth notifications verification is performed.\nOspf neighbors verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn bridge domain bd name detail verification is performed.\nShow event manager environment verification is performed.\nGNM/BNM messages should be received for up mep verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "cfm_xconnect_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Cfm basic verification",
                "Procedure": "CFM is configured on both processors (PEs) of a VPWS network, and several verifications are performed. This includes verifying the CFM peer maintenance endpoints, local maintenance points, and ensuring that traffic flows properly between them. The test also checks to see if the configuration has been set up correctly, specifically looking at the configuration of CFM. \n\nThis test is triggered by the need to verify the basic configurations of a CFM setup on a VPWS network, which involves configuring both PEs with correct settings for maintenance endpoints and ensuring that traffic can flow between them without interruption.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local maintenance points verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ping",
                "Procedure": "CFM is configured on both Provider Edge (PE) devices on the Virtual Private Wire Service (VPWS) network. To verify that the CFM ping is working, several checks are performed: CFM pings are initiated from a source MEP-ID and interface, from a source interface alone, and it's confirmed that traffic is flowing properly throughout.\n\nThis test is triggered by the user enabling CFM on the VPWS network.",
                "Pass/Fail Criteria": "CFM: Verify CFM ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm traceroute",
                "Procedure": "CFM traceroute can be verified by configuring CFM on both Provider Edge (PE) devices in a Virtual Private Wire Service (VPWS) network. It's necessary to verify the traceroute with the source Maintenance Association Endpoint Identifier (MEP-ID) and interface, as well as with just the source interface. Additionally, you must ensure that traffic is flowing properly throughout the network.\n\nThis test is triggered by configuring CFM on both Provider Edge devices in a VPWS network.",
                "Pass/Fail Criteria": "CFM: Verify CFM traceroute verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config",
                "Procedure": "To test the CFM Global Unconfiguration Configuration, configure CFM on both PEs in a VPWS network, then unconfigure it globally on both devices. Next, reconfigure CFM globally on both PEs and verify that the CFM session has been restored. Finally, check to see if traffic is flowing properly.\n\nThis test is triggered by the existence of a Configuration item named \"CFM\".",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Global Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm config unconfig int",
                "Procedure": "The test verifies the unconfiguration and re-configuration of CFM (Connectivity Fault Management) in a VPWS network, which involves configuring CFM on both endpoints, then unconfiguring it at the interface level, re-configuring it again, and checking that the CFM session is restored and traffic is flowing properly. This test is triggered by CFM Configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Interface Unconfiguration Configuration. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm unconfig config domain",
                "Procedure": "CFM configuration and unconfiguration involves configuring CFM on both PEs in a VPWS network, then unconfiguring the CFM domain on both devices. This process includes reconfiguring the CFM domain, verifying that the CFM session has been restored, and confirming that traffic is flowing properly.\n\nThis test is triggered by the Configuration of cfm domain.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM Unconfiguration Configuration of cfm domain verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm with unconfig config l2vpn",
                "Procedure": "The test verifies the operation of CFM (Connectivity Fault Management) in an L2VPN environment, specifically during configuration changes. To perform this test, configure CFM on both Provider Edge (PE) devices and the Provider device (P). Next, unconfigure the L2VPN on all three devices, followed by reconfiguring the L2VPN. Once the L2VPN is back online, verify that the CFM session has been restored and traffic is flowing normally. This test is triggered by a change in configuration that affects the L2VPN setup.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM on Unconfiguration Configuration of l2vpn on both PE's and P verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ccm 10m",
                "Procedure": "CFM is tested with a 10-meter CCM configuration, verifying that the CFM session is up and running, and that traffic flows smoothly between devices.\n\nThis test is triggered by configuring both PEs with a 10m CCM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 10m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ccm 1m",
                "Procedure": "To verify the correct operation of CFM with a cell size of 1m CCM, configure CFM on both provider edge (PE) devices using this cell size. Then, check that a CFM session has come up and is functioning correctly. Finally, confirm that traffic is flowing properly.\n\nThis test is triggered by verifying the correct operation of CFM with a cell size of 1m CCM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with 1m CCM. verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm ccm timer swap",
                "Procedure": "CFM tests are performed with multiple CCM timer values. To verify this, configure CFM on both PEs with a 10m CCM timer value and check that the CFM session is up and running. Then, reconfigure CFM on both devices with a 1m CCM timer value and verify the session remains operational. Next, change the configuration to use a 10s CCM timer value and confirm that the session continues to function correctly. Finally, ensure that traffic flows properly through the network. This test is triggered by changing the CCM timer values on both PEs in a CFM configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with multiple CCM timer values verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm maid string",
                "Procedure": "CFM configuration with MAID string involves setting up the technology on both PEs, which includes configuring it with a MAID string. This test verifies that the setup works as expected by ensuring that a CFM session is established and functioning correctly, and that traffic flows properly.\n\nThis test is triggered when CFM configuration with MAID string needs to be tested and verified.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with MAID string verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm maid dns",
                "Procedure": "The configuration of CFM (Connectivity Fault Management) with MAID DNS involves configuring CFM on both Provider Edge routers. This test verifies that the CFM session is established and functioning correctly, which includes verifying that traffic flows properly between the two devices.\n\nThis test is triggered by a specific configuration involving the use of MAID DNS in CFM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with MAID dns verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm maid mac",
                "Procedure": "The test checks the operation of CFM (Connectivity Fault Management) with a device that has an MAID MAC address. It involves configuring CFM on both peer edge devices, verifying that the CFM session is established and functioning correctly, and confirming that traffic flows properly between them.\n\nThis test is triggered by: Configure CFM on a device with an MAID MAC address to verify its operation.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with MAID mac verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm maid swap",
                "Procedure": "CFM is tested with multiple MAID values by configuring it on both processing engines (PEs) with a null Media Access Identifier (MAID), then verifying that the CFM session is functioning. This is followed by reconfiguring CFM on both PEs with a string MAID, and again verifying that the session remains operational. Next, the test reconfigures CFM on both PEs with a MAC address MAID, followed by another verification. After this, the test reconfigures CFM on both PEs without any MAID specified and verifies once more that the session is working properly. The final step involves verifying that traffic is flowing correctly. This test is triggered by configuring CFM on both PEs with various MAID configurations.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with multiple MAID values verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm interface flap",
                "Procedure": "CFM with interface flap testing verifies that the Connectionless-OAM (CL-OAM) feature works correctly. This test is triggered by a scenario where an interface flap occurs on the peer network device, causing the P router to bring down and then up the pseudowire (PW). The test involves configuring CFM on both primary equipment edge routers, verifying that the session is up and functioning as expected, bringing down the PW in the P router, checking that the CFM session is brought down, bringing the interface back up, and confirming that traffic flows properly.",
                "Pass/Fail Criteria": "Ipv4 interface detail verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM with interface flap verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm process restart",
                "Procedure": "This text describes a test that checks the functionality of CFM (Connectivity Fault Management) when a device process is restarted. To perform this test, first configure CFM on both devices, then verify that the CFM session is established and functioning correctly. Next, restart the process on one or both devices, and finally confirm that the CFM session remains up and working.\n\nThis test is triggered by restarting a device process during an active CFM session to verify whether CFM continues to function as expected.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm process restart rp",
                "Procedure": "The test checks for Communication Forwarding Management (CFM) functionality during a process restart. To verify this, configure CFM on both Protocol Engines (PEs), check that the CFM session is established and operational, then perform a process restart, after which the CFM session should remain up and working.\n\nThis test is triggered by verifying the successful completion of a process restart operation.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list_rp(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCFM: Verify CFM with process restart verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm triggers",
                "Procedure": "The configuration for this test involves enabling CFM on both Provider Edge (PE) devices, ensuring that the CFM session is operational, and then triggering specific events to test its functionality. This includes verifying that the CFM session remains up and running after each trigger event - specifically, rpfo, reload, and lcoir are used for testing purposes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"rpfo\" and \"lc_oir\" and \"xrvm_reload\"",
                "Pass/Fail Criteria": "Interface state verification is performed.\nL2vpn xconnect summary verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM with triggers verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm with push",
                "Procedure": "CFM (Connectivity Fault Management) performs basic verifications with the push operation. The process involves configuring CFM on both Provider Edge (PE) devices in a Virtual Private Wire Service (VPWS) network, verifying that the peer Multi-Point Encapsulated Relay Agent (MEP) is established, checking local maintenance points, and confirming that traffic is flowing correctly. Additionally, an L2VPN push is configured to verify that CFM sessions are active and functional.\n\nThis test is triggered by configuring CFM on both PEs in a VPWS network.",
                "Pass/Fail Criteria": "Verify verification is performed.\nCfm local maintenance points verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 10ms",
                "Procedure": "Here is the rewritten paragraph:\n\nCFM hw-offload sessions are tested using a 10ms timer. The test verifies that CFM pings are successful by configuring downmeps, creating 1000 sessions between R1 and R2, verifying cfm summary, peer meps, local meps, and checking that CFM pings with source MEP-ID and interface are working properly while ensuring traffic is flowing correctly.\n\nThis test is triggered by the need to verify proper hardware offload of CFM sessions.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 10ms with triggers",
                "Procedure": "CFM hw-offload sessions are tested with a 10ms timer that includes various triggers. The test verifies that CFM ping works by configuring downmeps for 1000 sessions between R1 and R2, checking the cfm summary, peer meps, and local meps, verifying CFM ping with source mep-id and interface, and confirming that traffic is flowing properly.\n\nThis test is triggered by RFC2544, LCOIR, interface flap, and unconfig rollback of CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"rpfo\" and \"lc_oir\" and \"interface_flap\" and \"unconfig_rollback_cfm\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nVerify verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 10ms clear ethernet cfm",
                "Procedure": "Here's how to test CFM hw-offload sessions: Configure CFM downmeps on R1 and R2. Then, create 1000 active sessions between them with a timer set to 10ms. Next, verify that the cfm summary shows peer MEPs and local MEPs correctly. You should also be able to ping CFM successfully from each device using its source MEP-ID and interface. Verify that traffic is flowing properly over the session. Then, clear the CFM peer Meps, local meps and offload, and repeat all these checks.\n\nThis test is triggered by a hardware timer with a 10ms setting.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"clear_cfm_peer_meps\" and \"clear_cfm_local_meps\" and \"clear_cfm_offload\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 10ms commit replace cscvy03169",
                "Procedure": "CFM hw-offload sessions are tested using a 10ms timer with the commit replace rollback trigger. This test verifies that all Meps are up before committing, and it checks for a CFMD crash in the syslog. If a crash is found, the test fails. The configuration used is CFM.\n\nThis test is triggered by the commit_replace_rollback command.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\ncfmd crash should not happen after commit replace rollback verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 3 3ms",
                "Procedure": "CFM hw-offload sessions are tested with a 3.3ms timer in this test to verify CFM ping functionality. The configuration involves configuring downmeps scale sessions between R1 and R2, verifying cfm summary, peer meps, and local meps, as well as checking that CFM ping works correctly with the source MEP ID and interface. Additionally, it's essential to ensure that traffic is flowing properly.\n\nThis test is triggered by the configuration of downmeps scale sessions between R1 and R2.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 3 3ms with triggers",
                "Procedure": "The test verifies the operation of CFM hw-offload sessions with a 3.3ms timer by simulating various triggers such as RPFO, LCOIR, interface flapping, and unconfiguration rollback.\n\nThis test is triggered by configuring R1 and R2 to run CFM downmeps scale sessions, verifying cfm summary, peer meps, local meps, CFM ping with source MEP-ID and interface, checking that traffic flows properly, then repeating the process after triggering RPFO, LCOIR, interface flap, and unconfig rollback of CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"rpfo\" and \"lc_oir\" and \"interface_flap\" and \"unconfig_rollback_cfm\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nVerify verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 3 3ms clear ethernet cfm",
                "Procedure": "The test verifies CFM ping by configuring CFM downmeps scale sessions between R1 and R2. It then verifies that the CFM summary, peer MEPs, and local MEPs are present, and checks that a CFM ping with a source MEP-ID and interface is successful. The test also confirms that traffic is flowing properly. Additionally, the configuration involves clearing the CFM peer MEPs, local MEPs, and offload, after which the above checks are repeated. This test is triggered by setting the timer to 3.3ms.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"clear_cfm_peer_meps\" and \"clear_cfm_local_meps\" and \"clear_cfm_offload\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 3 3ms process restart",
                "Procedure": "To test the CFM hw-offload sessions, we configure three scale sessions between R1 and R2 using a timer of 3.3ms to trigger the test. The test verifies that the CFM ping function is working correctly by checking the cfm summary, peer meps, local meps, and traffic flow. We also perform a process restart to ensure the system can recover properly from any issues. This test is triggered by setting the hw-offload timer to 3.3ms.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap, tc='test_cfm_hwoffload_scale_3_3ms')\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cscvx68016",
                "Procedure": "CFM process verification involves checking that it is not blocked while executing certain commands. The test verifies the CFM ping functionality, including verifying the CFM summary, peer MIPs and local MIPs, the CFM ping with source MEP ID and interface, and that traffic flows properly. Additionally, it executes the 'show tech ethernet cfm' command to confirm that the CFM daemon is not blocked. This test is triggered by a configuration of CFM.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm downmeps 100ms",
                "Procedure": "The configuration for this test includes configuring CFM downmeps, creating 1000 sessions between R1 and R2 with a 100ms timer, and verifying that cfm summary, peer meps , local meps are correct. The test also verifies that CFM ping is successful from the source MEP-ID and interface, and checks that traffic is flowing properly. \n\nThis test is triggered by configuring a hardware offload session to a device with a 100ms timer setting.",
                "Pass/Fail Criteria": "Get ethernet cfm summary verification is performed.\nEthernet cfm session verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 1s 16k",
                "Procedure": "CFM (Connectivity Fault Management) sessions are tested for hardware offload using a timer of 1 second. The test verifies that CFM pings can be sent successfully between devices R1 and R2, which have been configured with a large number of scale sessions. A cfm summary is verified to ensure the configuration has taken effect, as well as peer meps (maintenance entity groups) and local meps. Additionally, CFM pings are checked for successful transmission from source MEP-ID and interface, confirming that traffic is flowing properly through the network.\n\nThis test is triggered by a configuration involving 16K downmeps scale sessions between R1 and R2.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 1s 16k crosscheck mac",
                "Procedure": "The test checks how well CFM handles hardware-offload sessions with a 1-second timer by verifying its ping functionality. The configuration for this test involves setting up 16K downmeps scale sessions between R1 and R2, then checking the cfm summary, peer meps, local meps, and CFM ping with source mep-id and interface, as well as ensuring traffic is flowing properly. Next, the sessions are reconfigured to use mac-address as mep crosscheck and all of these steps are verified; this process is then rolled back to its original state using mep as crosscheck and once again verified. This test is triggered by the configuration: CFM.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nVerify verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 1s 16k trigger",
                "Procedure": "CFM sessions are tested by configuring downmeps scale sessions between R1 and R2. The test verifies that the CFM ping works correctly, checking the summary, peer MEPs, local MEPs, and the source MEP-ID and interface. Additionally, it ensures traffic is flowing properly. To simulate real-world scenarios, the triggers for RPFO (Remote Protocol Fault Notification), LCOIR (Local Control Plane Fault Indication Request), interface flap, and unconfig rollback of CFM are used, with the test being repeated after each trigger event.\n\nThis test is triggered by various events including RPFO, LCOIR, interface flapping, and unconfiguration of the CFM.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_oir\" and \"rpfo\" and \"unconfig_rollback_cfm\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nVerify verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 1s 16k process restart rp",
                "Procedure": "CFM hardware-offload sessions are tested using a 1-second timer with the following triggers. This test is triggered by the need to verify that CFM pings work correctly, which involves configuring CFM downmeps scale sessions between R1 and R2, checking cfm summary, peer meps, and local meps, verifying CFM ping with specific source MEP IDs and interfaces, ensuring proper traffic flow, restarting the process, and repeating these checks.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap, tc='test_cfm_hwoffload_scale_16k')\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm traceroute with mip",
                "Procedure": "CFM is configured on both Provider Edge (PE) routers connected through an XC network, enabling Basic Ping and Traceroute verifications between them. This test verifies that the basic ping functionality works as expected. Configure CFM on both PEs in the xc network to allow traceroute verification from R1 to R3.\n\nThis test is triggered by configuring CFM on both Provider Edge (PE) routers connected through an XC network.",
                "Pass/Fail Criteria": "CFM: Verify CFM traceroute from R1 to R3 verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm session after lc reload with efd cscvv38941",
                "Procedure": "The test verifies the basic verifications of CFM. It involves configuring CFM Up MEP and Down MEP with EFD enabled on both R1, the Unit Under Test. Then it checks for peer MEP configuration, sets a mismatched timer on R3 to trigger an EFD, resets the timer to its proper value, and verifies that the EFD is cleared. Next, the test reloads the LC on R1, waits until the LC is up, and then confirms that both Up MEP and Down MEP sessions are active. Finally, it checks that the EFD is not triggered.\n\nThis test is triggered by a mismatched timer value configured on R3.",
                "Pass/Fail Criteria": "Efd interface verification is performed.\nCfm peer meps verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm downmeps 1s",
                "Procedure": "CFM hw-offload sessions are tested with 1s timer support. The test verifies that CFM pings are working correctly by configuring downmeps on two devices, R1 and R2, and creating 2000 sessions between them. It then checks the cfm summary, peer meps, and local meps to ensure they match expectations. Additionally, it verifies a successful CFM ping with specific source MEP-ID and interface information. Finally, the test confirms that traffic is flowing properly throughout the process.\n\nThis test is triggered by an operator command to run CFM hw-offload sessions with 1s timer support.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 1s rewrite pop1",
                "Procedure": "CFM (Connectivity Fault Management) sessions are tested to ensure proper operation when hardware offload is disabled. The test involves setting up a timer of 1 second, rewriting POP1, and verifying that CFM pings are successful. This includes configuring downmeps scale sessions between R1 and R2 with POP1 rewrite enabled, checking the cfm summary, peer meps, and local meps, as well as confirming that traffic is flowing correctly. \n\nThis test is triggered by a configuration where hardware offload for CFM sessions is disabled and a timer of 1 second has been set.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 1s rewrite pop2",
                "Procedure": "CFM hw-offload sessions are tested with a 1s timer and POP2 rewritten when configuring the system. To verify this setup, CFM downmeps scale sessions between R1 and R2, with POP2 rewrite configured. The cfm summary, peer meps, and local meps should all be verified. Additionally, CFM ping verification is performed using a source MEP-ID and interface, confirming that traffic flows properly.\n\nThis test is triggered by configuring CFM downmeps scale sessions between R1 and R2 with POP2 rewrite configured.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm hwoffload downmeps 1s rewrite push1",
                "Procedure": "CFM sessions are tested for hardware offload with a 1 second timer, using PUSH1 rewrites. The test verifies that the CFM ping function works as expected. To achieve this, CFM downmeps sessions are configured to scale between R1 and R2 devices, while also setting up PUSH1 rewrite. After configuring these settings, verification checks are performed on the cfm summary, peer meps, local meps, and CFM ping with a source MEP-ID and interface. Additionally, it is confirmed that traffic flows properly in accordance with the configuration: CFM.\n\nThis test is triggered by hardware offload sessions configured with PUSH1 rewrites.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe",
                "Procedure": "CFM is configured on both PEs in a VPWS network, and its peer MEPs are verified. The test then simulates an issue by transitioning the UP MEP interfaces to a Tx-disable state.\n\nThis test verifies CFM basic verifications when it is triggered by the configuration of CFM on both PEs in a VPWS network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw pe and pe",
                "Procedure": "CFM is configured on both PEs in a VPWS network, and then the test verifies that CFM peers can communicate with each other. Next, it simulates an issue and checks that the transmit-disable state is triggered for the UP MEP interfaces.\n\nThis test is triggered by simulating an issue that causes the Tx-disable state to be activated on the UP MEP interfaces.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe ha triggers",
                "Procedure": "CFM is configured on both PEs in a VPWS network, and its peer maintenance association endpoints (meps) are verified. A simulated issue is then introduced, after which the transmit-disable state is confirmed for the upstream multipoint endpoint (UP MEP) interfaces.\n\nThis test verifies basic CFM configurations by triggering when either PE's CFM process encounters an abnormal situation that affects the communication between CE and PE in a VPWS network.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_oir\" and \"router_reload\" and \"rpfo\" and \"xrvm_reload\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe commit replace rollback",
                "Procedure": "The test, called upmep_upmep_fault_btw_CE_and_PE with commit_replace_rollback, is used to verify the basic functionality of CFM. It involves configuring CFM on both peer equipment (PES) in a VPWS network, verifying that they have established a peer MEP relationship, simulating an issue, and checking that the transmit-disable state is triggered for the interfaces of the UP MEP. The test assumes that the necessary configuration has been set up beforehand. This test is triggered by a commit-replace-rollback operation, which is the specific action that triggers this particular verification.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet cfm local meps verbose verification is performed.\nSpirent link state verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe remove readd l2vpn",
                "Procedure": "The CFM LLF upmep_upmep_fault_btw_CE_and_PE test is triggered by the presence of the remove_readd_l2vpn configuration. This test verifies basic CFM verifications on a VPWS network, including configuring CFM on both PEs and verifying peer MEPs, simulating an issue to check for Tx-disable state on UP MEP interfaces.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nL2vpn xconnect verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe remove readd cfm config",
                "Procedure": "CFM (Connectivity Fault Management) is verified with a series of checks. The configuration involves setting up CFM on both PE (Provider Edge) devices on a VPWS (Virtual Private Wire Service) network. This test verifies the basic functionality of CFM by checking the peer meps (maintenance association endpoints), simulating an issue, and verifying that the Tx-disable state is reached for UP MEP (User Process MEs) interfaces.\n\nThis test is triggered by the removal and re-addition of a specific configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe remove readd cfm inteface config",
                "Procedure": "CFM LLF is tested with the upmep_upmep_fault_btw_CE_and_PE scenario, where remove_readd_cfm_cinterface_onfig is used. This test is triggered by configuring CFM on both PEs in a VPWS network, verifying CFM peer meps, simulating an issue, and verifying that Tx-disable state is achieved for UP MEP interfaces during the configuration process.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe shut noshut cfm interface",
                "Procedure": "CFM is tested with the upmep_upmep_fault_btw_CE_and_PE and shut_noshut_cfm_interface tests. This test verifies the basic verifications of CFM. It involves configuring CFM on both PEs in a VPWS network, verifying CFM peer meps, simulating an issue, and checking that Tx-disable state is active for UP MEP interfaces.\n\nThis test is triggered by configuration: CFM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe process restart",
                "Procedure": "The test \"upmep_upmep_fault_btw_CE_and_PE\" with process_restart triggers the verification of basic CFM functionality. This involves configuring CFM on both PEs in a VPWS network, verifying the peer meps, simulating an issue, and checking that Tx-disable state is achieved for UP MEP interfaces during configuration.\n\nTriggered by: The test \"upmep_upmep_fault_btw_CE_and_PE\" with process_restart verifies this.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe process crash",
                "Procedure": "CFM is configured on both PEs in a VPWS network and the peer MEPs are verified. To trigger this test, verify that you have initiated a process restart. \n\nRewritten trigger sentence:\nTo trigger this test, verify that you have initiated a process restart.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"CfmApBase.get_proc_list(ApData=CfmApBase.zap)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf downmep upmep fault pe and pe",
                "Procedure": "The test verifies the basic configuration and functionality of CFM (Connectivity Fault Management) on a pair of PEs (Provider Edge devices) connected through a VPWS (Virtual Private Wire Service) network. It involves configuring CFM on both PEs, verifying that the peer MEPs (Maintenance Association End Points) are established correctly, simulating an issue to trigger a fault notification, and then checking that the Tx-disable state is activated for the UP MEP interfaces.\n\nThis test is triggered by simulating an Issue.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe bun",
                "Procedure": "CFM and LLF are tested in the upmep_upmep_fault_btw_CE_and_PE bundle interface. This test verifies basic CFM verifications, including configuring CFM on both PEs on a VPWS network, verifying peer meps, simulating an issue, and verifying that Tx-disable state is triggered for UP MEP interfaces. Configuration involves enabling CFM. This test is triggered by the need to verify that, upon failure of a CE's (Customer Edge) connection to a PE's (Provider Edge) network, its fault indication will be properly reported to the PE, and vice versa.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw pe and pe bun",
                "Procedure": "CFM is configured on both PEs in a VPWS network to verify its basic functionality, including the establishment of peer multi-point endpoints. The test then simulates an issue and checks that the transmit-disable state is activated for the upstream multipoint endpoint interfaces.\n\nThis test is triggered by the configuration of CFM on two Physical Entity (PE) nodes connected over a Virtual Private Wire Service (VPWS) network.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe bun remove readd bundle members",
                "Procedure": "CFM is configured on both PEs in a VPWS network, and its peer MEGs are verified. The test then simulates an issue by verifying the Tx-disable state for UP MEP interfaces.\n\nThis test is triggered by the presence of the configuration: CFM.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf downmep upmep fault pe and pe bun",
                "Procedure": "CFM (Connectivity Fault Management) is configured on both points of presence (PEs) in a virtual private wire service (VPWS) network. This test verifies the basic functionality of CFM, which involves verifying that the CFM peer multipeer endpoints (meps) are properly configured and functioning correctly. A simulated issue is then introduced to verify that the transmit-disable state for upstream multipoint endpoint interfaces (UP MEPs) behaves as expected.\n\nThis test is triggered by simulating an issue on a VPWS network with two PEs where CFM is enabled.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe bun add int to bundle with remote defect",
                "Procedure": "The CFM LLF test_cfm_llf_upmep_upmep_fault_btw_CE_and_PE_bun verifies basic verifications of CFM, including configuring it on both PEs in a VPWS network and verifying peer meps. To trigger this test, the following conditions are required: This test is triggered by adding an integer to bundle with a remote defect.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet cfm local meps verbose verification is performed.\nSpirent link state verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw ce and pe multiple mep",
                "Procedure": "When testing the upmep_upmep_fault_btw_CE_and_PE feature, which is designed to verify basic CFM (Connectivity Fault Management) configurations, the following steps are taken. Multiple mep pairs are configured on both PEs in a VPWS network. Then, CFM peer meps are verified, and an issue is simulated, after which the Tx-disable state for UP MEP interfaces is confirmed.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep fault btw pe and pe multiple mep",
                "Procedure": "CFM is tested on upmep_upmep_fault_btw_PE_and_PE with multiple meps. This test verifies the basic verifications of CFM, which involves configuring CFM on both PEs on a VPWS network, verifying the peer meps, simulating an issue, and checking that the Tx-disable state is reached for UP MEP interfaces.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf downmep upmep fault multiple mep",
                "Procedure": "CFM is configured on both endpoints of a Virtual Private Wire Service (VPWS) network. The test verifies the basic functionality of CFM by checking that it can communicate with its peers and enter a Tx-disable state when necessary. This test is triggered by the occurrence of an up-mep downmep fault PE and PE multiple mep fault event, where one or more ports on each endpoint are unavailable.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nSpirent link state verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm llf upmep upmep scale",
                "Procedure": "The test verifies the basic functionality of CFM by configuring it on both Provider Edge (PE) devices in a Virtual Private Wire Service (VPWS) network. The configuration involves verifying that the CFM peer Multi-Point Encapsulated Relay (MEP) is present, simulating an issue to put the interfaces into Tx-disable state for the UP MEP interfaces, and checking their states. This test is triggered by a scaled case 4 meps configured scenario.",
                "Pass/Fail Criteria": "Spirent link state verification is performed.\nCfm peer meps verification is performed.\nEthernet cfm local meps verbose verification is performed.\nCFM: Verify CFM peer meps and local maintanence points verification is performed.\nTx-disable state for UP MEP interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Baseline verification cfmmxconnect hwoffload",
                "Procedure": "The test for baseline verification of the CFMMXConnect HW Offload feature performs basic verifications related to L2VPN configuration. It checks if L2VPN is operational and functioning as expected. The configuration for this test has been done in the setup class, which implies that all necessary settings have been established before running the test.\n\nThis test is triggered by verifying that an L2VPN connection is successfully established.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nL2VPN to be up verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm xconnect upmep scale",
                "Procedure": "The test for CFM Xconnect Scale for Physical Subscriber verifies the configuration of a CFM 2000 UPMEP scale for physical subscribers. This involves setting up the physical subscriber configuration in the setup class, then verifying that the CFM summary, peer MEPs, and CFM offloads are functioning correctly. Additionally, the test ensures that traffic is flowing properly through the network under the specified configuration. \n\nThis test is triggered by a specific CFM configuration: CFM.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nGet ethernet cfm summary verification is performed.\nEthernet cfm session verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , cfm hwoffload verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm xconnect upmep scale trigger",
                "Procedure": "This paragraph:\nThe CFM Xconnect Up Mep Scale test verifies basic CFM verifications with triggers. It involves configuring CFM on both Provider Edge (PE) devices in a 2K setup class, then verifying that the peer Multi-Point Extension (MEP) and CFM summary are functioning correctly as well as hardware offload. Additionally, traffic is checked to ensure it's flowing properly.\n\nThis test is triggered by configuring different trigger settings for various tests within the CFM Xconnect Up Mep Scale framework.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lcreload\" and \"router_reload\"",
                "Pass/Fail Criteria": "Interface state verification is performed.\nL2vpn xconnect summary verification is performed.\nGet ethernet cfm summary verification is performed.\nEthernet cfm session verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps, cfm summary and hw-offload verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm downmeps scale 1s sf",
                "Procedure": "The test for verifying CFM (Connectionless Operation, Administration, and Maintenance) ping involves several steps. It requires configuring CFM down MEPs, then verifying the CFM summary, including both peer and local MEPs. Additionally, the test checks that a CFM ping is successful when sent with a specific source MEP-ID and interface. The final step is to confirm that traffic is flowing properly throughout the process.\n\nThis test is triggered by configuring CFM downmeps.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm downmep scale 1s sf with triggers",
                "Procedure": "The test verifies that CFM (Connectivity Fault Management) is functioning correctly by configuring a CFM down MEP, verifying the CFM summary, peer MEPs, and local MEPs, checking that CFM pings are successful with a specified source MEP ID and interface, ensuring that traffic is flowing properly, triggering specific events such as an RPF (Reverse Path Forwarding) failure, LCOIR (Loss of Connectivity to Other Interface on the same Router), interface flap, and unconfig rollback of CFM.\n\nThis test is triggered by specific network configurations that cause certain fault conditions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"rpfo\" and \"lc_oir\" and \"interface_flap\" and \"unconfig_rollback_cfm\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nVerify verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm downmep scale 1s sf clear ethernet cfm",
                "Procedure": "The test verifies CFM ping by configuring down Mep Scale timers to clear MEPs. It then checks that the CFM summary, peer MEPs, and local MEPs are verified. Next, it ensures that the CFM ping works correctly with a specified source MEID and interface, and that traffic is flowing properly. To complete the test, the peer MEPs and local MEPs are cleared, after which all of these checks are repeated.\n\nThis test is triggered by a configuration of CFM Down Mep Scale timer 1 seconds to clear MEPs.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"clear_cfm_peer_meps\" and \"clear_cfm_local_meps\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , local meps ping verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfmxconnect hwoffload basic verification",
                "Procedure": "CFM HWOffload basic verifications are verified through this test. This test is triggered by configuring CFM on both PEs in a VPWS network AC-AC setup, verifying CFM peer MEPs, local maintenance points, and Ethernet CFM details with \"show ethernet cfm local meps detail\", as well as pinging and performing a traceroute while ensuring traffic flows properly.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local maintanence points and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfmxconnect hwoffload 10ms 3 3ms timers",
                "Procedure": "CFM basic verifications for CFM HWOffload on Phy & Bundle Sub Up Mep-10ms & 3.3ms timers are tested by this test. This test verifies that CFM basic verifications, such as verifying CFM peer meps and local maintenance points, and showing Ethernet Cfm local meps detail, function correctly in a configured network where CFM is set up on both PEs on a VPWS AC-AC network. The configuration used for this test includes setting up CFM.\n\nThis test is triggered by the configuration: CFM\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntimer_value: \"10ms\" and \"3.3ms\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps and local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfmxconnect hwoffload triggers",
                "Procedure": "CFM (Connectivity Fault Management) test verifies basic verifications with triggers on a VPWS network AC-AC in setup class. It involves configuring CFM on both PEs, verifying peer MEPs, local maintenance points, and display of local MEP details using the \"show ethernet cfm local meps detail\" command. Additionally, it checks if pings and traceroutes through CFM are successful and verifies that traffic is flowing properly.\n\nThis test is triggered by configuring CFM on both PEs on a VPWS network AC-AC in setup class.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"router_reload\" and \"rpfo\" and \"flap_bundle_members\" and \"remove_readd_bundle_members\" and \"remove_readd_global_cfm\" and \"remove_cfm_intf\" and \"flap_interfaces\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps , local meps detail verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm xconnect upmep scale bundle",
                "Procedure": "CFM Xconnect Scale for Bundle Sub verifies the configuration of CFM 2k Upmep Scale for Bundle Sub, which was previously set up. The test checks that the CFM summary, peer Meps, and Cfm hwoffload are functioning correctly, and that traffic is flowing properly. This test is triggered by a setup in the CFM Configuration.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nCfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify cfm summary, peer meps , cfm hwoffload verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm xconnect upmep scale bundle trigger",
                "Procedure": "CFM (Connectivity Fault Management) is tested with various triggers to verify basic verifications. This test verifies that CFM works correctly when configured on both Provider Edge routers (PEs), specifically for a 2K Up Mep Bundle Sub Scale in the setup class. It checks if CFM peer meps, cfm summary and hardware offload are functioning as expected, and also verifies that traffic is flowing properly.\n\nThis test is triggered by the configuration of CFM on both Provider Edge routers (PEs).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"rpfo\" and \"bundle_members_add_remove\" and \"bundle_members_flap\"",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nCfm peer meps verification is performed.\nCfm local meps detail verification is performed.\nCFM: Verify CFM peer meps, cfm summary and hw-offload verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "evc_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Evc ping bundle subintf",
                "Procedure": "The test-case verifies the ping on a bundle subinterface and LLDP neighbours for both the bundle and its members. The configuration involves setting up Layer 2 physical and bundle subinterfaces, lacp revertive, Layer 2 VPN xconnects, dot1q, and dot1ad. This includes configuring l2vpn xconnect with lacp revertive settings. To verify, check the status of the L2VPN xconnect, ping the bundle, and list the LLDP neighbours.\n\nThis test is triggered by no specific conditions or events.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nL2vpn xconnect group name detail verification is performed.\nLldp neighbors verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Evc traffic phy int",
                "Procedure": "The test case verifies traffic on an L2 physical interface by configuring various features such as L2 physical and bundle interfaces, LACP revertive, L2VPN XConnect, dot1q, and dot1ad configurations. The relevant configurations for this test include L2VPN XConnect and LACP revertive. Verification includes checking unicast, multicast, and broadcast traffic over the Physical L2 interface.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nSpp node counters verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Evc traffic phy int no ptp",
                "Procedure": "The test-case verifies traffic on an L2 physical interface by configuring various features such as L2 physical and bundle interfaces, LACP revertive mode, L2VPN Xconnect, dot1q, and dot1ad. The configurations involve setting up L2VPN Xconnect and LACP revertive modes, while the verifications include checking unicast, multicast, and broadcast traffic over the Physical L2 interface.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nSpp node counters verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Evc l2main customether",
                "Procedure": "Traffic verification is performed on both physical and bundled Ethernet interfaces after custom settings are applied. The test involves configuring several L2 features, including physical and bundle interfaces, LACP revertive mode, L2VPN XConnect, a custom Ethernet type, 802.1Q tagging, and 802.1ad (also known as Q-in-Q) encapsulation. The verification process includes checking traffic on both types of interface with the custom Ethernet settings in place, and also verifying that pings can be sent successfully over these interfaces. This test is triggered by the absence of any specific conditions needing to be met for it to run.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Evc l2main customether ptp drop",
                "Procedure": "The test-case verifies traffic on L2 physical and bundle interfaces with custom Ether configurations. It configures L2 physical and bundle interfaces, LACP revertive, L2VPN xconnect, custom Ether, Dot1Q, and Dot1AD settings. The test assumes the following configurations: L2VPN xconnect, LACP revertive, and ethertype. Verifications include checking L2 physical and bundle interface traffic with custom Ether and successful pings on both interfaces. This test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Evc l2main event process restart",
                "Procedure": "The traffic verification process after various process restarts includes configuring l2 physical and l2 bundle interfaces, lacp revertive, l2vpn xconnect, dot1q, and dot1ad. Configurations include l2vpn xconnect and lacp revertive. The verification focuses on checking the traffic after process restarts for processes such as spio_ea, l2rib, l2fib_mgr, l2vpn_mgr, vlan_ea, and another instance of vlan_ea.\n\nThis test is triggered by a process restart of spio_ea, l2rib, l2fib_mgr, l2vpn_mgr, vlan_ea, or another instance of vlan_ea.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Evc l2main event process restart asr9k",
                "Procedure": "The test-case verifies traffic after various process restarts on an asr9k, which includes restarting the l2fib_mgr. It is configured with l2 physical and l2 bundle interfaces, lacp revertive settings, l2vpn xconnect configurations, dot1q, and dot1ad setups. Verifications include checking traffic after each process restart. This test is triggered by a process restart like 'spio_ea', 'l2rib', 'l2fib_mgr', 'l2vpn_mgr', or 'vlan_ea'.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hybrid phy bundle",
                "Procedure": "The test-case verifies traffic after hybrid xconnect and custom-ether by configuring L2 physical and bundle interfaces, LACP revertive, L2VPN XConnect hybrid, dot1q, and dot1ad protocols, as well as a custom ether configuration. The tests are based on three configurations: L2VPN XConnect, LACP revertive, and custom ether, with verification steps that include control traffic after hybrid xconnect and custom-ether.\n\nThis test is triggered by the occurrence of no specific triggers.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Phy subintf traffic check",
                "Procedure": "This paragraph describes a test case for verifying traffic on an L2 physical subinterface. The test involves configuring various features such as L2 bundle sub-interfaces, LACP revertive, L2VPN Xconnect, dot1q, dot1ad, and custom ether configurations. The test cases include verifying unicast, multicast, and broadcast traffic over the physical L2 sub-interface, as well as DHCP traffic verification. This test is triggered by none of the listed conditions.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle subintf ping check",
                "Procedure": "To verify ping on a bundle subinterface, the test-case checks that several configurations are in place, including L2 physical and bundle sub-interfaces, LACP revertive, L2VPN XConnect, dot1q, and dot1ad. These include specific setups for L2VPN XConnect and LACP revertive. The test then verifies that pings on the bundle subinterfaces are successful. This test is triggered by None.",
                "Pass/Fail Criteria": "Interface detail verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hybrid custom ether subintf",
                "Procedure": "To verify traffic on a phy sub-interface with custom ether, the configurations include setting up an L2VPN XConnect, enabling lacp revertive, and configuring dot1q and dot1ad. Additionally, a custom ether configuration is required. The verifications involve checking for tagged and untagged traffic on bundle sub-interfaces. \n\nThis test is triggered by verifying that no LACP bundles are formed due to the lacp revertive mode being enabled.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Phy subintf custom ether traffic",
                "Procedure": "Traffic on a physical subinterface with custom Ethernet settings is verified in this test case. The configuration includes the setup of L2VPN XConnect, LACP revertive mode, and custom Ethernet features, as well as dot1q and dot1ad configurations. To verify that tagged and untagged traffic flows correctly over the physical subinterfaces, specific verifications are performed. This test is triggered by the absence of any triggering events.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Control streams l2cp",
                "Procedure": "The test verifies control traffic on a physical subinterface by configuring various protocols and features such as L2VPN Xconnect, lacp revertive, dot1q, dot1ad, LLDP, CDP, and OAM. The configurations include enabling these features, while the verification involves checking for control stream traffic on the syncE-enabled physical subinterface.\n\nThis test is triggered by the absence of any specified conditions.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Event ping bundle commit replace",
                "Procedure": "To verify ping on a bundle after a commit replace operation, the following configurations must be in place: LACP revertive mode, L2VPN XConnect, dot1q, and dot1ad. The test case verifies that ping is successful after the operation is completed.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Interface detail verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cli pop1 asr9k",
                "Procedure": "This paragraph:\n\nThe test for unsupported CLI commands on ASR9k devices verifies that the \"rewrite pop1\" configuration does not work as expected, specifically with negative testing of the 'Rewrite POP1 Cli' command. The configurations used are standard rewrite POP1 settings and verifications include checking if the command fails as intended when attempting to use it in an unsupported manner.\n\nAnd this trigger sentence:\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Cli pop1",
                "Procedure": "The test-case for unsupported CLIs on DNX, specifically for pop1, involves verifying the operation of unsupported rewrite pop1 commands. These include configuring dot1q and dot1ad, as well as custom ether configurations. The test also verifies that negative Rewrite Pop1 cli operations are correctly handled. This test is triggered by the absence of any conditions.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Pop1 dot1q dot1ad",
                "Procedure": "Traffic for the rewrite pop1 feature with different encapsulation configurations is verified in this test-case. The configurations involve setting up Rewrite Pop1 CLI, dot1q, and dot1ad settings, while the verifications include checking traffic against Rewrite Pop1 CLI configurations. This test is triggered by the absence of any specific conditions or triggers.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pop1 dot1q custom ether",
                "Procedure": "This paragraph verifies traffic for pop1 using a custom ethernet configuration, which involves configuring custom ether, dot1q, and dot1ad protocols. It also reconfigures the pop1 CLI and sets up an L2VPN xconnect. The expected configurations include custom ether, dot1q, dot1ad, and pop1 settings, while verifications involve traffic checks using the pop1 CLI and custom ether.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cli pop2",
                "Procedure": "This test-case verifies the configuration of unsupported CLIs for rewrite pop2. It checks the following configurations: Rewrite Pop2 cli, dot1q, dot1ad, and custom ether. The verification ensures that a CLI commit for rewrite pop2 fails. This test is triggered by none.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Traffic pop2",
                "Procedure": "Traffic for the rewrite pop2 feature is verified in this test-case, which includes configurations such as dot1q and dot1ad, and verifications of traffic using the rewrite pop2 cli function within l2vpn xconnect.\n\nThis test is triggered by a lack of any triggers or conditions that would normally activate it.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Traffic pop2 custom ether",
                "Procedure": "Traffic verification involves checking that custom Ethernet settings are correctly applied to POP2 rewrite configurations, including configuration of the Dot1Q protocol, POP2 CLI interface, and L2VPN XConnect connections.\n\nThis test is triggered when no specific conditions have been defined to activate it.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Push1 cli ad",
                "Procedure": "The test case \"test_push1_cli_ad\" verifies the behavior of unsupported CLIs for rewrite push1 on DNX. The configuration involves setting up a scenario with both Rewrite Push1 cli and dot1ad enabled. To verify the expected outcome, the CLI Commit for rewrite push1 should fail. This test is triggered by none.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Push1 cli ad asr9k",
                "Procedure": "The test case verifies the unsupported CLIs for rewrite push1 on ASR9K routers. It checks if the configuration of a \"rewrite push1 cli\" with dot1ad fails when committing, as expected.\n\nThis test is triggered by no specific conditions or events.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Ping push1 dot1q traffic",
                "Procedure": "To verify ping traffic for push1 with dot1q, configure the system to use dot1q and a rewrite on push1 via the command line interface. Configurations include enabling dot1q and setting up a rewrite on push1, while verifications ensure that ping traffic passes through. This test is triggered by the absence of any specific conditions.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ping push1 dot1q traffic custom",
                "Procedure": "The configuration of a device with dot1q and a custom Ethernet address on the \"push1\" interface allows it to forward ping traffic correctly.\n\nThis test is triggered when there are no specific triggers set.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cli push2",
                "Procedure": "This test-case verifies the functionality of the unsupported CLIs in rewrite push2 on DNX, specifically testing the Configure dot1q, Configure dot1ad, and Configures custom ether options. The configurations used include Rewrite Push2 cli, dot1q, dot1ad, and custom ether, while the verifications check for the expected failure of the CLI Commit for rewrite push2. \n\nThis test is triggered by the absence of any required configurations or settings.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Cli push2 asr9k",
                "Procedure": "The test-case verifies the unsupported CLIs for rewrite push2 on ASR9k devices. It checks that the rewrite push2 CLI fails when committing configurations, including dot1q, dot1ad, and custom ether settings. \n\nThis test is triggered by there being no triggers specified.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Ping push2 dot1q traffic",
                "Procedure": "The test verifies the passing of ping traffic for a push2 device with a dot1q configuration and rewrite settings. Configurations include dot1q and rewrite push2, while verifications ensure that ping traffic passes through successfully. This test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ping push2 dot1q traffic custom",
                "Procedure": "To verify ping traffic for push2 with custom ether, the test-case checks that pinging works as expected when using dot1q configurations, rewriting push2, and setting a custom ether address.\n\nThe test is triggered by no specific action or event occurring in the system.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cli translate 1 1 asr9k",
                "Procedure": "The test case verifies the unsupported CLIs for the translate_1_1 feature on ASR9k devices. It tests three different configurations: rewriting the translate 1_1 CLI, configuring dot1q and dot1ad options, and customizing ether settings. The verification checks that a CLI commit fails for the translate 1_1 configuration.\n\nThis test is triggered by the absence of any triggers.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Cli translate 1 1",
                "Procedure": "The test case verifies the CLIs for translating packets on DNX, specifically focusing on unsupported configurations such as rewrite translate 1_1, dot1q, dot1ad, and custom ether. Configurations include rewriting translation 1_1 with these options, while verifications ensure that CLI commits fail when attempting to apply these unsupported configurations.\n\nThis test is triggered by the absence of supported configurations.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Ping trans 1 1 traffic",
                "Procedure": "Ping traffic for translation 1_1 is verified. The test case involves verifying that ping traffic passes when the configurations of dot1q, dot1ad, and rewrite translation 1_1 are set up correctly, along with an L2VPN Xconnect configuration. To achieve this, the following settings are taken into account: the use of dot1q, dot1ad, and rewrite translation 1_1, as well as the l2vpn xconnect. The test verifies that ping traffic should successfully pass through when these configurations are properly implemented.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ping trans 1 1 custom traffic",
                "Procedure": "The test case verifies ping traffic for rewriting translation 1.1 with a custom Ethernet configuration on the DNX device. The configurations include dot1q, dot1ad, and l2vpn xconnect options, as well as a custom Ethernet setup. To pass the test, ping traffic should successfully pass through the system when rewrite translation 1.1 is used.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Ping trans 1 1 custom traffic asr9k",
                "Procedure": "Verify ping traffic for a custom Ethernet configuration with translate 1_1 on an ASR9k device. This involves configuring and verifying various settings, including dot1q, dot1ad, l2vpn xconnect, and custom ether options, to ensure that ping traffic can pass through the network successfully.\n\nThis test is triggered by a lack of specified triggers.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Cli translate 1 2",
                "Procedure": "The rewrite translate_1_2 CLI verifies that certain configurations cause it to fail when committing. These configurations include Rewrite translate_1_2, dot1q, dot1ad, and custom ether settings.\n\nThis test is triggered by the absence of any specific conditions.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Cli translate 1 2 asr9k",
                "Procedure": "The test case verifies the unsupported CLIs for the rewrite translate_1_2 feature on ASR9k. It configures various features such as dot1q, dot1ad, and custom ether, along with rewrite translate_1_2 configurations. The verification checks that committing the rewrite translate_1_2 CLI results in a failure.\n\nThis test is triggered by there are no triggers defined.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Ping trans 1 2 traffic",
                "Procedure": "Ping traffic verification for configurations including dot1q, dot1ad, and L2VPN xconnect is done to ensure rewrite translation 1_2 passes successfully.\n\nThis test is triggered by the absence of any specific triggers.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ping trans 1 2 custom traffic",
                "Procedure": "The verification of ping traffic for the translation of layer 2 packets from 1 to 2 with a custom Ethernet configuration on a DNX device involves several configurations and verifications. The test case checks whether a CLI commit fails when rewriting translate 1_2 with custom ether is enabled. It includes configurations such as dot1q, dot1ad, rewrite translate 1_2, l2vpn xconnect, and custom ether, along with various verifications to ensure the correct functioning of these components.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ping trans 1 2 custom traffic asr9k",
                "Procedure": "The test case verifies ping traffic for rewrite translate 1_2 with custom Ethernet on the ASR9k. It confirms that CLI commands are correctly configured for dot1q, dot1ad, and l2vpn xconnect, as well as custom Ethernet configurations. However, when attempting to commit a configuration for rewrite translate 1_2 with custom Ethernet, the CLI command should fail. This test is triggered by none of the above configurations.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ping trans 2 2 traffic",
                "Procedure": "The test case verifies ping traffic for the configuration of a layer two VPN (L2VPN) xconnect with dot1q, dot1ad, and rewrite translation enabled, specifically for rewrite translation version 2_2.\n\nThis test is triggered when none.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ping trans 2 2 traffic custom ether",
                "Procedure": "Ping traffic verification for a specific configuration with custom Ethernet settings involves verifying that ping traffic passes through with the configurations enabled. The test case checks for successful ping traffic with dot1q, dot1ad, rewrite translate 2_2, custom ether, and l2vpn xconnect configurations in place.\n\nThis test is triggered by the absence of any triggers, indicating it has no specific events or conditions that would cause it to run.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pop1 dot1q dot1ad event",
                "Procedure": "Traffic convergence is verified after unconfig/config of an xconnect with rewrite pop1. The following configurations are used for this test-case: dot1q, dot1ad, l2vpn xconnect, and pop1. To verify traffic flow, the system checks that traffic converges after reconfiguring the l2vpn xconnect.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pop1 dot1ad event",
                "Procedure": "Traffic passing through a device that supports 802.1AD (dot1ad) and L2VPN XConnect with Rewrite POP1 configuration needs to be verified after adding or removing ad encapsulation. To set this up, configure the system for dot1ad, rewrite POP1, and L2VPN XConnect configurations. The goal is to ensure that traffic continues to pass through successfully when ad encap is added or removed. This test is triggered by verifying a system with no specific requirements.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pop1 dot1q custom ether event",
                "Procedure": "Traffic verification occurs for pop1 after removing and adding a custom Ethernet connection with rewrite enabled for pop1. The configuration involves the dot1q, xconnect, pop1, and custom Ether settings. To pass this test, traffic must successfully flow through the network following the removal and addition of the custom Ethernet link with rewrite enabled for pop1.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Push1 process crash event",
                "Procedure": "The process crash event triggers a verification of ping traffic for the configuration with dot1q, dot1ad, and xconnect settings applied to push1. Configurations include dot1q, dot1ad, xconnect, and push1. Verification checks that ping traffic passes after a process crash has occurred.\n\nThis test is triggered by a process crash.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Push1 process crash event asr9k",
                "Procedure": "The test-case verifies ping traffic after a process crash event for asr9k devices that include the l2fib_mgr, which also have configurations of dot1q, dot1ad, xconnect, and push1. The test checks whether ping traffic passes. It is triggered by a process crash event.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pop2 config event",
                "Procedure": "Traffic verification is performed after configuring and unconfiguring the POP2 CLI with specific settings including dot1q, dot1ad, a rewritten POP2 configuration, custom Ethernet, and L2VPN xconnect. The configurations used include L2VPN xconnect, POP2, dot1ad, dot1q, and custom Ethernet, while verification checks that traffic flows as expected after the changes are made.\n\nThis test is triggered by no specific conditions or events.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Push2 xconnect bridge event",
                "Procedure": "When verifying ping traffic for a device called \"push2\", the configuration or de-configuration of a \"bridge domain\" should have priority over an \"L2VPN XConnect\" interface. The test case involves configuring and then removing a bridge domain, before restoring it and removing its L2VPN XConnect counterpart. Configurations include the use of L2VPN XConnect, bridge-domain, and push2. Verification checks that ping traffic passes through both configurations. This test is triggered by a specific configuration requirement for priority over other options.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Xconnect scale",
                "Procedure": "Traffic verification on a physical subinterface involves configuring dot1q and dot1ad protocols as well as setting up an L2VPN xconnect configuration. The test case checks that traffic passes successfully with scaled traffic stream and xconnect configurations in place. It also includes verifications to ensure that traffic continues to pass when L2VPN is removed and then rolled back. This test is triggered by removing L2VPN and checking the traffic, or by rolling back L2VPN and verifying the traffic's continued passage.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Xconnect scale phy bundle",
                "Procedure": "The test-case verifies traffic with scaled traffic stream and xconnect by configuring dot1q and l2vpn xconnect features. The configurations involve dot1q and l2vpn xconnect, while the verifications ensure that traffic passes for scaled xconnect. To set up the test, remove l2vpn and check if traffic is still passing, then rollback the l2vpn configuration and verify traffic once more.\n\nThis test is triggered by removing l2vpn and checking traffic, then rolling back l2vpn and checking traffic again.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Xconnect with rewrite push 2 cscvs45062",
                "Procedure": "Traffic on an L2 physical subinterface with encapsulation untagged and rewrite push 2 is verified through the following configurations and verifications. Configurations include setting up L2 physical subinterfaces, configuring L2VPN xconnect, and configuring rewrite push 2. Verifications involve checking for unicast traffic over the physical L2 subinterface and verifying statistics.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "l2mtu_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "L2mtu xconnect send traffic normal",
                "Procedure": "Normal L2MTU traffic with physical interface xconnect is verified by configuring interfaces with VLANs, setting the L2MTU on each interface, and establishing a local xconnect over access circuits. The verification process includes checking that the L2VPN connection is established and that normal traffic is passing through it.\n\nThis test is triggered by configuration of l2mtu in the device's setup.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify the traffic flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2mtu xconnect send traffic equal",
                "Procedure": "Interfaces are configured with VLANs, Layer 2 MTU settings, and a local XConnect over AC interface. The L2VPN XConnect is then verified, followed by verification of equal Layer 2 Maximum Transmission Unit (MTU) traffic between the interfaces using physical interface XConnect.\n\nThis test is triggered by configuring interfaces with VLANS, setting L2MTU on them, configuring a local xconnect over ac interfaces and verifying l2vpn xconnet.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify the traffic flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2mtu with traffic greater than mtu",
                "Procedure": "The L2MTU test on xconnect using greater MTU traffic verifies that data packets larger than the Maximum Transmission Unit (MTU) can be transmitted over an XConnect interface without error. To perform this test, configure the Access Concentrator interfaces to use encapsulation and set a local bridge domain for the interfaces. Then verify that the bridge domains are properly configured and that the L2MTU is correctly set on each interface. Finally, ensure that traffic greater than MTU can be successfully transmitted over the XConnect interface.\n\nThis test is triggered by specifying a configuration with an L2MTU value.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nL2mtu: Verify l2mtu on interfaces verification is performed.\nTraffic: Verify traffic greater than mtu verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "And verify l2mtu setting 9646 show command",
                "Procedure": "The L2MTU Configuration test verifies that the MTU for physical interfaces is properly configured. The test sets up AC interfaces with encapsulation default, configures Layer 2 MTU on the interfaces, and places them in a local bridge domain. It then checks the configuration of the bridge domains and ensures that the Layer 2 MTU settings are correct on each interface. This test is triggered by the configuration setting \"l2mtu\".",
                "Pass/Fail Criteria": "Interface detail verification is performed.\nL2MTU : l2mtu configuration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "And verify l2mtu greater than 9646",
                "Procedure": "The L2MTU Configuration test using an abnormal value verifies that a physical interface can handle an abnormal maximum transmission unit (MTU) by configuring AC interfaces with encapsulation default, setting the L2MTU on interfaces, placing interfaces in a local bridge domain, verifying the bridge domains, and checking the L2MTU on the interfaces. This test is triggered by the configuration of 'l2mtu'.",
                "Pass/Fail Criteria": "L2MTU : Abnormal l2mtu configurations verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "And verify setting different mtu work",
                "Procedure": "The L2MTU configuration test verifies the functionality of different MTUs for physical interfaces. This involves configuring AC interfaces with default encapsulation, setting L2MTU on interfaces, and configuring those interfaces within a local bridge domain. The test also checks the status of the bridge domains and confirms that L2MTU settings are applied to the interfaces.\n\nThis test is triggered by changing the \"l2mtu\" configuration value from its initial state.",
                "Pass/Fail Criteria": "Interface detail verification is performed.\nL2MTU : Different l2mtu configurations verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2mtu with untagged less than mtu",
                "Procedure": "Physical untagged L2MTU traffic is verified by configuring AC interfaces for encapsulation untagged, setting L2MTU on interfaces, placing interfaces in a local bridge domain, verifying the bridge domains, and checking the L2MTU on the interfaces. \n\nThis test is triggered by configuration changes that affect the local MTU value.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify the traffic flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2mtu with untagged traffic greater than mtu",
                "Procedure": "Physical untagged traffic with a larger MTU is verified through this test. The AC interface is configured for encapsulation without tags, and the L2MTU is set on the interfaces. These interfaces are then placed in a local bridge domain, and the bridge domains are verified. Finally, traffic with an MTU greater than the default value is confirmed to be passing successfully.\n\nThis test is triggered by configuring all AC interfaces to use encapsulation without any VLAN tags.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify the traffic exception verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2mtu xconnect send traffic greater",
                "Procedure": "Interfaces are configured to have VLANs, and Layer 2 MTU is set on the interfaces. A local XConnect connection is also established over access circuit interfaces. The configuration includes a setting for Layer 2 MTU, specified as 'l2mtu'. This test is triggered by an increase in L2MTU traffic through a physical interface xconnect.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify the traffic exception verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2mtu deleting and traffic being blocked",
                "Procedure": "L2MTU traffic is verified without a specific configuration, which involves configuring interfaces with VLANs, setting L2MTU on these interfaces, and establishing local XConnect over Access Circuit (AC) interfaces. The test then verifies the L2VPN XConnect connection and checks for any exceptions in traffic flow.\n\nThis test is triggered by changing the value of 'l2mtu' to a specific number in the configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify the traffic exception verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Syntax if bundle mtu properly displayed",
                "Procedure": "To verify the L2MTU configuration for bundle interfaces, configure two bundle interfaces with a local XConnect and set up local bridge domains. Then check that the bundle and bridge domain statuses are correct, and finally confirm that the L2MTU is correctly configured on the bundle interfaces.\n\nThis test is triggered by specifying an L2MTU in the configuration.",
                "Pass/Fail Criteria": "Interface detail verification is performed.\nL2MTU: Verify l2mtu for bundle interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle mtu 9646",
                "Procedure": "Two bundle interfaces are configured with a local xconnect, and bridge domains are set up. The status of the bundles and bridge domains is verified, confirming that they are operational. Finally, it's confirmed that the L2MTU traffic on both bundle interfaces is equal.\n\nThis test is triggered by the configuration of an 'l2mtu' parameter.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify equal l2mtu of size 9646 traffic for bundle interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle mtu unpermitted",
                "Procedure": "Interfaces on a device are configured to use a translate tag, and the local bridge domain is also set up. This test verifies that these configurations enable a larger L2MTU with traffic that uses the translate tag.\n\nThis test is triggered by configuring interfaces and setting up the local bridge domain with L2MTU in the configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify  greater than 9646 frame size traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "With traffic ipv4",
                "Procedure": "The test verifies that the Layer 2 Maximum Transmission Unit (L2MTU) is equal to IPv4 traffic for a physical interface. To configure this, assign an IPv4 address to the interface and set an equal MTU value. Then verify that the L2MTU is indeed equal to IPv4 traffic during configuration.\n\nThis test is triggered by configuring an IPv4 address on an interface with an equal MTU setting.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify traffic is flowing properly. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Fragmentation with traffic",
                "Procedure": "The test is designed to verify fragmentation traffic when the Layer 2 Maximum Transmission Unit (L2MTU) is increased for IPv4 traffic. To achieve this, an IPv4 address is configured on the interface and the L2MTU is set higher than usual. The test then verifies that fragmentation traffic is functioning correctly as a result of the increased L2MTU.\n\nThis test is triggered by configuring an IPv4 address on an interface and increasing its MTU to simulate larger-than-usual packets.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify traffic is flowing properly. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mtu with reduced mtulevel",
                "Procedure": "When verifying L2MTU with IPv4 traffic, the process involves configuring an IPv4 address on an interface, setting a lower MTU level, and then checking that the L2MTU configuration is correct. The configuration for this test includes setting the Layer 2 Maximum Transmission Unit.\n\nThis test is triggered by configuring an IPv4 address on interfaces, configuring a reduced MTU, and verifying that the L2MTU is correctly configured.",
                "Pass/Fail Criteria": "L2MTU: Verify l2mtu configuration. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Traffic pass",
                "Procedure": "Two bundle interfaces are configured with a Bundle local xconnect, and their local and L2VPN xconnect statuses are verified. The bundle status is also checked. The configuration of the L2MTU is specified as 'l2mtu'. This test is triggered by configuring two bundle interfaces for the Bundle local xconnect.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify equal l2mtu of size 9646 traffic for bundle interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Traffic max",
                "Procedure": "A network is configured with a maximum Layer 2 Maximum Transmission Unit (L2MTU) of \"l2mtu\" for two bundle interfaces that use Bundle local cross-connect. The test then verifies the status of these bundle interfaces and checks that they are set up correctly as an L2VPN xconnect, ensuring equal traffic flow across both interfaces.\n\nThis test is triggered by a configuration change that sets the maximum L2MTU value to \"l2mtu\" for a Bundle local cross-connect.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify greater l2mtu traffic exception verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mtu 9216",
                "Procedure": "To verify the function of Equal L2MTU with Translate Tag, the configuration involves setting up interfaces with a Translate Tag and configuring the local bridge domain. The bridge domain's status is then verified, followed by sending equal L2MTU traffic to test its functionality.\n\nThis test is triggered when configuring the l2mtu in the configuration section.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify 9646 frame size traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart and send traffic",
                "Procedure": "L2MTU traffic is verified after a process restart, which involves configuring access control (AC) interfaces with VLANs, setting the L2MTU on interfaces, and configuring local Xconnect. The test also checks the status of L2VPN Xconnect and verifies that there is no impact on traffic after the process is restarted.\n\nThis test is triggered by the presence of a 'l2mtu' entry in the configuration.",
                "Pass/Fail Criteria": "Traffic: Verify 9646 frame size traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Traffic mtu 9646",
                "Procedure": "L2MTU traffic is verified after a process restart by configuring AC interfaces with VLANs, setting the L2MTU on the interfaces, and establishing a local XConnect. The test then verifies the status of the L2VPN XConnect and checks for normal traffic flow following the process restart.\n\nThis test is triggered by an L2MTU configuration involving vlans.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify 9646 frame size traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Traffic mtu unpermitted",
                "Procedure": "The configuration of the system includes setting up AC interfaces with VLANs, configuring L2MTU on interfaces, and establishing a local XConnect. After this setup, the system is verified to be functioning correctly in terms of L2VPN XConnect status and larger L2MTU traffic. This test is triggered by configuring l2mtu on the system configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify unpermitted traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mtu physical l2 local bridge domain smaller",
                "Procedure": "This test is triggered by verifying that the configuration includes an L2 MTU setting.\n\nThe test verifies smaller L2 local bridge domain traffic by configuring AC interfaces with VLANs, L2 MTU on interfaces, and a local bridge_domain. It then checks the status of the bridge_domain and verifies that it allows traffic of lesser than MTU size to pass through.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify traffic of lesser than mtu size verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "9646 mtu physical l2 local bridge domain shut no shut",
                "Procedure": "The test configures AC interfaces with VLANs, sets L2MTU on interfaces, and sets up a local bridge domain. It then verifies the bridge domain's status, shuts down an interface, brings it back online, and checks for L2MTU traffic to ensure it is functioning correctly after the interface flap.\n\nThis test is triggered by configuring AC interfaces with VLANs.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "9646 mtu physical l2 local bridge domain packets greater",
                "Procedure": "The test for the L2 local bridge domain greater traffic verifies that data can be transmitted over a network connection without errors. To set up this test, the Access Control (AC) interfaces are configured with VLANs, the L2 MTU is configured on each interface, and the local bridge domain is also configured. The status of the bridge domain is then verified to ensure it's functioning as expected. Finally, traffic is transmitted that exceeds the MTU size and its transmission is confirmed.\n\nThis test is triggered by configuration of an L2MTU setting.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTraffic: Verify traffic of greater than mtu size verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfd cscvq91837",
                "Procedure": "The test verifies that there are no error flags after configuring the MTU (Maximum Transmission Unit) size on all four subinterfaces of a parent interface. This is done by first setting the MTU size for the parent interface, and then for each of its four subinterfaces, in sequence: 9160, 9130, 1957, and 1560. Once this configuration is completed, no error flags should be present on the fourth subinterface.\n\nThis test is triggered by configuring an Mtu setting on a parent interface with at least four subinterfaces.",
                "Pass/Fail Criteria": "Show ethernet infra internal ea subs verification is performed.\nNo error flags verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "g8032_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Erps timing oir",
                "Procedure": "ERPS convergence timing during interface OIR is tested by verifying that all UUTs have ERPS ring configured, traffic is running smoothly, then performing an interface OIR. The ERPs should be in a protection state and the convergence timing should also be verified, with no crashes or core files recorded. This test is triggered when configuring specific network protocols including G8032, L2VPN, and OSPF.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nArp status verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erps timing switch",
                "Procedure": "ERPS convergence timing is tested during both manual and force switch scenarios. The setup involves configuring ERPS rings on all units under test (UUTs), verifying that traffic is stable, then initiating the traffic flow, simulating a network failure by flapping an interface, confirming that ERPS protection is engaged, assessing convergence timing, and inspecting for any resulting crashes or core files generated. Configurations include G8032, L2VPN, and OSPF protocols.\n\nThis test is triggered by manual or force switch events that necessitate the examination of ERPS convergence timing within the network setup involving G8032, L2VPN, and OSPF configurations.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nArp status verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "States scale",
                "Procedure": "The test verifies ERPS states for scaled cases. It involves configuring ERPS ring on all the units under test, verifying that the ERPS states are up, and confirming that traffic is flowing correctly. Additionally, it checks for any crash or core files. The test can be applied to various configurations, including G8032, L2VPN, and OSPF.\n\nThis test is triggered by the need to verify ERPS states in scaled scenarios.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shutdown interface",
                "Procedure": "When shutting down an interface, the ERPS protocol should enter a protection state. This test involves verifying this behavior by configuring ERPS on all units under test (UUTs), shutting down the interface, checking that the ERPS are in protection mode, and ensuring there are no crash or core files generated. Configurations used for this test include G8032, L2VPN, and OSPF.\n\nThis test is triggered by the shutdown of an interface.",
                "Pass/Fail Criteria": "Shut verification is performed.\nErps spanning tree verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Noshut interface",
                "Procedure": "The test begins by configuring ERPS rings on all Units Under Test (UUTs), then shutting and immediately re-opening the interface. Next, it verifies that ERPS has converged and that traffic is flowing properly. Finally, the test checks for any crash or core files generated during this process.\n\nThis test is triggered by a configuration of G8032, L2VPN, or OSPF on the UUTs.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verification verification is performed.\ntraffic verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Non revertive",
                "Procedure": "The test verifies ERPS functionality on a non-revertive profile. It involves configuring ERPS_RING on all Under Test Units (UUTs), shutting down an interface, and then configuring ERPs for a non-revertive profile before unshutting the interface. The process also includes verifying that ERPS has converged, checking that traffic is flowing properly, and examining for any crash or core files generated during the test. Additionally, the configurations used are G8032, L2VPN, and OSPF for the ERPs on a non-revertive profile.\n\nThis test is triggered by configuring an ERPS ring on all UUTs with specific protocols such as G8032, L2VPN, and OSPF enabled for the non-revertive profile.",
                "Pass/Fail Criteria": "Shut verification is performed.\nNoshut verification is performed.\nErps spanning tree verification is performed.\nTraffic verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erps ospf",
                "Procedure": "The test verifies Ethernet Ring Protection Switching (ERPS) with Open Shortest Path First (OSPF) level 3. To conduct this test, ERPs must be configured on all Under Test Units, along with OSPF configuration. Next, verify the OSPF states are correct and that ERPS has converged. Additionally, ensure that traffic is flowing properly between devices and check for any crash or core files generated during the process. This test is triggered by the need to validate ERPs functionality when used in conjunction with OSPF/L3 configurations, including G8032, L2VPN, and OSPF setups.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nErps spanning tree verification is performed.\nTraffic verification is performed.\nopsf verifcation verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Unblockrpl ospf",
                "Procedure": "To test ERPS with OSPF/L3 after unblocking RPL, configure ERPS_RING on all the UUTs, configure OSPF, and then unblock RPL. This test verifies that ERPS is working properly with OSPF/L3 - verify the OSPF states, check for ERPS convergence, ensure traffic is flowing as expected, and examine the system for any crash or core files resulting from this configuration. Configurations used in this scenario include G8032, L2VPN, and OSPF.\n\nThis test is triggered by the unblocking of RPL on UUTs configured with ERPS_RING and OSPF.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nTraffic verification is performed.\nopsf verifcation verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Removeadd erps",
                "Procedure": "This paragraph describes a test that verifies the function of an Erps (Ethernet Ring Protection Switching) closed ring. The test involves configuring Erps_ring on all units under test (UUTs), removing this configuration, rolling back the removed configuration, verifying that traffic is flowing properly, and checking for crash or core files resulting from the test.\n\nThis test is triggered by configurations such as G8032, L2VPN, OSPF being configured on the closed Erps ring.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Removeadd l2vpn",
                "Procedure": "The test verifies the ERPS closed ring functionalties by configuring `erps_ring` on all UUTs, removing L2VPN configuration, and rolling back any removed configurations. Traffic should be flowing properly with no crashes or core files generated. The system is configured as follows: the ERPS ring is set to closed mode, G8032 protocol is enabled, and OSPF routing is used in conjunction with L2VPN.\n\nThis test is triggered by configuring the device under test (UUT) with a closed-ring topology that utilizes the ERPS protocol and its supporting protocols including G8032, L2VPN, and OSPF.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart",
                "Procedure": "Tests for process restart on both Local Concentrator (LC) and Remote Port concentrator (RP) involve verifying ERPS functionality with a 4-node topology for two rings, both with scale and enabled for various protocols like CFM/OSPF/ISIS. Additionally, the tests cover ERPS functionality with dot1q rewrite pop/push for RAPS channel, scaled VLANs and scaled BVI interfaces, traffic scaling, and checking for crashes or core files. Configurations include G8032, L2VPN, and OSPF.\n\nThis test is triggered by the configurations including G8032, L2VPN, and OSPF.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"spp\" and \"ifmgr\" and \"aib\" and \"netio\" and \"erp_io\" and \"erp_ctrl\" and \"l2vpn_mgr\"",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verifcation after process restart verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart fib mgr",
                "Procedure": "The test process restarts on both the LC and RP fib_mgr systems to verify ERPS functionality under various configurations. This includes verifying that ERPS works correctly with a 4-node topology for two rings with scaled VLANs and bridged virtual interfaces, as well as with scaled VLANs but no bridging. It also checks traffic patterns in these scenarios and searches for crash or core files generated by the system. Additionally, other specific tests are performed using different protocols such as CFM/OSPF/ISIS enabled, and dot1q rewrite operations. The configurations used to run these tests include G8032, L2VPN, and OSPF.\n\nThis test is triggered by various configurations including G8032, L2VPN, and OSPF.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verifcation after process restart verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Reload",
                "Procedure": "To test the router or card, start by reloading it and verifying that it comes up within the expected time. The ERPS functionality should then be verified in a four-node topology with two rings using different protocols such as cfm/ospf/isis enabled. Additionally, test the system's ability to handle 4 node topologies with two rings and dot1q rewrite pop/push for RAPS channel. You should also verify the system's performance under scaled VLANs and BVI interfaces, as well as the traffic generated by scaling. Finally, check if any crash or core files are produced during the test.\n\nThis test is triggered by configurations including G8032, L2VPN, and OSPF.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"rpfo\" and \"lc_oir\" and \"reload_active_rp\" and \"calvados\" and \"xr_vm_reload\" and \"mpareload\" and \"mpaflap\"",
                "Pass/Fail Criteria": "Standby rp verification is performed.\nErps spanning tree verification is performed.\nTraffic verification is performed.\nErps verifcation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Msfs unshut",
                "Procedure": "The test verifies the functionalities of the manual and force switches by configuring ERP-S ring on all the units under test. This includes setting up the manual switch and force switch configurations, verifying that ERPS is converged, checking for proper traffic flow, and looking for any crash or core files generated during the process. The test scenarios involve removing the original switch configuration, then configuring both manual and force switches using G8032, OSPF, and L2VPN settings.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nmanual swicth and forec switch funcationalities verification is performed.\ncash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mffs shutdown",
                "Procedure": "After shutting down the interface, test the functionality of both the manual and force switches. This test verifies that the switches are working properly after a shutdown by first configuring ERPS rings on all units under test, then setting up the manual and force switches, verifying that ERPs is converged, checking for proper traffic flow, and inspecting for any crash or core files. The configurations used in this test include removing the switch configuration, reconfiguring with manual and force switches enabled, and using G8032, OSPF, and L2VPN settings. This test is triggered by verifying that the shutdown of an interface properly resets its operational state so that it can be manually overridden.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nmanual swicth and forec switch funcationalities verification is performed.\ncash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac flush",
                "Procedure": "This paragraph tests the MAC flush functionality on a device. The test involves configuring ERPS rings on all units under test (UUTs), then verifying that the MAC address has been flushed and that traffic is flowing correctly without any crashes or core files.\n\nThis test is triggered by the configurations of G8032, OSPF, L2VPN.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMac flush verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erps converge",
                "Procedure": "The ERPS convergence test verifies that the open ring functionality of ERPs is working correctly. To run this test, configure ERPS on all devices under test (UUTs) to use a single instance. Next, verify that ERPS has converged and that traffic is flowing properly between them. Additionally, check for any crash or core files that may have been generated during the test. This test is triggered by configuring the ERPs for a single instance with settings such as G8032, OSPF, or L2VPN.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verification verification is performed.\nErps convergence verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vlan exclusion",
                "Procedure": "The test verifies ERPS convergence for a specific exclusion list by configuring the exclusion list and verifying that ERPs is converged. It then checks that traffic is flowing properly, looks for crash or core files, removes L2VPN, verifies traffic flow, reloads the router, and repeats the verification process. The configuration involves setting up an exclusion VLAN list with G8032, OSPF, and L2VPN.\n\nThis test is triggered by the need to verify ERPS convergence for a specific exclusion list as part of the configuration involving G8032, OSPF, and L2VPN.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nInterface detail verification is performed.\nErps spanning tree verification is performed.\nexclusion vlan list verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ring open",
                "Procedure": "The test verifies the ERPS open ring functionality. To perform this test, configure ERPS_RING on all the UUTs, then set up an ERPS open ring configuration. Next, verify that ERPS is converged and check that traffic is flowing properly through the network. After running the test, inspect for crash or core files to ensure system stability. This test is triggered by configurations such as setting the ERPS ring to open, with options including G8032, OSPF, or L2VPN protocols enabled.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ring closed",
                "Procedure": "The test verifies the ERPS (Ethernet Ring Protection Switching) closed ring functionality by first configuring ERPS on all units under test (UUTs), followed by setting up the ERPS closed ring configuration. The ERPS convergence and proper traffic flow are then verified, after which the ERPS configuration is removed and the UUTs' behavior is checked again to ensure normal traffic flow resumes. Additionally, any crash or core files generated during the process are examined. Configurations considered for this test include setting up the ERPS ring as a closed loop with G8032, OSPF (Open Shortest Path First), and L2VPN protocols.\n\nThis test is triggered by configuring the UUTs to use a closed ERPS ring topology with either G8032, OSPF, or L2VPN protocols.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nErps verification verification is performed.\nCheck for crash/core files verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "g8032_ap_bundle.py": {
        "test_cases": [
            {
                "Test Case Name": "States scale",
                "Procedure": "The test aims to verify the ERPS states in various scaled scenarios by configuring ERPS Ring on all Unite Under Test (UUT) devices and checking that ERPS states are up. It also verifies proper traffic flow and checks for any crash or core files generated during the process.\n\nThis test is triggered when configurations such as G8032, OSPF, L2VPN, or Bundle are set up.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nErps spanning tree verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shutdown bundle",
                "Procedure": "After shutting down the bundle, this test verifies that the ERPS ring is properly configured and functioning in a protected state. The test involves configuring ERPS on all Universal Test Units (UUTs), shutting down the bundle, verifying that the ERPS are in protection mode, and checking for any crash or core files generated by the process. This test is triggered when configuring protocols such as G8032, OSPF, L2VPN, or Bundle on all UUTs.",
                "Pass/Fail Criteria": "Shut verification is performed.\nErps spanning tree verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Noshut bundle",
                "Procedure": "After configuring ERPS on all units under test (UUTs), verifying that ERPS is converged and that traffic is flowing properly, checking for crash or core files, the bundle is unshut. This test verifies states after unshutting the bundle by configuring ERPS ring on all UUTs, ensuring ERPS is converged, verifying traffic is flowing properly, and checking for crash/core files. Configurations include G8032, OSPF, L2VPN, and Bundle.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Non revertive",
                "Procedure": "To verify Enhanced Ring Protection (ERPS) functionality for a non-revertive profile, ensure ERPS is configured on all Under Test Units (UUTs), and then shut down the bundle. Next, configure ERPS to use a non-revertive profile with settings such as G8032, OSPF, L2VPN, and Bundle configurations in place. After re-establishing network connectivity by unshutting the bundle, verify that ERPS is converged and traffic is flowing properly across the network.\n\nThis test is triggered when the system administrator wants to validate the operation of Enhanced Ring Protection with a non-revertive profile configuration.",
                "Pass/Fail Criteria": "Shut verification is performed.\nNoshut verification is performed.\nErps spanning tree verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Removeadd erps",
                "Procedure": "The test verifies the ERPS closed ring functionality. The UUTs are configured with ERPS_ring, and then all configuration is removed. A rollback of this removal is performed, followed by verification that traffic is flowing as expected. In addition, checks for crash or core files are made to ensure the system's stability. Configurations tested include a closed ERPS ring using G8032, OSPF, L2VPN, and Bundle.\n\nThis test is triggered by configuring the ERPS ring to be in a closed state.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hqos erps scale",
                "Procedure": "The test verifies that Enhanced Ring Protection Switching (ERPS) states are up and functioning correctly in scaled cases. The UUTs are configured with ERPS_ring on all interfaces, and the test checks that traffic is flowing properly between them. It also verifies that shaping is working as expected on the bundle interface enabled for ERPS. Additionally, the test looks out for crash or core files and ensures that HQoS profiles are enabled for proper operation. This test is triggered by specific configurations including G8032, OSPF, L2VPN, Bundle, and HQoS.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTgenchecktrafficerror verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Reload",
                "Procedure": "The router or card needs to be reloaded, and the router should come up in the expected time. To verify ERPS functionality, we test it with a four-node topology for two rings without any additional protocols enabled, with the same topology but with cfm/ospf/isis enabled, with dot1q rewrite pop/push configured for RAPS channel support, and finally with scaled VLANs and BVI interfaces set up. We also test traffic handling at scale and check for crash or core files generated during the process. The configurations used in this testing include G8032, OSPF, L2VPN, and Bundle.\n\nThis test is triggered by a configuration that includes G8032, OSPF, L2VPN, and Bundle.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ErpsBase.get_process_list(ApData.zap, 'test_reload')\"",
                "Pass/Fail Criteria": "Standby rp verification is performed.\nErps spanning tree verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart",
                "Procedure": "The tests process restart on both LC (Label Control) and RP (Route Processor) to verify the ERPS (Ethernet Ring Protection Switching) functionality in various scenarios. These include verifying that ERPS works with a four-node topology for two rings with scaled VLANs, scaled BVI interfaces, and enabled protocols such as CFM (Connectivity Fault Management), OSPF (Open Shortest Path First), and ISIS (Intermediate System to Intermediate System). Additionally, the tests verify traffic flow and check for any crashes or core files generated by the system. The configurations tested include G8032, L2VPN, OSPF, and Bundle.\n\nThis test is triggered by the need to confirm ERPS functionality under different network scenarios and conditions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"ErpsBase.get_process_list(ApData.zap, 'test_process_restart')\"",
                "Pass/Fail Criteria": "Erps state verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart fib mgr",
                "Procedure": "Tests process restart on both LC and RP fib_mgr, verifying various ERPS functionalities, including those with four-node topologies, two rings, and enabled protocols such as cfm/ospf/isis. Other tests involve verifying the functionality of dot1q rewrite pop/push for RAPS channels and scaled VLANs and BVI interfaces, checking traffic, and identifying crash or core files generated during these processes. This test is triggered by G8032, L2VPN, OSPF, and Bundle configurations.",
                "Pass/Fail Criteria": "Erps state verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process crash",
                "Procedure": "Tests for processing crashes occur on both Local Controller (LC) and Remote Processing (RP) units. To verify Enhanced Reliable Path Selection (ERPS) functionality, we test a topology with four nodes arranged in two rings, first without scaling, then with the addition of Common Control Layer 2 protocols such as cfm/ospf/isis enabled. Further testing involves verifying ERPS functionality with Data Over Cable Service Interface Specification (DOCSIS) dot1q rewrite on an RAPS channel and with scaled VLANs and bridge VLAN interfaces. Traffic is also tested under scaling conditions, after which we check for crash or core files generated during the process. Configurations are set up as described in the setup module. \n\nThis test is triggered by verifying that the configurations have been done correctly within the setup module.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"ErpsBase.get_process_list(ApData.zap, 'test_process_crash')\"",
                "Pass/Fail Criteria": "Erps state verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process crash fib mgr",
                "Procedure": "Tests process crashes on both Local Console (LC) and Remote Power (RP), which is verified by checking for core files. The Enhanced Ring Protection Switching (ERPS) functionality is also tested with a 4-node topology, featuring two rings, with and without scaled VLANs and bridged virtual interfaces. Additionally, ERPS functionality is verified with dot1q rewrite pop/push enabled on the RAPS channel, as well as with Common Filtering Mechanism (CFM), Open Shortest Path First (OSPF), and Intermediate System-to-Intermediate System (IS-IS) protocols enabled. This test is triggered by verifying that Enhanced Ring Protection Switching (ERPS) functionality works correctly in a scaled environment.",
                "Pass/Fail Criteria": "Erps state verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart ncs560",
                "Procedure": "The NCS560 Platform's test process restart on the Routing Protocol (RP) involves verifying various features. It includes checking ERPS functionality with a four-node topology and two rings, as well as enabling cfm/ospf/isis in the same setup. Additionally, it verifies ERPS functionality with dot1q rewrite pop/push enabled for RAPS channels, scaled VLANs and BVI interfaces, and scaled traffic. Furthermore, the test checks for crash or core files. The configurations used are G8032, L2VPN, OSPF, and Bundle.\n\nThis test is triggered by verifying ERPS functionality with a four-node topology and two rings that have cfm/ospf/isis enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"ErpsBase.get_process_list(ApData.zap, 'test_process_restart_ncs560')\"",
                "Pass/Fail Criteria": "Erps state verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process crash ncs560",
                "Procedure": "The tests aim to process crashes on the RP in NCS560 Platform by verifying various aspects of ERPS functionality, including multiple node topologies with different configurations such as two rings, CFM/OSPF/ISIS enabled, and RAPS channel support. Additionally, scaled VLANs and BVI interfaces are being tested for their impact on traffic and to check if the system crashes or produces core files.\n\nThis test is triggered by the need to verify the ERPS functionality in various scenarios to prevent potential system crashes or errors that may occur due to configuration or scaling issues.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"ErpsBase.get_process_list(ApData.zap, 'test_process_crash_ncs560')\"",
                "Pass/Fail Criteria": "Erps state verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Msfs unshut",
                "Procedure": "The test verifies the functionality of both the manual and force switches by configuring ERPS rings on all units under test. This is done by removing the existing switch configuration, then setting up both types of switches, followed by verifying that Ethernet Ring Protection Switching (ERPS) has converged properly and traffic is flowing as expected. Additionally, any crash or core files are checked for potential issues. The configurations used during this test include G8032, Bundle, OSPF, and L2VPN.\n\nThis test is triggered by the need to verify that manual and force switches function correctly in a variety of network scenarios.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mffs shutdown",
                "Procedure": "After shutdown, test the manual and force switch functionalities. This process involves verifying that ERPS (Ethernet Ring Protection Switching) is converged, traffic is flowing properly, and there are no crash or core files. To begin, configure ERPS on all devices under test (UUTs), then set up both manual and force switches. Following this, check for convergence of the ERPS network and verify that traffic is flowing as expected. It's also necessary to remove any switch configuration, and instead set up a G8032, Bundle, OSPF, and L2VPN configuration.\n\nThis test is triggered by verifying manual and force switch functionalities after interface shutdown.",
                "Pass/Fail Criteria": "Erps spanning tree verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "mstag_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Mstag functionality npe",
                "Procedure": "Configure MST-AG and install it on the N-PE, then verify that preconfigured BPDUs are being sent by the N-PE. \n\nThis test is triggered by a specific set of circumstances.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify mac table flushed",
                "Procedure": "The test procedure for F14401 involves configuring the MST-AG on the N-PE, bringing down the active link between the N-PE and U-PE, verifying convergence of the access network, and ensuring the MAC table is flushed. This test is triggered by a configuration change or manual intervention.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify mac withdrawal message sent",
                "Procedure": "When an active link is brought down between N-PE (Network Provider Edge) and U-PE (User Provider Edge), the network should be able to converge and send a MAC (Media Access Control) withdrawal message across the VPLS (Virtual Private LAN Service). This test is triggered by the failure of an active link between N-PE and U-PE.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify precanned bpdu sent hello timer interval",
                "Procedure": "The system checks that it sends pre-configured BPDU's at the Hello timer interval. This test is triggered by the absence of any specific conditions.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify mst ag functionality physical interface",
                "Procedure": "The test verifies the functionality of the MST-AG feature on a physical interface. It does not have any specific triggering conditions. This test is triggered by verifying the MST-AG functionality on a physical interface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify mst ag functionality sub interface",
                "Procedure": "The test, known as FTS ID F14401, is designed to verify the functionality of MST-AG (Multistage Tunneling and Security Tunnel Aggregation) on a subinterface. It does not have any specific triggers.\n\nThis test is triggered by the need to validate the proper functioning of MST-AG on a subinterface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify mst ag functionality bundle interface",
                "Procedure": "Verify MST-AG functionality on bundle interface. This test is triggered by no specific event or condition, meaning it can be run at any time to check the MST-AG function in isolation.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify mst ag functionality dot1ad encap",
                "Procedure": "The functional test F14401 verifies MST-AG (Multiple Spanning Tree Algorithm) functionality on devices that support IEEE 802.1ad encapsulation.\n\nThis test is triggered by the need to verify MST-AG functionality on devices that support IEEE 802.1ad encapsulation.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify mst ag functionality dot1ad dot1q",
                "Procedure": "The FTS with the ID F14401 verifies the MST-AG functionality on a device that supports double encapsulation.\n\nThis test is triggered by the fact that it has no specific triggers.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag config fails in l3 port",
                "Procedure": "The test checks if the MST (Multiple Spanning Tree) Agile configuration is functioning correctly on a Layer 3 port.\n\nThis test is triggered by any event that causes the MST Agile configuration to fail, including changes to the network topology or configuration errors in the switch software.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag config repag mstag config failes",
                "Procedure": "When checking the MST (Multiple Spanning Tree) and REP (Regional Trunking Subgroup) Advanced General settings, this test is triggered by a failure to configure both on the same port.\n\nRewritten trigger sentence:\nThis test is triggered by a failure to configure both MST and REP Advanced General settings on the same port.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag router reload",
                "Procedure": "The test checks the Media System Trunk (MST) Aggregation Group after a router has been reloaded. It doesn't have any specific triggers.\n\nThis test is triggered by a router reload to verify the MST AG configuration.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag card reload",
                "Procedure": "The test checks the MST (Multiple Spanning Tree) area graph configuration after a router reload. This test is triggered by a router reload event.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag card oir",
                "Procedure": "The test FTS ID: F14401 checks the MST AG (Main Service Tray Asynchronous General Purpose I/O) configuration after a card is installed or replaced in a system.\n\nThis test is triggered by card OIR, meaning that it runs whenever a card is inserted or removed from the system's main service tray.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag router switchover",
                "Procedure": "The check mast (MST) automatic gain (AG) with radio personality (RP) switchover test verifies that the system switches between mast and RP gains as expected.\n\nThis test is triggered by changes to the MST or RP status.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag process restart",
                "Procedure": "After a process restart, the MST AG configuration is checked to ensure it is functioning correctly.\n\nThis test is triggered by a process restart.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag process crash",
                "Procedure": "After a process crash, the system checks if the Master Service Table (MST) is in an active state.\n\nThis test is triggered when a process crashes.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag rp so when mst converging",
                "Procedure": "The test checks that the Master State Transition (MST) AG Read Protected Function Output (RPFO) is correct when the Master State Transition Agreement (MSTAG) converges.\n\nThis test is triggered by the master state transition agreement (MSTAG) converging.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag standby rp oir powercycle",
                "Procedure": "The test checks the Main Station Terminal (MST) After Generator (AG) status after a power cycle on the Redundant Power (RP). It does not have any specific triggers for execution.\n\nThis test is triggered by a power cycle on the redundant power unit.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag rp active rp power cycle",
                "Procedure": "The test FTS ID F14401 checks the Multiple Segment Transponder (MST) AG configuration after a power cycle of the active Routing Processor (RP). This test has no specific triggers.\n\nTrigger sentence: This test is triggered by a change in the status of the active RP, specifically when it undergoes a power cycle.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag maximum vlan",
                "Procedure": "The system checks that the Maximum Spanning Tree (MST) Aggregator supports the maximum number of VLANs.\n\nThis test is triggered by an unknown or unsupported value in the 'max-vlans-supported' parameter of the MST Aggregator's configuration.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag multi member link bundle max",
                "Procedure": "The test checks whether the master node (MST) can communicate with other nodes on a multichannel link bundle. It is not triggered by any specific events, and therefore runs as needed.\n\nThis test is triggered when communication across multiple members of a link bundle needs to be verified.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mst ag cpuhog",
                "Procedure": "The FTS checks the Master Timing Source (MST) against the Central Processing Unit's (CPU) high-performance timer. This test is triggered by an anomaly in the relationship between the two, which can indicate a timing discrepancy or clock skew issue.\n\nThis test is triggered by an anomaly in the relationship between the MST and the CPU's high-performance timer.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Max mst ag sessions",
                "Procedure": "The FTS (Fault Tolerant System) ID for this check is F14401, and its purpose is to verify the maximum number of MST AG (Multi-State Technology Advance Gateway) sessions.\n\nThis test is triggered by a specified condition or event that needs to be determined.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag show tech",
                "Procedure": "The test checks to see if show tech exists for a Media Server Template (MST) named AG. It is not triggered by any specific events. \n\nThis test is triggered when a user attempts to configure or deploy a Media Server Template named AG.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Mstag debug options",
                "Procedure": "The following FTS is used to check the enabling and disabling of debug options for MST AG.\n\nThis test is triggered by the necessity to verify the functionality of debug options for MST AG in various scenarios.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            }
        ]
    },
    "repag_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Repag func renn bpdus edge no neighbor",
                "Procedure": "The REP-AG is configured, and it generates RENN BPDUs that trigger the IOS device to enter edge-no-neighbor mode.\n\nThis test is triggered by configuring the REP-AG to generate RENN BPDUs.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag forward timer physical main",
                "Procedure": "The test to configure and verify the REP AG forward timer on the Physica Main system does not have any specific triggers.\n\nThis test is triggered by the need to ensure that the REP AG forward timer is properly configured on the Physica Main system.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag forward timeer subinterface",
                "Procedure": "Configure and verify the REP (Resilient Ethernet Protocol) AG forward timer on the Physical MANIN interface and subinterface.\n\nThis test is triggered by a configuration change to the REP AG forward timer settings.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag hello timer main interface",
                "Procedure": "The test verifies that the REPAG hello timer is working correctly in the main interface.\n\nThis test is triggered by the usual automated schedule.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag hello timer sub interface",
                "Procedure": "The test FTS ID F14404 is designed to verify the REPAG hello timer in the subinterface. It does not have any specific triggers.\n\nThis test is triggered by: a specific event or condition, which is not specified.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag maxage timer physical interface",
                "Procedure": "The test, known as F14404, is designed to verify that the REPAG maximum age timer is functioning correctly within the physical interface. It does not have any specific triggers for execution.\n\nThis test is triggered by the need to ensure that the REPAG maximum age timer in the physical interface is operating correctly.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag physical interface",
                "Procedure": "The REP-AG feature in the physical interface needs to be verified for correct functionality.\n\nThis test is triggered by unspecified conditions.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag feature physical subinterface",
                "Procedure": "To verify the REP-AG feature in a physical subinterface, there are no specific triggers for this test. This test is triggered by the need to confirm that the REP-AG function operates correctly within a physical subinterface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag bundle main",
                "Procedure": "This test is triggered when verifying the REP-AG feature in the bundle main interface to ensure its functionality.\n\n( Trigger sentence: )\n\nNote: The original text had a 'Description' line, but it was not included in the paragraph as per your instructions. If you'd like to include it, I can add it for you!",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag feature bundle subinterface",
                "Procedure": "The Feature Test Suite (FTS) with ID F14404 is used to verify the REP-AG feature within a bundle subinterface.\n\nThis test is triggered by the presence of a REP-AG feature on a bundle subinterface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag startup state physical main",
                "Procedure": "The test, known as F14404, is designed to verify the REP-AG's startup state from its physical main interface after power-on. It has no specific triggers.\n\nThis test is triggered by a standard system power-up or restart event.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag startup state bundle main",
                "Procedure": "When power is turned on, this test verifies the state of the REP-AG startup from the physical bundle interface.\n\nThis test is triggered by the power-on event.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify rep ag snoop bpdu tcn physical main",
                "Procedure": "The test, known as FTS ID: F14404, aims to verify that a REP-AG can successfully snoop a BPDU TCN packet on a physical interface. This test is triggered by any situation in which the device needs to determine if it can intercept and analyze BPDUs (Bridge Protocol Data Units) with a type-length-value (TLV) code indicating a topology change notification.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify rep ag snoop bpdu tcn bundle main",
                "Procedure": "The FTS with ID F14404 verifies that a REP-AG is able to snoop on the BPDU TCN packet on the bundle's main interface. It does not have any specific triggers.\n\nThis test is triggered by the configuration of REP-AG and the transmission of a BPDU TCN packet on the bundle's main interface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify rep ag snoop bpdu tcn physical sub",
                "Procedure": "The FTS verifies that a REP-AG can successfully snoop a BPDU TCN packet on the physical subinterface. This test is triggered by: The system being configured as a REP and receiving a TCN frame on the physical subinterface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify rep ag snoop bpdu tcn bundle sub",
                "Procedure": "The test is used to verify that REP-AG is able to snoop the BPDU TCN packet on a bundle subinterface. There is no specific trigger for this test.\n\nThis test is triggered by any change in the configuration of the bundle subinterface, including changes to member ports or the bundle itself.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag bpdu tcn mac withdraw physical main",
                "Procedure": "The test, identified by FTS ID: F14404, verifies that a REP-AG can successfully snoop the BPDU TCN packet and trigger the VPLS MAC withdrawal on the physical main interface. There is no specific trigger for this test.\n\nThis test is triggered when a BPDU TCN packet is received by the REP-AG.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag bpdu tcn mac withdraw physical sub vpls",
                "Procedure": "The test is used to verify that a REP-AG (Remote Ethernet Port Aggregator) can snooped the BPDU (Bridge Protocol Data Unit) TCN (Topology Change Notification) packet and trigger the VPLS (Virtual Private LAN Service) MAC withdrawal on the physical subinterface.\n\nThis test is triggered by sending a BPDU TCN packet to the REP-AG.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag bpdu tcn mac withdraw bundle main vpls",
                "Procedure": "The test verifies that a REP-AG is capable of snooping the BPDU TCN packet and triggering the VPLS MAC withdrawal on the bundle's main interface.\n\nThis test is triggered by the presence of a REP-AG sending a BPDU TCN packet to trigger a VPLS MAC withdrawal on the bundle's main interface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag bpdu tcn mac withdraw bundle sub vpls",
                "Procedure": "The test verifies that REP-AG can sniff a BPDU TCN packet and trigger a VPLS MAC withdrawal on the Bundle sub-interface. This test is triggered by the presence of a BPDU TCN packet being sent to the device under test.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag bpdu tcn mac withdraw physical main local mac",
                "Procedure": "The test FTS ID: F14404 verifies that a REP-AG can snoop on a BPDU TCN packet and trigger a local MAC withdrawal, affecting physical/bundle management and subinterfaces. This test is triggered by the presence of a BPDU TCN packet being snooped by the REP-AG.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag bpdu tcn mac withdraw physical sub local mac",
                "Procedure": "The test verifies that a REP-AG device is able to sniff the BPDU TCN packet and trigger the local MAC withdrawal on physical, bundle-managed, and subinterface interfaces.\n\nThis test is triggered by receipt of a Bridge Protocol Data Unit (BPDU) with a Topology Change Notification (TCN).",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag no neighbor ring",
                "Procedure": "The test, known as FTS ID: F14404, verifies that a network with a ring topology and no neighboring nodes can still establish a REP (Reduced Election Protocol) AG (Active Gateway). \n\nThis test is triggered by the absence of neighboring nodes on the ring topology.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag untagged encapsulation physical",
                "Procedure": "This test is triggered by a physical subinterface with untagged encapsulation for the REP-AG protocol.\n\nVerify that the REP-AG protocol functions correctly when using untagged encapsulation on a physical subinterface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag untagged encapsulation bundle",
                "Procedure": "The test, identified by FTS ID F14404, is called \"Verify REP-AG on untagged encapsulation bundle sub interface\". It has no specific triggers.\n\nThis test is triggered by: The system being in the correct state for testing a REP-AG connection over an untagged encapsulation bundle on a subinterface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag default encapsulation physical",
                "Procedure": "The purpose of this test is to verify that REP-AG (Remote Protocol Entity - Access Gateway) functions correctly on a physical subinterface when using the default encapsulation method.\n\nThis test is triggered by the user's request to run it.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag default encapsulation bundle",
                "Procedure": "The purpose of this test is to verify that REP-AG (Remote End Point - Aggregate) functions correctly when it is enabled by default on a bundle subinterface.\n\nThis test is triggered by enabling REP-AG on the default encapsulation bundle subinterface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag priority tagged encapsulation physical",
                "Procedure": "This test checks that a priority-tagged encapsulation is correctly associated with the REP-AG attribute.\n\nTriggered by any change to a physical or subinterface main configuration.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag priority tagged encapsulation bundle",
                "Procedure": "The test verifies that REP-AG is functioning correctly on both the primary and secondary interfaces of a bundle, which has been prioritized for its encapsulated traffic. This test is triggered by a configuration change to the priority tagging on either the main or sub interface of the bundle.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag double tagged dot1q encapsulation physical",
                "Procedure": "The test, identified by FTS ID F14404, verifies the REP-AG function on a network with double-tagged 802.1Q encapsulation using both physical main and sub interfaces.\n\nThis test is triggered by there being no specific events or conditions that initiate it.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag double tagged dot1q encapsulation bundle",
                "Procedure": "The test, FTS ID F14404, verifies the REP-AG (Remote Protocol Agent) functionality on a bundle with dual-tagged (dot1q encapsulation) interfaces, specifically the main and sub interfaces.\n\nThis test is triggered by the presence of a bundle with double tagged dot1q encapsulation.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag double tagged dot1ad encapsulation physical",
                "Procedure": "The FTS ID is F14404 and it involves verifying the REP-AG on a double-tagged dot1ad encapsulation of a physical main/sub interface.\n\nThis test is triggered by there being no specific triggers associated with it.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag double tagged dot1ad encapsulation bundle",
                "Procedure": "The test verifies that REP-AG works correctly on a double-tagged Dot1AD encapsulated bundle of both main and sub interfaces.\n\nThis test is triggered by the F14404 test ID, which indicates verification of REP-AG functionality.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag push rewrite physical",
                "Procedure": "This test verifies that the REP-AG feature is properly applied during a push rewrite operation on the physical main or sub interface.\n\nThis test is triggered by the execution of a push rewrite command on either the physical main or sub interface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag push rewrite bundle",
                "Procedure": "The FTS ID for this test is F14404. It verifies that the REP-AG function operates correctly on both the main and sub interfaces of a push rewrite bundle.\n\nThis test is triggered by: [insert trigger description here]",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag pop rewrite physical",
                "Procedure": "The test, with ID F14404, is designed to verify that REP-AG functions correctly during a pop operation involving a physical main and/or sub interface. The test has no specific triggers. This test is triggered by the initiation of a pop rewrite process on a main or sub interface configured for REP-AG functionality.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag pop rewrite bundle",
                "Procedure": "The test FTS ID F14404 is designed to verify that REP-AG functions correctly on the pop rewrite bundle main and sub interfaces.\n\nThis test is triggered by: unspecified conditions.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag translate rewrite physical",
                "Procedure": "The test FTS ID: F14404 is designed to verify the REP-AG on translate rewrite physical main/sub interface. It has no specific triggers.\n\nThis test is triggered by unspecified events that need to be determined.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag translate rewrite bundle",
                "Procedure": "The purpose of this test is to verify that the REP-AG functionality works correctly on both the main and sub interfaces of the translate rewrite bundle. \n\nThis test is triggered by any changes made to the REP-AG configuration on these interfaces.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag vpls bd mac limit",
                "Procedure": "The test, identified by the code F14404, checks the REP AG feature within a VPLS Border Domain that includes a MAC (Media Access Control) limit. There are no specific events or conditions that trigger this test. \n\nThis test is triggered when the system under test is configured to operate as a VPLS Border Domain with a specified MAC address limit for the REP AG feature.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag vpls bd mac learn limit",
                "Procedure": "Check REP Aggregation and VPLS Bridge Domain with MAC Learning Limit to ensure proper functionality.\n\nThis test is triggered by network traffic that activates the specified protocol features under normal operating conditions.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag vpls bd mac learn limit and actions",
                "Procedure": "The FTS (Functional Test System) ID is F14404, and it's used to check two things: the REP AG (Redundant Ethernet Port Aggregation Group) and the VPLS BD (Virtual Private LAN Service Bridging Domain). The test also looks at how the system handles mac learn limits and certain actions. \n\nThis test is triggered by any occurrence where all its components, specifically the mac learn limit and actions within the REP AG and VPLS BD, are being utilized.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag vpls bd unknown unicast disable",
                "Procedure": "The FTS (Functional Test Suite) ID is F14404, which involves verifying the REP-AG (Resilient Ethernet Protocol - Aggregate Group) ports in a Virtual Private LAN Service (VPLS) Border Device when unknown unicast traffic is disabled. This test has no specific triggers.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag vpls bd storm control",
                "Procedure": "The test FTS ID F14404 verifies that REP-AG ports are functioning correctly within a VPLS bridge domain while storm control is enabled.\n\nThis test is triggered by the verification of REP-AG ports in a VPLS bridge domain with storm control enabled.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag vpls bd unknown unicast enable",
                "Procedure": "The FTS, known as F14404, is designed to verify REP-AG ports in a VPLS Bridge Domain where unknown unicast traffic is enabled. This test does not have any specific triggers that initiate it. \n\nThis test is triggered by the activation of unknown unicast enablement on a VPLS Bridge Domain with REP-AG ports present.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag vpls bundle main interface",
                "Procedure": "The purpose of this test is to verify that the REP-AG ports are functioning correctly through the bundle's main interface. There are no specific events or conditions that trigger this test.\n\nThis test is triggered by any event or condition that initiates a check on the status of the REP-AG ports in the bundle's main interface.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag vpls bundle sub interface",
                "Procedure": "The test, identified as F14404, is used to verify the REP-AG ports within a bundle subinterface. It has no specific triggers.\n\nThis test is triggered when verifying REP-AG ports in a bundle subinterface configuration.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag disabled",
                "Procedure": "The system verifies that a REP AG is in a disabled state when this test is triggered by the occurrence of any event.\n\nThis test is triggered by the occurrence of any event.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag invalid bpdu tcn",
                "Procedure": "The test FTS ID F14404 is designed to verify the REPAG (Remote Procedure Call Access Gateway) functionality when dealing with an invalid BPDU (Bridge Protocol Data Unit) with a TCN (Topology Change Notification).\n\nThis test is triggered by the occurrence of an invalid BPDU with a TCN.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify port movement l2 l3 physical",
                "Procedure": "The test with the FTS ID F14404 verifies the REgional Exchange Point - Autonomous Group (REP-AG) when a port is moved between L2 and L3 layers.\n\nThis test is triggered by moving the port between L2 and L3 layers.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify port movement l2 l3 bundle",
                "Procedure": "The FTS (Functional Test Specification) with the ID F14404 verifies that REP-AG behaves correctly when a port is moved between levels 2 and 3. However, this test does not have any specific triggers.\n\nThis test is triggered by the movement of a port from level 2 to level 3 or vice versa.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify commit fail l3",
                "Procedure": "The purpose of this test is to verify that a commit fails on Layer 3 ports when using the REP-AG feature.\n\nThis test is triggered by: FTS ID : F14404 Description : Verify REP-AG commit fail in l3 ports",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify commit repag mstag samenode",
                "Procedure": "The test, known as F14404, verifies that when a REP-AG (Redundant Election Protocol Active Gateway) and an MST-AG (Multiple Spanning Tree Active Gateway) are configured on the same node and fail to commit, the system behaves as expected.\n\nThis test is triggered by configuring REP-AG and MST-AG on the same network device.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify removing adding repag port vpls bd",
                "Procedure": "The purpose of this test is to verify the functionality of removing and adding REP-AG ports from a VPLS boundary domain. This test is triggered by manual intervention, as it does not have any specific automated triggers.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag config commit replace",
                "Procedure": "The test FTS ID: F14404 is used to verify that a REP-AG commit replace occurs correctly. It lacks specific triggers for execution, and its purpose is focused on confirming this specific operation.\n\nThis test is triggered by the occurrence of a REP-AG commit replace event requiring verification.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag removing adding global vpls config physical interface",
                "Procedure": "The FTS ID for this test is F14404, and its purpose is to verify that removing and adding global VPLS configurations on REP-AG enabled bundle or physical ports functions as expected. \n\nThis test is triggered by the removal and addition of global VPLS configurations from REP-AG enabled Bundle/Physical ports.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Verify repag removing adding global vpls config bundle interface",
                "Procedure": "The test verifies removing and adding global VPLS configurations that were previously enabled on REP-AG bundle or physical ports.\n\nThis test is triggered by enabling the removal and addition of global VPLS configurations on REP-AG bundle or physical ports.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Same vpls physical and bundle",
                "Procedure": "The test (F14404) verifies that a REP-AG enabled bundle and its associated physical ports are configured within the same VPLS binding domain.\n\nThis test is triggered by no specific conditions or events.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Feature interaction l2acl",
                "Procedure": "The purpose of this test is to verify that REP-AG (Remote Edge Port Aggregation) works correctly when an L2 Access Control List (ACL) is configured on its enabled ports.\n\nThis test is triggered by any change in the configuration of a port where REP-AG is enabled, specifically if an L2 ACL is added or modified.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Rep feature interaction bpdu guard",
                "Procedure": "The purpose of this test is to verify that a REP-AG (Remote Edge Port Aggregation) device functions correctly when BPDU Guard is configured on its enabled ports.\n\nThis test is triggered by the configuration of BPDU Guard on a REP-AG port, and verification of REP-AG functionality.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Rep feature interaction lacp enabled",
                "Procedure": "Verify that REP-AG is interoperable with bundle interface (LACP enabled). The test to verify this functionality has no specific triggers.\n\nThis test is triggered by the need to check for interoperability between REP-AG and a bundle interface with Link Aggregation Control Protocol (LACP) enabled.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag switchover stable topology",
                "Procedure": "The test is designed to verify the switchover process for REP-AG over a stable network topology, with no specific events triggering its execution.\n\nThis test is triggered by any occurrence of an unexpected change in the network environment that requires the REP-AG switchover mechanism to be tested.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag switchover converging topology root bridge change",
                "Procedure": "A high availability (HA) switchover occurs when the system switches to a redundant component in a converging topology, accompanied by a root bridge change.\n\nThis test is triggered by a HA switchover in a converging topology where there is also a root bridge change.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag switchover converging topology port role change",
                "Procedure": "The High Availability (HA) switchover process is tested in a converging network topology where the port role changes. This test is triggered by the HA switchover procedure itself, without any specific external events or conditions.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag switchover converging topology port link failure",
                "Procedure": "A high availability (HA) switchover occurs in a network configuration where multiple paths converge to a single point, and when a link failure occurs on one of the ports.\n\nThis test is triggered by a high-availability switchover in converging topology with port link failure.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag switchiver converging topology over nei bridge failure",
                "Procedure": "In a network using High Availability (HA) switchover in converging topology, with neighboring Bridge failures, this test is triggered by the occurrence of HA switchover in converging topology and neighboring Bridge failure.\n\nThis test is triggered by an occurrence of HA switchover in converging topology and neighboring Bridge failure.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag oir active rp",
                "Procedure": "The HA (High Availability) switchover OIR (Onboard Interface Replacement) Active RP test is triggered when a failure occurs during the switch to active role for an onboard interface replacement, and it is also not associated with any specific triggers.\n\nThis test is triggered by any failure occurring during the switch to active role for an onboard interface replacement.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag oir standby rp",
                "Procedure": "HA switchover OIR Standby RP is a procedure where High Availability (HA) switches to an alternate system in case of failure, using the Operations and Incident Response (OIR) team to manage the process.\n\nThis test is triggered by the HA system detecting a critical failure in its primary setup.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Crash stp controller process",
                "Procedure": "The crash stp_controller process on an active RP is triggered when the system crashes.\n\nThis test is triggered by the system crashing.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Crash pvstag io process",
                "Procedure": "Crashes can occur in a data processing environment when the pvstag-io process on an active resource pool crashes.\n\nThis test is triggered by any crash of the pvstag-io process on an active resource pool.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Process restart stp controller",
                "Procedure": "The crash process restart STP (Spanning Tree Protocol) controller test is identified by FTS ID F14404 and involves restarting the crash process.\n\nThis test is triggered by a manual initiation of the crash process restart.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag io process active rp",
                "Procedure": "The crash process restart STP controller test has no specific triggers. The test is designed to restart a switch with Spanning Tree Protocol (STP) enabled after it has crashed.\n\nThis test is triggered by the need for an immediate restart of the STP controller in order to ensure continuous network operation.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Stp controller process crash standby",
                "Procedure": "The crash process restart STP (Spanning Tree Protocol) controller is a test with no specific triggers to initiate it.\n\nThis test is triggered by an instance of the STP system crashing and failing to recover properly.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Process restart gsp",
                "Procedure": "The crash process restart STP (Spanning Tree Protocol) controller is a test with no specific triggers.\n\nThis test is triggered by any event that causes the system to crash and subsequently require the STP controller to be restarted.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Restart system db",
                "Procedure": "The crash process restart STP controller test has a description of restarting the switch fabric to verify that the spanning tree protocol (STP) controller recovers properly.\n\nThis test is triggered by.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Multiple link failure admin oper beetween nodes",
                "Procedure": "This test checks for the occurrence of multiple administrator login failures. It does not have any specific triggers. This test is triggered by a user attempting to log in with incorrect credentials as an administrator multiple times consecutively.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Access node failure",
                "Procedure": "The access node known as Accs-1 is a part of the EPAG system that failed. This test is triggered by an actual failure of the EPAG access node, specifically Accs-1.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Access node failure 2",
                "Procedure": "The EPAG access node, designated Accs-2, failed to function properly.\n\nThis test is triggered by a failure of the EPAG access node, specifically Accs-2.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Multiple node failure",
                "Procedure": "REPAG multiple node failure can occur when one or more nodes in the system fail simultaneously.\n\nThis test is triggered by multiple node failures occurring simultaneously.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag performance stateless commit replace",
                "Procedure": "Verify restart with stateless after commit replace is a test that has no specific triggers.\n\nThis test is triggered by no specific events or conditions.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag performance scaled mac",
                "Procedure": "The test, identified by FTS ID F14404, is used to verify the operation of REPAG with scaled MAC entries in a network environment. It lacks any specific triggers that initiate its execution. This test is triggered by a system administrator or automated process requesting verification of REPAG functionality during routine maintenance or troubleshooting activities.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag servicability",
                "Procedure": "The purpose of this test is to verify that the REP-AG debug infrastructure is being used correctly. It does not rely on any specific triggers.\n\nThis test is triggered by changes made to the REP-AG debug infrastructure.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag syslog",
                "Procedure": "The purpose of this test is to verify that REP-AG syslogs are functioning correctly. It has no specific triggers.\n\nThis test is triggered by a non-functional REP-AG syslog.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Repag show tech",
                "Procedure": "The FTS ID is F14404 and this test is used to verify the REP-AG show tech. It does not have any specific triggers.\n\nThis test is triggered by the completion of a REP-AG show.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            }
        ]
    },
    "mstp_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Mstp default values check",
                "Procedure": "The test verifies the default MSTP values for all VLANs after MSTP convergence are correct. Configurations include using MSTP protocol via l2transport, l2vpn and mstp, with default MSTP parameters on all routers. The verifications involve checking for MSTP convergence. \n\nThis test is triggered by there being no specific triggers for this test.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nStp mstp verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp forward link shut noshut",
                "Procedure": "The test verifies MSTP (Multiple Spanning Tree Protocol) convergence after shutting down and then bringing back up interfaces that are linked using MSTP. The configuration includes enabling MSTP protocol via three different methods, setting default parameters on all routers, and then shutting down or bringing up the interfaces to simulate a failure and recovery scenario. To verify the test's success, we check the interface states, MSTP convergence, and traffic flow. This test is triggered by shutting down and then bringing back up the interfaces that are linked using MSTP.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp interface remove config",
                "Procedure": "The test case verifies MSTP convergence after removing and adding back the interfaces from the MSTp configuration. It involves configuring MSTP protocols via l2transport, l2vpn, and mstp on routers, using default MSTP parameters, and then unconfiguring and reconfiguring the interfaces. Verification steps include checking interface states, MSTP convergence, and traffic flow.\n\nThis test is triggered by: when an interface is removed from the spanning tree configuration only to be added back again.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2vpn remove configure",
                "Procedure": "The test-case verifies the MSTP convergence after removing and adding the l2vpn configs from MSTP configurations. It involves running MSTP protocol via l2transport, l2vpn, and mstp with default parameters on all routers. The verification criteria include checking for MSTP convergence. This test is triggered by removing or adding the l2vpn configs.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp bundle change",
                "Procedure": "The test case verifies whether MSTP convergence is successful after adding or removing bundle members from a bundle associated with MSTP. The configuration involves using MSTP protocol via different methods, such as l2transport, l2vpn, and mstp, while default MSTP parameters are set on all routers. To verify the mstp convergence, the test checks that it occurs successfully when the bundle members are removed or added from the associated bundle. This test is triggered by removing or adding the bundle members from the bundle associated with MSTP.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp bundle member interface flap",
                "Procedure": "When the bundle members are Flapped, this test case verifies that MSTP convergence is successful. The test assumes MSTP protocol configurations via l2transport, l2vpn and mstp with default parameters on all routers. To verify MSTP convergence, the test checks whether the MSTP protocol correctly re-converges after a disruption in the bundle members.\n\nThis test is triggered by shutting or un-shutting the bundle members from the bundle associated with MSTP.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp process ha",
                "Procedure": "The test checks MSTP convergence after restarting the processes mentioned in the input file, which includes verifying that the processes are properly restarted and recovered from a crash. The configurations include running MSTP protocol via l2transport, l2vpn, and mstp, using default MSTP parameters on all routers, and simulating a process restart and crash. The verifications include checking for successful MSTP convergence and confirming that the processes have been successfully restarted or recovered.\n\nThis test is triggered by Process restart and process crash.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Commit rollback replace",
                "Procedure": "The testcase verifies MSTP convergence after performing a commit replace and rollback of configurations, including MSTP protocol settings via l2transport, l2vpn, and mstp, using default parameters on all routers with a restart process. The verifications include checking for successful commit replace/rollback and mstp convergence. This test is triggered by the occurrence of a commit replace action.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp with rpfo",
                "Procedure": "The testcase is designed to verify that the Multiple Spanning Tree Protocol (MSTP) converges correctly after a Remote Port Flap Operation (RPFO). This test checks two main aspects: it performs an RPFO operation and then verifies that MSTP has converged. The configuration involves setting up MSTP on routers using three different protocols - L2Transport, L2VPN, and MSTP - and ensuring default MSTP parameters are used on all devices before restarting the process.\n\nThis test is triggered by a Remote Port Flap Operation.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nRPFO verification is performed.\nmstp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp reload",
                "Procedure": "MSTP Convergence Test verifies whether MSTP convergence happens after the router or card is reloaded, with proper root bridge election and smooth traffic flow.\n\nThis test is triggered by a reload of the router or card.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp root bridge election check",
                "Procedure": "The test for MSTP Convergence involves testing whether MSTP converges successfully after removing a root or non-root bridge router that was previously part of the MSTP protocol. The configurations used include MSTP via l2transport, l2vpn and mstp, as well as default MSTP parameters on all routers. The verification steps check for MSTP convergence. This test is triggered by manually removing the root/non-root bridge from the MSTP configuration.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp replace values check",
                "Procedure": "The test verifies that the MSTP (Multiple Spanning Tree Protocol) default values for all VLANs are correct after the protocol has converged, which occurs when the MSTP parameters on a router are updated using NETCONF.\n\nThis test is triggered by: The absence of any specific configuration or event requirement.",
                "Pass/Fail Criteria": "Stp mstp verification is performed.\nStp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp replace values check port priority",
                "Procedure": "The test verifies whether the MSTP default values for all VLANs are proper after replacing a port priority value using NETCONF and achieving MSTP convergence. The configurations involve enabling the MSTP protocol via L2 transport, L2 VPN, and MSTP, and setting default MSTP parameters on all routers. To verify that the test case is successful, MSTP convergence must be achieved, with no additional triggers required.\n\nThis test is triggered by a change in port priority value via NETCONF.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Interface root guard",
                "Procedure": "MSTP functionality is tested when the interfaces' root guard is applied, with the objective of verifying MSTP convergence. The configuration for this test includes using MSTP protocol via l2transport, l2vpn and mstp, setting default MSTP parameters on all routers, and configuring port root guard. Verification involves checking for MSTP convergence.\n\nThis test is triggered by interface root guard.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Interface bpdu guard",
                "Procedure": "When the interfaces' BPDU guard is applied, MSTP functionality can be tested for convergence. The test-case verifies whether MSTP convergence has occurred or not when using MSTP protocol via l2transport, l2vpn, and mstp, with default MSTP parameters on all routers and port BPDU guard configured. The verification checks for MSTP convergence. This test is triggered by the application of interface BPDU guard.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp feature interaction qos",
                "Procedure": "The test case verifies whether the MSTP (Multiple Spanning Tree Protocol) convergence happens or not, using configurations that include MSTP via l2transport, l2vpn, and mstp, with default mstp parameters on all routers. To check for MSTP convergence, restart the Router/Card.\n\nThis test is triggered by the need to verify MSTP functionality under normal operating conditions.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp bridge priority",
                "Procedure": "The functionality of the Multiple Spanning Tree Protocol (MSTP) for the bridge priority is tested to verify whether MSTP convergence occurs or not. The configurations include MSTP protocol via various methods such as l2transport, l2vpn, and mstp, with default MSTP parameters used on all routers and the bridge priority configured. Verification of MSTP convergence is carried out. This test is triggered by a change in the bridge priority.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp port priority",
                "Procedure": "The test verifies whether MSTP convergence has occurred when using the port priority configuration, specifically testing the protocol's functionality with default parameters and various configurations such as L2 transport, L2 VPN, and MSTP.\n\nThis test is triggered by a change in port priority.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp name change",
                "Procedure": "To verify that MSTP functionality works with a changed name, test-case examines whether MSTP convergence occurs. The configurations include using MSTP protocol via l2transport, l2vpn and mstp, defaulting to the standard mstp parameters on all routers, and configuring a new mstp name. The verification process checks for MSTP convergence.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp untagged",
                "Procedure": "The test for MSTP convergence with untagged packets verifies whether MSTP untagged packets are forwarded properly, including MSTP convergence. Configurations involve enabling the MSTP protocol via l2transport, l2vpn and mstp, using default MSTP parameters on all routers. Verification involves checking for MSTP convergence.\n\nThis test is triggered by there being no specific events or conditions that need to occur beforehand.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "pvrst_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Pvrst default values check",
                "Procedure": "The test verifies whether the Power VLAN Rapid Spanning Tree (PVRST) default values for all Virtual Local Area Networks (VLANS) are correct after PVRST convergence has taken place. The configurations used include PVRST protocol via layer 2 transport, layer 2 VPN, and PVRST with default parameters applied to all routers. The verifications involve checking the convergence of PVRST. This test is triggered by specific conditions that do not need to be specified.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nStp pvrst verification is performed.\nStp pvrst interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst fwd link shut noshut",
                "Procedure": "The PVRST forward linked interfaces are shut and no shut, verifying PVRST convergence after shutting down and bringing back up the connected interfaces that use the PVRST protocol via l2transport, l2vpn, or pvrst, with default parameters on all routers. To confirm this, check the interface states, ensure proper PVRST convergence, and verify that traffic is flowing as expected.\n\nThis test is triggered by the shut and no shut of the interfaces.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst interface remove configure",
                "Procedure": "The PVRST test verifies the convergence of protocols after removing and re-adding linked interfaces. The test is configured with PVRST protocol settings via l2transport, l2vpn, and pvrst, using default parameters on all routers, and involves unconfiguring and configuring the interfaces from spanning tree. Verification includes checking interface states, PVRST convergence, and traffic flow. This test is triggered by manually unconfiguring and then re-configuring the interfaces from spanning tree.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2vpn remove configure",
                "Procedure": "The test PVRST Convergence involves verifying that PVRST converges after the L2VPN configurations have been removed and then readded on a router. The test case uses default PVRST parameters, PVRST protocol via L2 transport, L2VPN, and PVRST itself. It checks for PVRST convergence during this process.\n\nThis test is triggered by removing or adding the L2VPN configurations.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst bundle change",
                "Procedure": "When testing PVRST Convergence, we want to verify that it's successful when bundle members are removed or added from a bundle using PVRST. We're looking at three different configurations: PVRST via l2transport, l2vpn, and pvrst, with default parameters on all routers. To check the convergence of PVRST, we'll remove or add bundle members from the bundle associated with it.\n\nThis test is triggered by the removal or addition of bundle members from the bundle associated with PVRST.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst bundle member interface flap",
                "Procedure": "The test for PVRST Convergence involves verifying whether the protocol converges successfully after a bundle's members are removed and readded to it. The configurations tested include PVRST enabled via various transport methods, as well as default parameters used on all routers. To check the convergence, one must verify that the PVRST protocol functions correctly under these conditions. This test is triggered by shutting down and then bringing back up the bundle members associated with the PVRST protocol.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst process ha",
                "Procedure": "The test verifies PVRST convergence after restarting processes mentioned in the input file, using configurations such as PVRST protocol via l2transport, l2vpn, and pvrst with default parameters on all routers, followed by a restart of the process.\n\nThis test is triggered by a combination of process restart and crash.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Commit rollback replace",
                "Procedure": "The test case performs a commit replace and rollback configuration to verify PVRST convergence. Configurations include using the PVRST protocol via l2transport, l2vpn, and pvrst with default parameters on all routers, as well as restarting the process. The verification steps involve checking for commit replace/rollback functionality and ensuring PVRST convergence is achieved. This test is triggered by a commit replace action.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst with rpfo",
                "Procedure": "The PVRST convergence is tested after an RPFO. The test verifies that the system performs a redundancy preservation fast operation (rpfo) and ensures proper PVRST convergence. The configuration includes using the PVRST protocol via L2 transport, L2VPN, and PV-RST with default parameters on all routers and simulating a restart process.\n\nThis test is triggered by performing an RPFO action on a configured PVRST network.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nRPFO verification is performed.\npvrst convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst replace values check",
                "Procedure": "The test verifies that the PVRST default values for all VLANs are proper after PVRST convergence, which occurs when the protocol is used via l2transport, l2vpn, and pvrst with default parameters on all routers. The test checks for pvrst convergence.\n\nThis test is triggered by: The absence of any specific event or condition.",
                "Pass/Fail Criteria": "Stp pvrst verification is performed.\nStp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst replace values check port priority",
                "Procedure": "The test verifies whether the PVRST default values for all VLANs are proper after replacing a port priority value using netconf and triggering PVRST protocol via l2transport, l2vpn, and pvrst on all routers with default parameters. The configurations involve setting up PVRST and waiting for convergence to occur. This test is triggered by the configuration changes made through netconf.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst reload",
                "Procedure": "The test verifies that the PVRST (Per VLAN Rapid Spanning Tree) protocol converges properly after a router or card is reloaded. The test checks whether the root bridge election occurs correctly and if traffic flows smoothly. To achieve this, the PVRST protocol is configured using various methods (l2transport, l2vpn, and pvrst), and default parameters are used on all routers. The verification process includes checking for successful convergence of PVRST and ensuring that the router or card has restarted successfully. This test is triggered by a reload of the router or card.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst root bridge election check",
                "Procedure": "The PVRST Convergence test verifies whether the protocol's convergence is successful after the root or non-root bridge router is removed from the PVRST configuration. The test case uses various configurations, including PVRST via L2 transport, L2 VPN, and PVRST with default parameters on all routers. To determine if the convergence is successful, the verification checks for PVRST convergence. This test is triggered by removing the root or non-root bridge from the PVRST.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Interface root guard",
                "Procedure": "The PVRST functionality is tested by applying the interfaces root guard. The test-case verifies whether the PVRST convergence has occurred. Configurations include the use of PVRST protocol via l2transport, l2vpn and pvrst, default pvrst parameters on all routers, and a configured port root guard. Verifications check for successful PVRST convergence. \n\nThis test is triggered by interface root guard.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Interface bpdu guard",
                "Procedure": "To verify the PVRST functionality when the interface's BPDU Guard is applied, we need to confirm if PVRST convergence occurs. The configuration involves setting up the PVRST protocol via L2Transport, L2VPN, and PV-RST, using default parameters on all routers, and configuring port BPDU guard. Verification of PVRST convergence is key in this process. This test is triggered by interface BPDU Guard.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst feature interaction qos",
                "Procedure": "The test of PVRST functionality with qos verifies whether the protocol's convergence has occurred. The configuration involves testing the PVRST protocol through l2transport, l2vpn, and pvrst methods using default parameters on all routers, and restarting a router or card. Verification includes checking for pvrst convergence. This test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst bridge priority",
                "Procedure": "To test the PVRST functionality for the bridge priority, verify that the protocol has converged as expected. The test assumes the following configurations: the PVRST protocol is enabled using l2transport, l2vpn, or pvrst; default parameters are used on all routers; and the bridge priority is configured. To determine if the convergence was successful, check for the presence of PVRST convergence. This test is triggered by a change in the bridge priority.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst port priority",
                "Procedure": "The test verifies whether PVRST convergence has occurred for a given port priority configuration. To test this, we use the PVRST protocol via various transport methods and configure default parameters on all routers. We also set up a port priority configuration as part of the test case. The test is successful if PVRST convergence occurs under these conditions. This test is triggered by a change to the port priority.",
                "Pass/Fail Criteria": "Stp convergence verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "tunn_mac_age_timer_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Verify ospf l2vpn mpls ldp",
                "Procedure": "The test case verifies the OSPF-MPLS LDP-L2VPN XConnect-Bridge Domain configuration. The verification process involves a common setup and checks on OSPF, MPLS LDP, XConnect, and Bridge Domain configurations. Triggers are not specified for this test.\n\nThis test is triggered by no specific events or conditions.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nOspf verification is performed.\nMpls ldp neighbor brief verification is performed.\nL2vpn bridge domain summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac timer add remove",
                "Procedure": "The mac timer is verified to be configured and removed as expected from the system configurations. A configuration of setting the mac timer to a value other than its default value is tested, followed by verification that it has been set and subsequently removed successfully. The trigger for this test is none.",
                "Pass/Fail Criteria": "L2vpn bridge domain bd name detail verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Diff bd diff mac timer",
                "Procedure": "The highest MAC aging timer should be chosen for each bridge domain with its own distinct MAC aging time. To achieve this, we have different MAC aging times configured for various bridge domains. We then verify that the MAC addresses age after the longest set timer across multiple bridge domains.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nL2vpn forwarding bridge domain mac address internal location verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Static mac bd",
                "Procedure": "The test verifies static MAC configuration under a bridge port. The setup consists of a bridge domain with three access controllers (ACs), one of which has its MAC address statically configured. To test this scenario, traffic is first verified to not flood all ACs when the destination MAC address matches the statically configured one. Then, an AC is shut down and it's ensured that the source MAC address is still present in the bridge table. After removing the source MAC from the bridge port, traffic should start flooding again. This test is triggered by shutting down an access controller and then removing its MAC address from the bridge port.",
                "Pass/Fail Criteria": "L2vpn bridge domain bd name detail verification is performed.\nL2vpn forwarding bridge domain mac address internal location verification is performed.\nControllers fia diagshell location verification is performed.\nTgenchecktrafficerror verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove bvi",
                "Procedure": "The test case verifies that adding and removing a bridge VLAN (BVI) under a Border Gateway (BD) does not affect the flooding functionality of traffic to all access control (AC) ports. To automate issues CSCvs89939 and CSCvs76294, the configuration involves setting up a BD with three ACs, then adding and subsequently removing a BVI from the BD. The verifications include checking that traffic is successfully flooded to all ACs when the BVI is present in the BD, then again after it has been removed; additionally, a ping test of the BVI interface itself is performed. This test is triggered by the addition and removal of a BVI in the BD.",
                "Pass/Fail Criteria": "Tgenchecktrafficerror verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Remove and readd l2 ac under bd",
                "Procedure": "The test verifies that adding and removing a bridge virtual interface (BVI) under Bridge Domain (BD) does not impact flooding functionality. The configuration involves setting up a BD with three access control entities (ACs), adding the BVI to the BD, and then removing it. Verifications include checking that traffic is flooded to all ACs when the BVI is present in the BD and again after the BVI has been removed. This test is triggered by changing the status of the bridge virtual interface in the Bridge Domain.",
                "Pass/Fail Criteria": "L2vpn bridge domain bd name detail verification is performed.\nTgenchecktrafficerror verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shg bd",
                "Procedure": "The test-case verifies if split horizon functionality is working on border ports. To do this, a configuration with two Access Controllers (ACs) and a Border Domain (BD) is set up, where a split-horizon group is enabled on both BD's border ports. The verification process involves checking that traffic does not flow when the split-horizon group is enabled, but does flow when it is disabled on one of the border ports. This test is triggered by configuring the split-horizon group on both border ports and verifying traffic, then removing the group from one port to see if traffic resumes flowing.",
                "Pass/Fail Criteria": "L2vpn bridge domain bd name detail verification is performed.\nL2vpn forwarding bridge domain mac address internal location verification is performed.\nControllers fia diagshell location verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Uucast flood",
                "Procedure": "The test-case verifies if unknown-unicast disable is working on bport, which involves configuring a bridge domain (BD) with two access circuits (ACs), one of which has unknown-unicast disable enabled. The test then checks the flow of traffic to ensure that it does not occur when unknown-unicast is enabled on the B-port and that it flows when it is disabled. This test is triggered by configuring unknown-unicast disable on the BD, checking for traffic, and then removing the configuration to verify traffic continues to flow.",
                "Pass/Fail Criteria": "L2vpn bridge domain bd name detail verification is performed.\nL2vpn forwarding bridge domain mac address internal location verification is performed.\nControllers fia diagshell location verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Negative tagged untagged",
                "Procedure": "The test verifies if an untagged subinterface forwards tagged traffic. The configurations include setting up a Bridge Domain with two Access Connectors, one with encapsulation as untagged and the other with default encapsulation. To verify this, the test checks that traffic flows when the encapsulation is changed from IEEE 802.1Q to the default mode, but does not flow when it's changed from default to untagged mode. The test also involves checking the traffic in three different scenarios: setting encap to default and removing any rewriting actions, then verifying the traffic; setting encap to untagged, checking the traffic; and finally restoring the original configuration.\n\nThis test is triggered by the following sequence of operations: set encap to default, remove rewriting actions, check the traffic flow, set encap to untagged, check the traffic flow, and restore the original configuration.",
                "Pass/Fail Criteria": "L2vpn bridge domain bd name detail verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging default min with phy ac bun phy pw",
                "Procedure": "The test case verifies that a MAC address is learned via Physical Address (phy ac) and Bridge Port Watcher protocol (bun pw). To accomplish this, the Physical PowerWatcher protocol is shut down, after which it is checked if the MAC address has been successfully learned and expires according to its default timer.",
                "Pass/Fail Criteria": "L2vpn bridge domain bd name detail verification is performed.\nL2vpn forwarding bridge domain mac address internal location verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging default min with bun ac phy bun pw",
                "Procedure": "The mac address is verified to be learned from both the BUN AC and PHY PW sources. The configuration involves shutting down the BUN PW, while the verification checks that the mac address is indeed learned and expires after the default timer has passed. This test is triggered when no specific trigger event is specified.",
                "Pass/Fail Criteria": "L2vpn bridge domain bd name detail verification is performed.\nL2vpn forwarding bridge domain mac address internal location verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging via ac ac",
                "Procedure": "The test case checks whether a MAC address is learned through ac_ac. It involves configuring a non-default MAC timer, verifying that it's set up and later removed, but there are no triggers for this test.\n\nThis test is triggered by the absence of any specific events or conditions.",
                "Pass/Fail Criteria": "L2vpn forwarding bridge domain mac address internal location verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Broadcast multicast traffic",
                "Procedure": "Broadcast and multicast traffic are verified in this test case, which checks that destination MAC addresses are not learned and traffic is broadcasted. Configurations include no specific settings. The verification process confirms that the desired behavior occurs.\n\nThis test is triggered when there is a lack of configuration details.",
                "Pass/Fail Criteria": "Interface output count verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ac interface flap",
                "Procedure": "The test case checks how the MAC address ageing behavior is affected when the AC (Air Conditioning) system is turned on and off. The configurations include shutting down and turning back on the AC, while the verifications check that the MAC address is flushed after each action.\n\nThis test is triggered by the shutdown or restart of the Air Conditioning system.",
                "Pass/Fail Criteria": "L2vpn forwarding bridge domain mac address internal location verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging mac flush ac interface flap",
                "Procedure": "Mac aging and mac flush are verified on a bridge device (BD) connected to multiple access control (AC) interfaces while experiencing multiple link flaps. The test setup includes the configuration of the BD and AC interfaces.\n\nThis test is triggered by performing multiple flap events between AC interfaces and verifying that mac aging and mac flush occur correctly in response to these changes.",
                "Pass/Fail Criteria": "mac aging and mac flush from BD with multiple AC interface flap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging ac different timer",
                "Procedure": "Verification of MAC learning and aging for multiple Air Conditioners (AC) with various timer configurations is performed. Each AC has its unique setup, allowing for diverse testing scenarios to be executed.\n\nThis test is triggered by verifying mac learning and ageing of multiple AC with different timer configuration under each AC.",
                "Pass/Fail Criteria": "mac learning and aging of multiple AC with different timer configuration under each AC verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac learning disable bd",
                "Procedure": "When configuring MAC learning on a single Bridged Domain (BD) and multiple BDs, verification is required. The test procedures involve disabling MAC learning on both types of domains to ensure that the functionality works as expected.\n\nThis test is triggered by disabling MAC learning for testing purposes in order to verify the correct operation of the network under these conditions.",
                "Pass/Fail Criteria": "Configure Mac learning disable on singlle BD and multiple BD and verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging bum traffic physical",
                "Procedure": "Flooding occurs when there is a high volume of BUM traffic between two physical access points (APs), specifically between an AP (AC) and a port, or a port (PW). This test is triggered by a specific configuration where BUM traffic is intentionally enabled for testing purposes.",
                "Pass/Fail Criteria": "Check flooding happens for BUM traffic from one physical AC to another AC and AC to PW and vice versa verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging flooding",
                "Procedure": "Flooding occurs when traffic is sent from a physical sub-interface AC to another sub-interface AC, or from a sub-interface AC to a sub-interface PW, and the reverse also happens. This test is triggered by attempting to send traffic across a network where a physical sub-interface connects directly with another sub-interface, or where a sub-interface connected via protocol wire (PW) sends data to one connected directly.",
                "Pass/Fail Criteria": "Check flooding happens from one physical sub-interface AC to another sub-interface AC and one sub-interface AC to sub-interface PW and vice versa verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging bum traffic bundle",
                "Procedure": "Flooding of BUM traffic can occur when there is a transfer of traffic between different types of bundles, such as from a bundle AC (Access-Edge Network) to another bundle AC or to a bundle PW (Packet Wire), and also in the reverse direction. \n\nThis test is triggered by the exchange of BUM (Broadcast, Unknown-Unicast, Multicast) traffic between bundles of type AC and bundles of type PW.",
                "Pass/Fail Criteria": "Check flooding of BUM traffic happens from one bundle AC to another bundle AC and one bundle AC to bundle PW and vice versa verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging unicast bundle",
                "Procedure": "The test sends ac-ac, ac-pw, and pw-ac unicast traffic as a bundle and checks for mac aging with various configurations to ensure proper operation.\n\nThis test is triggered by sending AC-AC, AC-PW, or PW-AC unicast traffic in a bundled format.",
                "Pass/Fail Criteria": "Send AC-AC, AC-PW, PW-AC unicast traffic as bundle and check for mac aging with different configs. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging vpls bundle",
                "Procedure": "The configuration of basic VPLS involves setting up a bundle subinterface on an access concentrator (AC) and checking for MAC address ageing. This is done by sending traffic to the multiple bundle sub interfaces, which can be achieved through various test procedures.\n\nThis test is triggered by testing the functionality of a bundle sub interface on an AC in a basic VPLS configuration.",
                "Pass/Fail Criteria": "Configure basic VPLS and check for mac aging by sending traffic to multiple Bundle-sub interface AC verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging bum bundle subinterface",
                "Procedure": "Flooded traffic on a BUM (Broadcast, Unknown Unicast, Multicast) can occur between two bundle-sub interfaces of type AC or between a bundle-sub interface of type AC and a bundle-sub interface of type PW. When this situation occurs, it may cause network congestion.\n\nThis test is triggered by the exchange of Layer 2 traffic between two BUM-enabled ports that are connected via a bundle-sub interface AC, or between a BUM-enabled port and a PWE3-enabled port that are connected via a bundle-sub interface PW.",
                "Pass/Fail Criteria": "Check flooding of BUM traffic happens from one bundle-sub interface AC to another bundle-sub interface AC and one bundle-sub interface AC to bundle-sub interface PW and vice versa verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging unicast bundle subinterface",
                "Procedure": "The test involves sending AC-AC, AC-PW, and PW-AC unicast traffic as a bundle subinterface to verify MAC aging with various configurations.\n\nThis test is triggered by sending AC-AC, AC-PW, and PW-AC unicast traffic as a bundle subinterface.",
                "Pass/Fail Criteria": "Send AC-AC, AC-PW, PW-AC unicast traffic as bundle sub-interface and check for mac aging with different configs. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging multiple bundle ac",
                "Procedure": "To add multiple members to a bundle, first configure the bundle AC and the bundle PW, then verify that there is no flooding by checking the output of the \"show ip cef\" command. This test is triggered by a user attempting to add more than one member to an existing bundle.",
                "Pass/Fail Criteria": "Add multiple members to bundle AC and bundle PW and check for flooding and corresponding mac flush verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging phy to bundle ac",
                "Procedure": "The configuration involves setting up both physical and bundle access control (AC) protocols. It's also necessary to perform a series of checks, including verifying that the system correctly switches between physical and bundle AC modes, as well as ensuring that the MAC address aging time is functioning properly.\n\nThis test is triggered by configuring the device with both physical and bundle AC settings, which then activates the system's ability to switch between these modes.",
                "Pass/Fail Criteria": "Configure and check for physical to bundle AC and bundle to physical AC and verify mac aging time. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging phy ac to bundle pw",
                "Procedure": "To configure the system, set up a physical AC with bundled Power Window (PW) and also bundle AC with physical PW. Additionally, ensure that the MAC address aging time is verified. This test is triggered by the need to confirm proper bundling of systems for accurate operation in different configurations.",
                "Pass/Fail Criteria": "Configure and check for physical AC to bundle PW and bundle AC to physical PW and verify mac aging time. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging split horizon physical",
                "Procedure": "To verify split horizon functionality, test with a physical and physical subinterface, as well as a bundle and bundle subinterface. This test is triggered by configuring the interfaces accordingly.",
                "Pass/Fail Criteria": "Split horizon with physical, physical sub AC and with bundle and bundle sub AC verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac address range verify",
                "Procedure": "The verification process involves checking the range of MAC address aging for static MAC addresses. The test procedures begin with configuring a specific setup.\n\nThis test is triggered by the configuration of a device to use a static MAC address and check how the system handles MAC address aging in that particular context.",
                "Pass/Fail Criteria": "range of Mac address aging for Static Mac address verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac withdraw disable enable",
                "Procedure": "To test MAC withdrawal and verification, perform the following steps. Disable and enable MAC address to ensure that it is not stuck in a wrong state. Verify that the MAC address is correctly retrieved from the switch when the interface is enabled. This test is triggered by a change in the MAC address configuration of an interface.",
                "Pass/Fail Criteria": "Disable and enable MAC withdraw and verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging mac address limit action",
                "Procedure": "To verify that device identification based on MAC address is functioning properly when a certain number of devices have been identified, follow these steps.\n\nConfiguration:\n\n* Verify that the MAC address limit action is enabled.\n* Identify all devices connected to the network using their MAC addresses. This test is triggered by having more than or equal to X devices with the same MAC address detected on the network, where X is a configuration parameter set for this type of device identification.",
                "Pass/Fail Criteria": "mac aging with MAC address limit action enabled verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging physical hqos profile",
                "Procedure": "The mac aging test for AC-AC, AC-PW, and PW-AC physical interfaces with an HQOS profile is verified. The configuration for this test involves setting up the system in a specific manner, which includes verifying that the mac address is cleared when a new link partner becomes present on the network.\n\nThis test is triggered by the presence of a new link partner on the AC-AC, AC-PW, or PW-AC physical interface with an HQOS profile.",
                "Pass/Fail Criteria": "mac aging for AC-AC, AC-PW, PW-AC physical interface with HQOS profile verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging physical subinterface hqos profile",
                "Procedure": "To verify MAC addressing on an AC-AC, AC-PW, or PW-AC physical subinterface with a Headquarters Open Shortest Path First (HQOS) profile, follow these steps. The test is triggered by selecting the specific interface type in question and configuring it with an HQOS profile.\n\nThis test is triggered by selecting the specific interface type in question and configuring it with an HQOS profile.",
                "Pass/Fail Criteria": "mac aging for AC-AC, AC-PW, PW-AC physical sub interface with HQOS profile verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging bundle hqos profile",
                "Procedure": "Verification of MAC addressing in AC-AC, AC-PW, and PW-AC bundles that use the High-Quality Service (HQOS) profile should involve checking the test procedures for configuration. This test is triggered by a change to the HQOS profile in the bundle interface.",
                "Pass/Fail Criteria": "mac aging for AC-AC, AC-PW, PW-AC bundle interface with HQOS profile verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging bundle subinterface hqos profile",
                "Procedure": "To verify mac aging for AC-AC, AC-PW, and PW-AC bundle subinterface configurations with an HQOS profile, the following test procedures are used. \n\nConfiguration:\nVerify that all devices in the configuration have been properly set up and connected to one another.\n\nThis test is triggered by initiating a connection between two devices in different domains over a point-to-point link and then testing for mac aging behavior after a certain amount of time has elapsed.",
                "Pass/Fail Criteria": "mac aging for AC-AC, AC-PW, PW-AC bundle sub interface with HQOS profile verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add delete bundle member hqos profile",
                "Procedure": "Configuration for a bundle and its sub-bundle is set up using the HQOS profile to test addition and deletion of bundle members through the bundle and sub-bundle interfaces.\n\nThis test is triggered by configuration changes in the bundle and sub-bundle interfaces involving the addition or removal of bundle members.",
                "Pass/Fail Criteria": "Addition and deletion of bundle members from bundle and sub-bundle interface with HQOS profile. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Split horizon hqos profile",
                "Procedure": "To verify split horizon functionality, configure a HQOS (Header Queueing and Object Store) profile to test with both physical and physical sub interfaces, as well as bundle and bundle sub interfaces. \n\nThis test is triggered by configuration settings that enable split horizon in the HQOS profile for the specified interface types.",
                "Pass/Fail Criteria": "Split horizon with physical, physical sub, bundle and bundle sub in HQOS profile. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mac aging evpn control plane",
                "Procedure": "The test verifies that the system correctly ages EVPN control-plane MAC addresses learned through BGP. The test procedures require configuration of EVPN with control-plane MAC learning enabled. This test is triggered by verifying that an EVPN BGP advertisement for a new, unexpected MAC address causes the aged address to be flushed from the system's MAC table within a specified time frame.",
                "Pass/Fail Criteria": "Mac aging for EVPN control-plane MAC learning verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging mh evpn",
                "Procedure": "To verify MAC address aging for a Multi-Homed External Virtual Private Network (EVPN) setup, follow these test procedures:\n\nVerify that the device is configured to support MAC address aging. This test is triggered by sending multiple ARP requests with different source MAC addresses from the same host.",
                "Pass/Fail Criteria": "mac aging for MH EVPN setup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging sh evpn",
                "Procedure": "Verification of MAC address aging is necessary for setting up Single-Homed EVPN (EVPN) configurations. For this test, a series of configuration procedures must be followed. This test is triggered by verifying that the configured MAC address aging time matches the expected value on all network devices in the SH EVPN setup.",
                "Pass/Fail Criteria": "mac aging for SH EVPN setup verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify stp synce packets",
                "Procedure": "The test for verifying STP verifies that switch-to-switch link information is properly received from neighboring devices by sending SyncE control packets. It appears that a certain configuration is required in order to run this test.\n\nThis test is triggered by the presence of a configured Synce control packet.",
                "Pass/Fail Criteria": "STP, Synce control packets verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging bvi",
                "Procedure": "Mac aging can be verified via BVI (Bridge-VLAN Interface) by configuring a trunk connection between two switches, where one switch is on layer 2 and the other on layer 3. The test involves sending traffic from the layer 3 switch to the layer 2 switch.\n\nThis test is triggered by establishing a trunk link between L3-to-L2 switches with BVI configured on both sides.",
                "Pass/Fail Criteria": "mac aging via BVI for L2 to L3 with traffic from L3 to L2 verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging erps inclusion",
                "Procedure": "Mac verification for ERP APS/ inclusion L2 bridge ports involves testing to ensure that MAC addresses are properly propagated across all interfaces on a switch. When verifying configuration settings, check that STP is enabled and spanning tree protocol parameters are set as required. This test is triggered by the presence of an ERP AP connected to a network through a L2 bridge port, which causes the switch to behave in a specific way under normal conditions. \n\nThis test is triggered by the presence of an Access Point (AP) that supports the Extended Roaming Protocol (ERP), which is connected to a network through a Layer 2 bridge port, causing the switch to propagate MAC addresses and forward traffic as required.",
                "Pass/Fail Criteria": "Mac aging for ERP APS/inclusion l2bridgeports verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging erps exclusion",
                "Procedure": "The system verifies Mac aging for ERP APS/exclusion L2 bridge ports.\n\nThis test is triggered by verifying that Mac aging is enabled for Enterprise VLAN Access Ports (ERP) and excluded from Layer 2 bridge ports.",
                "Pass/Fail Criteria": "Mac aging for ERP APS/exclusion l2bridgeports verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging mac move functionality",
                "Procedure": "To verify that Mac ageing is functioning correctly, test procedures are required to check for successful completion of a move operation using the Mac move functionality.\n\nThis test is triggered by an attempt to move a Mac from one server to another.",
                "Pass/Fail Criteria": "Mac aging with Mac move functionality verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging timer lesser than min",
                "Procedure": "The Mac age timer should be configured with a value less than the minimum allowed value. The test procedures are as follows: Configuration: This test is triggered by configuring the Mac age timer with a value that is lower than its lowest permitted setting.",
                "Pass/Fail Criteria": "Configure Mac age timer with the value lesser than the minimum value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging timer greater than max",
                "Procedure": "The Mac age timer is configured to be greater than its maximum value.\n\nThis test is triggered by configuring a Mac age timer to have a value greater than its maximum value.",
                "Pass/Fail Criteria": "Configure Mac age timer with the value greater than the maximum value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging after removing bridge domain",
                "Procedure": "Bridge domain configuration should be removed from the bridge group before proceeding with further testing. This test is triggered by a requirement to configure bridge domains outside of bridge groups. \n\nThe rewritten trigger sentence was the last line, but since it doesn't quite fit as written, here's an alternative that might work better: 'This test is typically performed when configuring bridge domains independently of bridge groups.'",
                "Pass/Fail Criteria": "Remove bridge domain configurarion from the bridge group verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging after removing bundle members",
                "Procedure": "The bundle members need to be removed from the bundle interface. To do this, follow the test procedures outlined below. The configuration should be in place before proceeding.\n\nThis test is triggered by the removal of all existing bundle members from the bundle interface during configuration setup.",
                "Pass/Fail Criteria": "Remove all the bundle members from the bundle interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging after disable mac age timer",
                "Procedure": "To test whether the Mac age timer is disabled, you need to configure it first.\n\nThis test is triggered by checking the configuration settings that are related to the Mac age timer.",
                "Pass/Fail Criteria": "Disable Mac age timer and check for results verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging process",
                "Procedure": "The verify process test for L2VPN manager involves restarting or crashing it, and also includes testing shutting down or bringing up the process. This test is triggered by a specific condition that needs to be identified and implemented according to the existing configuration settings.",
                "Pass/Fail Criteria": "process l2vpn_mgr restart/crash, process shut/unshut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging across lc",
                "Procedure": "The test involves adding bundle members across different Local Controllers (LC) and then reloading one of the LCs to verify that the Mac address is flushed across all LCs.\n\nThis test is triggered by a change in the configuration of bundle members across multiple Local Controllers.",
                "Pass/Fail Criteria": "Add bundle members across different LC and this time reload one LC;verify Mac flush across LC. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging rp reload",
                "Procedure": "To verify that Remote Procedure (RP) reloaded is working correctly, the system should be configured according to standard procedures.\n\nThis test is triggered by a scenario where RP reload is required.",
                "Pass/Fail Criteria": "RP reload verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging before after sso",
                "Procedure": "Here is the rewritten text:\n\nVerify that a client's MAC address remains unchanged before and after a Single Sign-On (SSO) process to ensure proper authentication. \n\nThis test is triggered by changes to the network configuration involving Single Sign-On processes affecting the assignment of client MAC addresses.",
                "Pass/Fail Criteria": "mac aging before and after SSO verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging between sso",
                "Procedure": "Verification of MAC address consistency is essential during a redundancy switch-over (SSO) test to ensure that all devices maintain their assigned addresses. The test procedures involve configuring the system.\n\nThis test is triggered by performing a manual or automated reboot of the device after verifying the SSO configuration settings, allowing for an accurate verification of MAC address changes or consistency.",
                "Pass/Fail Criteria": "mac aging between the SSO [redundancy switch-over] verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Reload rp verify mac flush",
                "Procedure": "When reloading the Remote Procedure (RP) a certain number of times, we need to check if there's a MAC flush involved in the process. This involves verifying that all the required configuration settings are met.\n\nThis test is triggered by checking that the RP reload occurs as specified after a set number of reloads have been attempted.",
                "Pass/Fail Criteria": "Reload RP number of times and check for mac flush verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Reload lc verify mac flush",
                "Procedure": "The test involves reloading the LC number a specified number of times to determine if the MAC address is flushed properly.\n\nThis test is triggered by the requirement that the device's MAC address should be reset after a certain number of reloads.",
                "Pass/Fail Criteria": "Reload LC number of times and check for mac flush verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rollback configs",
                "Procedure": "When multiple erasures occur, the config is rolled back multiple times, which can lead to data loss.\n\nThis test is triggered by a series of repeated attempts to erase and roll back configurations.",
                "Pass/Fail Criteria": "Multiple times erase and rollback configs verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Shut unshut ac and multiple times",
                "Procedure": "Multiple shutdowns and startups of both Air Conditioning (AC) and Power Window (PW) systems are necessary for testing.\n\nThis test is triggered by performing multiple shutdowns and startups of the vehicle's AC and PW systems.",
                "Pass/Fail Criteria": "Shut/Unshut AC and PW multiple times verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove ports multiple times",
                "Procedure": "To test adding and removing multiple ports, the following configuration should be used. First, configure a port to use both transmit and receive functions. Then, add another port in a similar manner, ensuring it can also handle both transmission and reception of data. Next, remove one of these secondary ports from the system, verifying that only the primary port remains active. This test is triggered by adding at least two additional ports beyond the standard configuration, utilizing their full capabilities before selectively removing them.",
                "Pass/Fail Criteria": "Add/Remove ports multiple times verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging with 8k phy bundle ac",
                "Procedure": "Mac aging is verified by running 8K physical and bundle AC test procedures in a configuration that includes verification.\n\nThis test is triggered by a request to verify mac aging.",
                "Pass/Fail Criteria": "mac aging with 8K physical and bundle AC verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging with 4k bundle sub interface ac",
                "Procedure": "Configuration involves setting up the system to verify MAC address aging behavior on a 4K bundle sub-interface. This requires selecting the specific test case or scenario to be run, determining the relevant parameters and inputs, and configuring the system accordingly. The configuration should also include specifying any necessary filtering options for packet capture and analysis tools.\n\nThis test is triggered by the activation of the MAC address aging feature on a 4K bundle sub-interface under specific network conditions.",
                "Pass/Fail Criteria": "mac aging with 4K bundle sub interface AC verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging with 250 bridge domain",
                "Procedure": "To verify MAC aging with 250 bridge domains in a VPLS configuration, perform the following steps. The test is triggered by a configuration change that involves adding multiple bridge domains and enabling MAC aging on each device involved.",
                "Pass/Fail Criteria": "mac aging with 250 bridge domain in VPLS config verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging with 512 ac per bd",
                "Procedure": "Configuration involves setting up the system to test verification of MAC addressing on a 512 AC by byte basis. This is done by following specific steps to ensure accurate results.\n\nThis test is triggered by the need to verify that MAC addresses are properly assigned and recognized on a device with a 512 AC byte capacity, which would require multiple iterations to confirm correct identification across all boundaries.",
                "Pass/Fail Criteria": "mac aging with 512 AC per BD verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify mac aging with 128k mac per lc",
                "Procedure": "The verification of 128K MACs per LC involves a series of test procedures that require careful configuration.\n\nThis test is triggered by verifying whether each location control (LC) supports at least one 128K Media Access Control (MAC).",
                "Pass/Fail Criteria": "128K MACs per LC verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify 64k mac per bd",
                "Procedure": "The verify 64K Mac per BD test procedures involve a configuration where the MAC (Media Access Control) address is verified against the block descriptor (BD). The procedures for this test are based on a specific setup.\n\nThis test is triggered by the detection of any discrepancy between the MAC address and the block descriptor.",
                "Pass/Fail Criteria": "64k Mac per BD verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify 250 bd cpu utilization",
                "Procedure": "When testing bridge domains with a verification CPU that monitors memory utilization across various MAC addresses and timer settings, the configuration is critical. The test procedures specify the steps to be taken during this process.\n\nThis test is triggered by changes in the verify cpu setting for different mac age timers.",
                "Pass/Fail Criteria": "With 250 bridge domain verify CPU memory utilization for different range of mac age timer verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale bridge domain",
                "Procedure": "The test verifies the bridge domain (BD) scale with a physical AC subinterface configured on the device. Configurations include setting up 1500 subinterfaces on physical interfaces and creating a BD with two access circuits (ACs). The test then checks the traffic on all bridge domains and mac learning on all bridge domains. Additionally, it verifies that traffic resumes as expected after removing l2vpn and rolling back the configuration. This test is triggered by removing L2VPN to check if traffic stops, then rolling back the configuration to ensure traffic resumes normally.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nL2vpn forwarding bridge domain location verification is performed.\nTgenchecktrafficerror verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "udld_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Udld aggressive dest mac broad",
                "Procedure": "To test the UDLD aggressive mode, you can use a destination MAC broadcast address. This includes testing the functionality in this configuration: UDLD.\n\nThis test is triggered by using a destination MAC broadcast address to test the UDLD aggressive mode.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld interfaces verification is performed.\nudld aggressive mode with broadcast mac address verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal dest mac broad",
                "Procedure": "The test involves checking how the device handles the normal mode of the Universal Downstream Detection (UDLD) protocol, specifically when the destination MAC address is set to a broadcast address. This requires validating both the configuration and unconfiguration of UDLD in its normal mode. The specific configurations for this test include enabling UDLD. \n\nThis test is triggered by setting the destination MAC address to the broadcast address during the UDLD normal mode configuration or validation process.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal mode",
                "Procedure": "The test case is designed to validate the configuration and de-configuration of UDLD (Unidirectional Link Detection) in normal mode. It performs a series of operations to verify that UDLD is functioning as expected in its default state. This test is triggered by initiating a UDLD connection on a network device with the configuration set for normal mode, followed by disabling and re-enabling the feature to confirm that it can be successfully de-configured.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal routed interface",
                "Procedure": "To validate the configuration and deconfiguration of UDLD in normal mode when routing is enabled, the test performs the following operations: it configures UDLD in normal mode, verifies that it has been successfully configured, displays the UDLD status for a specified interface using the \"show ethernet udld interfaces\" command, and then deletes the UDLD configuration. This test is triggered by Configurations - UDLD.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal bundle interface",
                "Procedure": "To validate config and unconfig of udld normal mode with bundle interface, the test performs the following operations. It first configures udld normal mode on a bundle interface, then verifies that the interface is in udld normal mode. Next, it runs the command 'show ethernet udld interfaces <interface name>' to confirm the status. Finally, it deletes the udld normal mode configuration.\n\nThis test is triggered by the Configurations: - UDLD",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode with bundle interface verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal shut noshut",
                "Procedure": "UDLD is enabled in normal mode, which shuts down the interface and verifies that UDLD can detect a link failure. The interface is then unshut to allow traffic to flow again through the link.\n\nThis test is triggered by enabling UDLD in normal mode.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal dest mac",
                "Procedure": "UDLD is a protocol that detects and prevents link failures. It performs the following functions: Configuring it to operate in normal mode, which means that it will not send UDLD traffic when there are no faults, but instead will only respond to any incoming traffic. When configured with a normal destination MAC address, it verifies that the other end of the connection is also configured for UDLD. The protocol can be configured using the following settings: The UDLD mode and destination MAC address.\n\nThis test is triggered by the presence of UDLD configuration in the switch.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nTraffic verification is performed.\nudld normal mode with unknown mac address verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal bundle shut noshut",
                "Procedure": "UDLD can be tested by enabling and disabling it on a bundle interface, with the interface first being shut down and then brought back up.\n\nThis test is triggered by attempting to configure or unconfigure UDLD on a bundle interface that has been shut down and later brought back online.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode with bundle interface shut and no shut verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal only one end",
                "Procedure": "When testing the UDLD normal mode, perform a test case that validates the configuration and de-configuration of UDLD normal mode on only one end. The test involves verifying that UDLD is in its normal operating state. Configurations for this test include enabling UDLD.\n\nThis test is triggered by an attempt to configure or unconfigure UDLD settings on only one end of a network device.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode on one end verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal device name change",
                "Procedure": "Testing the UDLD (Unidirectional Link Detection) normal mode involves making a device name change on one end to verify the functionality of this feature. This test is triggered by configuring UDLD, which should be done in preparation for the test.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal mode clear stats",
                "Procedure": "To test the UDLD (Universal Device Link Detection) functionality in normal mode, you need to configure it first and then clear the Ethernet statistics to verify that the link is functioning correctly. This involves clearing the UDLD statistics for all ports while UDLD is operating in normal mode.\n\nThis test is triggered by the configuration of UDLD in normal mode.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld statistics verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal mode cdp enable",
                "Procedure": "The test involves configuring CDP (Cisco Discovery Protocol) to be enabled, while also setting UDLD (Unidirectional Link Detection) to operate in normal mode.\n\nThis test is triggered by the configuration of CDP enabling and UDLD being set to normal operation.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode with bundle interface shut and no shut verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal mode cdp enable shut noshut",
                "Procedure": "To test UDLD in normal mode with CDP enabled, configure UDLD to operate in normal mode and enable CDP on all ports. This test is triggered by enabling CDP globally and setting the UDLD mode to normal on a given port.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode with shut and no shut verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal mode cdp enable bundle",
                "Procedure": "The test for UDLD in normal mode with CDP enabled involves the following steps: configurations are set so that CDP is enabled and UDLD operates in normal mode. This test is triggered by a configuration where CDP is enabled and UDLD is operating in normal mode.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode with bundle interface verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld config unconfig",
                "Procedure": "This test validates the configuration and deconfiguration of Udld by performing the following operations: it configures Udld in normal mode, then checks that the configurations are correct.\n\nThis test is triggered by a user initiating a change to the Udld settings.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld statistics verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive mode",
                "Procedure": "UDLD (Unidirectional Link Detection) mode in an aggressive configuration is tested by performing a series of operations to validate its setup and teardown.\n\nThis test is triggered by entering the \"Test udld mode aggressive\" command, which initiates the validation process for the UDLD aggressive mode configurations.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nudld aggressive mode verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive routed interface",
                "Procedure": "To test the UDLD aggressive mode with a routed interface, the configuration and unconfiguration of this mode must be validated using a test case that simulates the following operations: configurations are set to include UDLD, then configurations without UDLD are applied. This test is triggered by setting an interface to \"udld port disable\" and then immediately changing it to \"udld aggressive\".",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nudld aggressive mode with routed interface verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive bundle interface",
                "Procedure": "To test the UDLD aggressive mode with bundle interfaces, a test case is required to validate the configuration and deconfiguration of this feature on bundle interfaces. This test involves configuring UDLD, which stands for UniDirectional Link Detection. The configurations include enabling or disabling UDLD.\n\nThis test is triggered by changing the UDLD mode from normal to aggressive on a bundle interface.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nudld aggressive mode with bundle interface verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive shut noshut",
                "Procedure": "The test for the UDLD aggressive mode involves verifying its configuration and deconfiguration in both a \"shut\" state and without shutting down the interface. This includes testing the configuration and deconfiguration of the UDLD aggressive mode. The specific test procedures involve the following operations:  Configurations: - UDLD aggressive mode enabled, disabled, and verified for each condition.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld interfaces verification is performed.\nudld aggressive mode with shut and noshut verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive dest mac",
                "Procedure": "To test the UDLD (Unidirectional Link Detection) aggressive mode, specify a destination MAC address to send UDLD packets to. Include this destination MAC address when testing the feature and verify that it functions as expected.\n\nThis test is triggered by specifying a destination MAC address in the configuration of UDLD's aggressive mode.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld interfaces verification is performed.\nudld aggressive mode with unknown mac address verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive bundle shut",
                "Procedure": "To test the UDLD mode in an aggressive state, both bundle interfaces should be shut down. The tests will verify that the functionality is working correctly.\n\nThis test is triggered by setting the UDLD mode to aggressive and shutting down all bundle interfaces.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld interfaces verification is performed.\nudld aggressive mode with bundle interface shut no shut verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive device name change",
                "Procedure": "To test the UDLD (UniDirectional Link Detection) aggressive mode with a device name change, first configure the necessary settings including the UDLD feature. This test is triggered by changing the device name on one of the ports while UDLD is enabled in aggressive mode to verify that the link detection functionality operates correctly.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld interfaces verification is performed.\nudld aggressive mode verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive one end",
                "Procedure": "To test UDLD in aggressive mode on one end of a network connection, perform the following steps. The configurations include enabling UDLD. This test is triggered by configuring two devices to exchange UDLD protocol messages with their ports enabled to aggressively detect link failures.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld aggressive mode with one end disable verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive mode clear stats",
                "Procedure": "The test cases are designed to verify that clearing the Ethernet UDLD (Unidirectional Link Detection) statistics in aggressive mode works as expected. To achieve this, two test cases are run with the same configuration: UDLD is enabled in aggressive mode. This test is triggered by changing the UDLD mode from non-aggressive to aggressive on a network interface and verifying that the statistics are cleared after running the command \"clear ethernet udld statistics all\".",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld statistics verification is performed.\nudld aggressive mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive mode cdp enable",
                "Procedure": "To test the configuration and deconfiguration of aggressive UDLD mode with CDP enabled, a series of operations are performed: configures CDP to be enabled along with aggressive UDLD mode, and then checks that these configurations are correctly set.\n\nThis test is triggered by the need to validate the configuration and deconfiguration of aggressive UDLD mode when CDP is enabled.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nudld aggressive mode with bundle interface shut and no shut verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive mode cdp enable bundle",
                "Procedure": "To validate the configuration and unconfiguration of UDLD aggressive mode with CDP enabled, perform the following operations: configure CDP to be enabled with UDLD in aggressive mode, then verify that the configurations have taken place. This test is triggered by validating config and unconfig of udld aggressive mode with cdp enable.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nudld aggressive mode with bundle interface verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive mode cdp enable shut noshut",
                "Procedure": "To test and validate the configuration and unconfiguration of UDLD (Unidirectional Link Detection) in aggressive mode when CDP (Cisco Discovery Protocol) is enabled, perform the following steps. The network should be configured to include CDP enabled with UDLD set to aggressive mode. Perform the operations described below: Config cdp enable with udld aggressive mode. This test is triggered by setting UDLD to aggressive mode while CDP is enabled on a Cisco device.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld interfaces verification is performed.\nudld aggressive mode with shut and no shut verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld aggressive config unconfig",
                "Procedure": "To validate the configuration and unconfiguration of UDLD (Unidirectional Link Detection), a test case is performed. It involves configuring UDLL in aggressive mode and verifying that it functions correctly, then attempting to unconfigure it while ensuring that all settings are properly removed.\n\nThis test is triggered by the requirement to ensure proper functioning of UDLD configurations when operating in aggressive mode.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld statistics verification is performed.\nudld aggressive mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal aggressive mode",
                "Procedure": "The test case is designed to validate the configuration and unconfiguration of UDLD in both normal and aggressive modes. It performs two operations: verifying that UDLD is set to its default (normal) mode, and then setting it to an aggressive mode for one side while keeping the other side in normal mode. This test is triggered by a scenario where there are different types of network devices on opposite sides of a link with varying configurations for UDLD.\n\n(Note: The trigger sentence is rewritten as per your request.)",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld database verification is performed.\nudld normal mode and aggressive mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal aggressive bundle interface",
                "Procedure": "The test case is designed to validate the configuration and de-configuration of UDLD in normal mode, as well as aggressive mode, when used on a bundle interface. It involves performing several operations, including configuring UDLD in normal or aggressive mode using a bundle interface, verifying that it is working correctly, checking the status with the 'show ethernet udld interfaces' command, and then deleting the configuration. Configurations include enabling UDLD.\n\nThis test is triggered by changes to the UDLD configurations.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld database verification is performed.\nudld normal mode/aggressive with bundle interface verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld normal aggressive shut noshut",
                "Procedure": "When performing a test for normal shutdown, you configure UDLD in normal mode on one interface and in aggressive mode on another. You then shut down an interface and verify that UDLD is disabled, before unshutting it to check that UDLD is re-enabled.\n\nThis test is triggered by the need to ensure that the User Datagram Protocol (UDLP) Link Down Detection protocol functions correctly in both normal shutdown and aggressive modes.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld database verification is performed.\nudld normal mode verification is performed.\nudld aggressive mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld multi session",
                "Procedure": "To validate the configuration and de-configuration of UDLD with multiple sessions, a test is performed that carries out the following steps: configures UDLD in normal mode, specifies the configurations including UDLD, performs the operations, then unconfigures UDLD. This test is triggered by performing all the necessary actions to configure and subsequently unconfigure UDLD under normal operating conditions, but in multiple sessions at the same time.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld multi session with bundle",
                "Procedure": "The test performs a UDLD (UniDirectional Link Detection) test with multiple sessions, bundled together. It configures UDLD in normal mode and includes the following configurations: UDLD settings.\n\nThis test is triggered by executing the command 'udld port enable' on all participating ports.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld multi session shut",
                "Procedure": "The test involves performing a series of operations to simulate a network scenario where the link is shut down, and then triggering a specific test condition.\n\nThis test is triggered by the configuration of the device being in UDLD normal mode.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart multi session",
                "Procedure": "The processes that support test restart are located in two systems, LC and RP. These systems handle the following processes: ifmgr, spp, spio_ea, and udld_daemon. The configuration for this feature is related to the UDLD.\n\nThis test is triggered by changes made to the UDLD configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"ifmgr\" and \"spp\" and \"spio_ea\" and \"udld_daemon\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Triggers multi session",
                "Procedure": "The test is triggered by a multi-session test that covers reload, lc_oir, and rpfo triggers. It involves various configurations, including UDLD.\n\nThis test is triggered by a multi-session test that covers specific trigger types, including reload, lc_oir, and rpfo, and requires particular configurations such as UDLD.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"lc_oir\" and \"rpfo\"",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nStandby rp verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld multi session clear stats",
                "Procedure": "The test configuration and unconfiguration of UDLD (Universal Device Language Layer Discovery) with multiple sessions involves performing several operations, including configuring UDLD in normal mode and setting various configurations such as UDLD protocol version. This test is triggered by a change in the network or system settings related to UDLD operations.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld statistics verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld multi session config unconfig",
                "Procedure": "UDLD (Unidirectional Link Detection) can be tested in both normal and abnormal modes, including a configuration and re-configuration test with multiple sessions. The test performs several key operations: it configures UDLD to run in normal mode and records the configurations used during this process.\n\nThis test is triggered by a series of pre-defined operations, including configuring UDLD to operate normally and configuring various parameters for the protocol.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld statistics verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process restart",
                "Procedure": "The tests that process restart are triggered for both the Local Controller (LC) and Remote Processor (RP). These processes include ifmgr, spp, spio_ea, and udld_daemon. The restart is applicable to configurations involving Universal Device Language (UDLD).\n\nThis test is triggered by UDLD configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"ifmgr\" and \"spp\" and \"spio_ea\" and \"udld_daemon\"",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nTraffic verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Triggers",
                "Procedure": "The test triggers for this feature include the events 'reload', 'lc_oir', and 'rpfo'. It covers configurations that involve UDLD, which is a standard protocol used to prevent network loops.\n\nThis test is triggered by the occurrence of specific events or configuration changes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"lc_oir\" and \"rpfo\"",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nStandby rp verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld interface level",
                "Procedure": "Here is a rewritten version of the text in a single, natural-sounding paragraph.\n\nThis test case is designed to validate the configuration and unconfiguration of UDLD (Unidirectional Link Detection) in normal mode. It performs several operations, including checking that all relevant fields such as port number, FSM state, destination MAC address, message interval, and neighbor details match their configured values. The configurations used for this test include enabling UDLD.\n\nThis test is triggered by a change to the device's configuration settings.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld interface level database",
                "Procedure": "The test case is designed to validate the configuration and de-configuration of UDLD in normal mode. It performs several checks on an interface, including verifying its MAC address, destination MAC address, FSM state, and neighboring device details.\n\nThis test is triggered by a configuration of UDLD in normal mode.",
                "Pass/Fail Criteria": "Ethernet udld database verification is performed.\nEthernet udld interfaces verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld daemon database <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld interface level statistics",
                "Procedure": "This test validates the configuration and deconfiguration of UDLD (Unidirectional Link Detection) in normal mode by checking that all relevant fields match the specified settings. It performs operations such as verifying port numbers, FSM states, destination MAC addresses, message intervals, and neighbor details against the configured values. Configurations for this test include enabling and disabling UDLD in its standard operation mode. This test is triggered by running a command to check the configuration of UDLD on a device.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld statistics verification is performed.\nudld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Show tech for udld",
                "Procedure": "The UDLD test can be performed by issuing a command to display technology information and checking the configurations. This test is triggered by the issue of a command to show technology details, specifically one that displays UDLD configurations.",
                "Pass/Fail Criteria": "udld normal mode verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Udld msg time",
                "Procedure": "The test case is designed to validate the configuration and deconfiguration of UDLD (Unidirectional Link Detection). It performs a series of operations, including checking that the dynamically changed message time falls within the range of 7 to 90 seconds. The relevant configurations include enabling UDLD.\n\nThis test is triggered by changes to the dynamically changed message-time <7-90> seconds in UDLD configurations.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nEthernet udld statistics verification is performed.\nudld active states verification is performed.\nshow ethernet udld interfaces <interface name> verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "y1564_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Y1564 rewrite push1 dot1ad external phy dot1q subinterface",
                "Procedure": "The configuration of the y1564 on phy dot1q subinterface is tested by verifying that it can be configured and works correctly for all relevant parameters. This test configures and verifies internal y1564 behavior with push1 dot1ad rewrite. This test is triggered by a Y1564 profile with push1 dot1ad rewrite configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 dot1ad external phy dot1q subinterface",
                "Procedure": "The configuration for testing the rewrite of 802.1Q and 802.1AD protocols on a subinterface is set up to test internal behavior with push2 mode. This test is triggered by configuring a Y1564 profile with push2 dot1ad rewrite, in order to verify all relevant parameters in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 external phy dot1q subinterface",
                "Procedure": "The configuration for testing the y1564 rewrite functionality involves setting up a specific test on the External phy dot1q subinterface, utilizing the y1564 profile with push2 rewrite configuration.\n\nThis test is triggered by configuring and verifying all Y1564 parameters in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 dot1ad external phy dot1ad subinterface",
                "Procedure": "The configuration includes testing the rewrite of dot1q to dot1ad on the phy subinterface, which is in the External direction for y1564. This test is triggered by configuring a y1564 profile with push1 dot1ad rewrite and verifying all Y1564 parameters in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 dot1ad external phy dot1ad subinterface",
                "Procedure": "The configuration involves testing the y1564 parameters on a phy dot1q subinterface, specifically the push2 dot1ad configuration, in an External direction. All Y1564 settings are then configured and verified for proper internal behavior using a y1564 profile that includes the push2 dot1ad rewrite feature. This test is triggered by a specific requirement to configure and verify all Y1564 parameters in the external direction with a y1564 profile that enables push2 dot1ad rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 external phy dot1ad subinterface",
                "Procedure": "The test involves configuring and verifying the push2 dot1ad configuration of y1564 in the External direction on a phy dot1q subinterface, specifically focusing on internal y1564 behavior with push2 rewrite. This test is triggered by the configuration of a y1564 profile with push2 rewrite.\n\nRewritten trigger sentence: \nThis test is triggered by the configuration of a y1564 profile with push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 dot1ad external phy dot1q priority tagged subinterface",
                "Procedure": "The test checks the configuration of the Y1564 protocol in the External direction on a phy-dot1q priority-tagged subinterface, including verifying its internal behavior with the push1 dot1ad rewrite enabled.\n\nThis test is triggered by configuring and verifying all Y1564 parameters in the external direction using a y1564 profile with push1 dot1ad rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 dot1ad external phy dot1q priority tagged subinterface",
                "Procedure": "The test involves configuring and verifying the behavior of a y1564 device in the External direction on a phy dot1q priority_tagged subinterface, ensuring all Y1564 parameters are correctly set up. The configuration includes a y1564 profile with push2 dot1ad rewrite enabled. This test is triggered by the configuration specified for testing the Y1564 in External direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 external phy dot1q priority tagged subinterface",
                "Procedure": "The configuration is tested for the External direction on phy dot1q priority_tagged subinterface, specifically targeting the y1564 rewrite push2 dot1q configuration. This test configures and verifies internal y1564 behavior with push2 rewrite.\n\nThis test is triggered by configuring a y1564 profile with push2 rewrite in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 dot1ad external phy dot1ad priority tagged subinterface",
                "Procedure": "The configuration for the y1564 test involves testing the push1 dot1q configuration of y1564 in External direction on phy dot1ad priority_tagged subinterface, configuring and verifying internal y1564 behavior with push1 dot1ad rewrite. All Y1564 parameters are configured and verified in the external direction, using a profile with push1 dot1ad rewrite.\n\nThis test is triggered by configuration: y1564 profile with push1 dot1ad rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 dot1ad external phy dot1ad priority tagged subinterface",
                "Procedure": "The configuration to be tested involves setting up the y1564 profile with a push2 dot1ad rewrite, which configures and verifies internal behavior on the device, specifically in the External direction on phy dot1ad priority_tagged subinterface.\n\nThis test is triggered by configuring a y1564 profile with push2 dot1ad rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 external phy dot1ad priority tagged subinterface",
                "Procedure": "The configuration of the y1564 on the phy interface is tested in the External direction for dot1ad priority_tagged subinterface, using the push2 dot1q configuration.\n\nThis test configures and verifies internal y1564 behavior with push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal packet size 1024 bundle dot1q doubleinner any l2vpn admin reload",
                "Procedure": "The configuration of y1564 in the Internal direction on a Bundle dot1q doubleinner-any L2VPN interface is tested. This test is triggered by the configuration of y1564 profile settings, including configuring and verifying all Y1564 parameters in internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal packet size 1024 bundle dot1q doubleinner any l2vpn rpfo trigger",
                "Procedure": "The configuration for y1564 in the Internal direction on a Bundle dot1q doubleinner_any L2VPN interface is tested by verifying that it can configure and function correctly. This test configures and verifies internal y1564 behavior - Configure and verify all Y1564 parameters in internal direction. Configuration: y1564 profile.\n\nThis test is triggered by testing the configuration of y1564 in Internal direction on Bundle dot1q doubleinner_any l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal packet size 1024 bundle dot1q doubleinner any l2vpn restart rp",
                "Procedure": "The configuration of y1564 in the Internal direction on a Bundle dot1q doubleinner_any L2VPN interface is tested by testing the configuration. This test configures and verifies internal y1564 behavior, specifically configuring all Y1564 parameters in the internal direction. The configuration involves setting up a y1564 profile. \n\nThis test is triggered by the need to test the configuration of y1564 in Internal direction on Bundle dot1q doubleinner_any l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 internal bundle dot1q l2vpn subinterface",
                "Procedure": "Test the rewrite push2 configuration of y1564 in Internal direction on Bundle dot1q l2vpn interface, where the test configures and verifies internal y1564 behavior with push2 rewrite by configuring all Y1564 parameters in internal direction. This test is triggered by a y1564 profile with push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal bundle dot1q l2vpn subinterface",
                "Procedure": "The dot1ad push1 configuration of the Y1564 is tested in the Internal direction on a Bundle dot1q L2VPN interface, where it is configured and verified to function correctly as expected.\n\nThis test configures and verifies internal Y1564 behavior by triggering an event that causes all Y1564 parameters in the internal direction to be configured with a y1564 profile that includes dot1ad push1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push2 internal bundle dot1q l2vpn subinterface",
                "Procedure": "The configuration of the y1564 in Internal direction on Bundle dot1q l2vpn interface needs to be tested. It configures and verifies the internal y1564 behavior with dot1ad push2 rewrite. This test is triggered by configuring a y1564 profile with dot1ad push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 internal bundle dot1ad l2vpn subinterface",
                "Procedure": "The configuration involves testing the internal direction of the y1564 device on a Bundle dot1ad l2vpn interface, where the test configures and verifies internal y1564 behavior with push2 rewrite enabled. \n\nThis test is triggered by configuring a y1564 profile with push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal bundle dot1ad l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on the Bundle dot1ad l2vpn interface is tested in Internal direction with a dot1ad push1 configuration. The test configures and verifies the internal behavior of the y1564 with a dot1ad push1 rewrite. All Y1564 parameters are configured and verified in the internal direction, using a y1564 profile with a dot1ad push1 rewrite.\n\nThis test is triggered by configuring a y1564 profile with a dot1ad push1 rewrite on the Bundle dot1ad l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 internal bundle dot1q priority tagged l2vpn subinterface",
                "Procedure": "The configuration for testing the rewrite push2 settings of device y1564 is executed on an interface configured as Bundle dot1q_priority_tagged within the l2vpn network. This test is triggered by configuring a y1564 profile with dot1q_priority_tagged rewrite settings. Configuration includes setting and verifying all Y1564 parameters in internal direction, ensuring proper operation with push2 rewrite enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 internal bundle dot1ad priority tagged l2vpn subinterface",
                "Procedure": "To test the configuration of y1564 in Internal direction on a Bundle dot1ad_priority_tagged l2vpn interface, configure and verify all Y1564 parameters. This includes setting up a y1564 profile with dot1ad_priority_tagged rewrite.\n\nThis test is triggered by the configuration of a y1564 profile with dot1ad_priority_tagged rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal bundle dot1q priority tagged l2vpn subinterface",
                "Procedure": "The configuration tests the dot1ad push1 settings for y1564 on a Bundle dot1q_priority_tagged l2vpn interface, specifically in the Internal direction. This test configures and verifies internal y1564 behavior with dot1ad push1 rewriting. The test includes configuring and verifying all Y1564 parameters in the internal direction, using a configuration that involves a y1564 profile with a dot1q_priority_tagged rewrite. This test is triggered by the configuration of a y1564 profile with a dot1q_priority_tagged rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push2 internal bundle dot1ad priority tagged l2vpn subinterface",
                "Procedure": "The configuration to be tested involves configuring and verifying the internal behavior of y1564 with a specific rewrite rule for dot1ad priority-tagged packets on an L2VPN interface.\n\nThis test is triggered by a y1564 profile configured with a dot1ad push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal bundle dot1ad priority tagged l2vpn subinterface",
                "Procedure": "The configuration of the y1564 in Internal direction on the Bundle dot1ad_priority_tagged l2vpn interface is tested for a rewrite dot1ad push1. This test is triggered by configuring and verifying all Y1564 parameters in internal direction, using a y1564 profile with dot1ad_priority_tagged rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push2 internal bundle dot1q priority tagged l2vpn subinterface",
                "Procedure": "The configuration for the dot1ad push2 rewrite of the y1564 on an Internal direction Bundle l2vpn interface needs to be tested. This test configures and verifies all Y1564 parameters in internal direction, including the specific settings related to a y1564 profile with a dot1q_priority_tagged rewrite configuration.\n\nThis test is triggered by the configuration of a y1564 profile with dot1q_priority_tagged rewrite on an Internal direction Bundle l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal bundle dot1q doubleinner range l2vpn subinterface",
                "Procedure": "The configuration of the y1564 push1 rewrite is tested on the l2vpn interface in the Internal direction, specifically with the Bundle dot1q_doubleinner_range interface. All Y1564 parameters are configured and verified to function internally when this specific rewrite is applied.\n\nThis test is triggered by configuring a Y1564 profile with the dot1q_doubleinner_range rewrite on an L2VPN interface in the internal direction with Bundle dot1ad push1 configuration of y1564.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal bundle dot1ad doubleinner range l2vpn subinterface",
                "Procedure": "The test configures and verifies the internal behavior of the Y1564 protocol by setting up a specific configuration on an L2VPN interface, including a y1564 profile that rewrites the dot1ad double inner range.\n\nThis test is triggered by configuring a y1564 profile with a dot1ad_doubleinner_range rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal phy dot1q l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on a phy dot1q l2vpn interface is tested in Internal direction to check the functionality of the dot1ad push1 mode. The test configures and verifies all Y1564 parameters, including its internal behavior, to ensure it's working correctly with dot1ad push1 rewrite.\n\nThis test is triggered by configuring a y1564 profile with dot1ad push1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 internal phy dot1q l2vpn subinterface",
                "Procedure": "The configuration of the y1564 in the Internal direction on the phy dot1q l2vpn interface is tested, specifically for a push2 rewrite scenario. This test configures and verifies all Y1564 parameters in the internal direction using a y1564 profile with push2 rewrite enabled.\n\nThis test is triggered by configuring a y1564 profile with push2 rewrite to simulate an internal direction on a phy dot1q l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push2 internal phy dot1q l2vpn subinterface",
                "Procedure": "The configuration of the phy-dot1q l2vpn interface is set up to test the dot1ad push2 settings for y1564 in Internal direction, verifying the internal behavior of y1564 with dot1ad push2 rewrite. This test configures and verifies all Y1564 parameters in internal direction by setting up a y1564 profile that includes dot1ad push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal phy 1ad1q l2vpn subinterface",
                "Procedure": "The configuration to be tested is for the y1564 on a phy interface, specifically the dot1ad_push1 configuration in an Internal direction on phy 1ad1q l2vpn interface. This test configures and verifies internal y1564 behavior with dot1ad_push1 rewrite.\n\nThis test is triggered by the need to verify that all Y1564 parameters are correctly configured in the internal direction, using a y1564 profile with a dot1ad1q rewrite configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal phy dot1ad l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on the phy dot1ad l2vpn interface is tested for a specific scenario where the traffic is directed internally and is rewritten using the dot1ad push1 method.\n\nThis test is triggered by configuring a y1564 profile that uses the dot1ad push1 rewrite rule.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 internal phy dot1ad l2vpn subinterface",
                "Procedure": "The configuration for the y1564 push2 feature on phy dot1ad l2vpn interface is tested by verifying its setup and performance in internal direction.\n\nThis test is triggered by configuring a y1564 profile with push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push2 internal phy dot1ad l2vpn subinterface",
                "Procedure": "The configuration for the y1564 push2 feature on phy dot1ad l2vpn interfaces in Internal direction is being tested to ensure correct behavior when rewriting dot1ad packets. The test configures and verifies all Y1564 parameters, including a specific profile that enables dot1ad push2 rewrite. This test is triggered by configuring a y1564 profile with the setting for dot1ad push2 rewrite enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal phy dot1q priority tagged l2vpn subinterface",
                "Procedure": "The configuration for testing the rewrite of dot1ad push1 packets on a y1564 interface in an Internal direction involves configuring the phy dot1q_priority_tagged l2vpn interface to test the internal behavior of the y1564. This test is triggered by a specific scenario where all Y1564 parameters are configured and verified, including a profile that utilizes dot1ad push1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 internal phy dot1q priority tagged l2vpn subinterface",
                "Procedure": "To test the configuration of y1564 in Internal direction on phy dot1q_priority_tagged l2vpn interface, configure and verify all Y1564 parameters. The configuration includes a y1564 profile with push2 rewrite. This test is triggered by the configuration of a y1564 profile with push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push2 internal phy dot1q priority tagged l2vpn subinterface",
                "Procedure": "The configuration for the y1564 rewrite in Internal direction on a phy dot1q_priority_tagged l2vpn interface needs to be tested and verified, including setting up and checking all Y1564 parameters in this specific setup.  This test is triggered by configuring a y1564 profile with the dot1ad push2 rewrite feature enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal phy dot1ad priority tagged l2vpn subinterface",
                "Procedure": "The configuration of the y1564 in Internal direction on phy dot1q_priority_tagged l2vpn interface is tested to ensure correct operation. This involves configuring and verifying the internal y1564 behavior with dot1ad push1 rewrite enabled, including all necessary parameters.\n\nThis test is triggered by a Y1564 profile with dot1ad push1 rewrite configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push2 internal phy dot1ad priority tagged l2vpn subinterface",
                "Procedure": "The configuration for testing the push2 rewrite of y1564 is triggered by configuring a y1564 profile with push2 rewrite on an l2vpn interface, specifically the phy dot1ad_priority_tagged interface in the Internal direction.\n\nThis test is triggered by configuring a Y1564 profile with push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push2 internal phy dot1ad priority tagged l2vpn subinterface",
                "Procedure": "The configuration of the y1564 protocol on the l2vpn interface, specifically in the Internal direction for phy dot1ad_priority_tagged connections, is to be tested. To achieve this, all Y1564 parameters must be configured and verified within the internal direction. This involves configuring a y1564 profile with a specific feature called dot1ad push2 rewrite.\n\nThis test is triggered by configuration of a y1564 profile with dot1ad push2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite dot1ad push1 internal phy qinq l2vpn subinterface",
                "Procedure": "The configuration for the y1564 in internal direction on phy qinq l2vpn interface includes a y1564 profile with dot1ad push1 rewrite. This test is triggered by configuring and verifying all Y1564 parameters in the internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "Y1731_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Upmep scale dmm profile scale phy 2k vpws",
                "Procedure": "Phy sub DMM scale sessions are verified using 2K UP meps and CCM as 1s in VPWS environments. To perform this test, the following steps are followed: configure an ethernet SLA DMM profile globally, apply the ethernet SLA configuration under each interface, verify that ethernet CFM local MEPs show verbose counters for DMM sent/received traffic, check the details of the ethernet SLA profile, verify that SLA statistics information is displayed correctly using the \"show ethernet sla statistics\" CLI command, and then monitor the network traffic. The test also involves verifying that all configurations are properly removed when an SLA configuration is unconfigured globally.\n\nThis test is triggered by verifying that Ethernet SLA DMM along with scaling and interface level SLA configs are correctly configured in the system.",
                "Pass/Fail Criteria": "Y1731 scale global config verification is performed.\nDmm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm profile scale phy 2k vpws",
                "Procedure": "To verify the phy sub-DMM scale sessions, perform the following steps. First, configure an Ethernet SLA SLM profile globally, then apply the Ethernet SLA configuration under each interface. Next, verify that the local MEPs are functioning correctly by checking the DMM sent and received counters in verbose mode. After that, check the details of the Ethernet SLA profile and ensure that the statistics information is displayed accurately when using the 'show ethernet sla statistics' CLI command. Finally, generate traffic to test the configuration and then unconfigure the Ethernet SLA globally.\n\nThis test is triggered by verifying that phy sub-DMM scale sessions work correctly with 2K UP MEPs and CCM as 1s - VPWS.",
                "Pass/Fail Criteria": "Y1731 scale global config verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale dmm slm profile scale phy 2k vpws",
                "Procedure": "To verify that the phy sub-DMM scale sessions work as expected, configure Ethernet SLA DMM and SLM profile globally, apply the configuration under each interface, and verify various counters and statistics. The verification process includes checking the DMM sent/received counters in verbose mode, verifying the Ethernet SLA profile detail, ensuring correct display of statistics under the show command, and confirming that traffic flows as expected. This test is triggered by configuring Ethernet SLA DMM along with scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Y1731 scale global config verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep scale dmm slm phy vpws trigger",
                "Procedure": "The Y1731 DMM and SLM test cases use 1500 Physical sub UP MEPs with a VPWS trigger and timer set to 10 seconds. The test verifies service level agreements (SLAs) on various interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q. It checks the performance of SLA operations using commands such as \"show ethernet sla operations\" and \"show ethernet statistics interface\", in both configuration and on-demand modes. The test also verifies these parameters while traffic is flowing, and repeats all steps for on-demand mode. This test is triggered by configuring CFM (Connectivity Fault Management) and Ethernet SLA delay measurement.\n\nThe rewritten trigger sentence is: This test is triggered by configuring Connectivity Fault Management (CFM) and Ethernet SLA delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_rollback_sla_config\" and \"unconfig_rollback_cfm\" and \"removeaddintf\" and \"shut_unshut_interface\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep scale dmm slm phy vpws",
                "Procedure": "The test verifies that phy sub-DMM SLM scale sessions function properly using 1K UP MEPs and CCM as 10s - VPWS. This is done by configuring an ethernet SLA DMM profile globally, applying the configuration under each interface, verifying the ethernet CFM local MEP counters for sent/received data, checking the ethernet SLA profile details, ensuring that statistics are displayed correctly in the show ethernet SLA statistics CLI command, verifying traffic flow, and finally unconfiguring the ethernet SLA globally. Configuration involves setting up an ethernet SLA DMM along with scaling and interface level sla configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep scale dmm slm phy scale vpws unconfig config l2vpn",
                "Procedure": "The test verifies Upmep cfm ethernet sla DMM SLM over l2vpn vpws physical - config unconfig l2vpn. This interface supports a range of physical and sub-interfaces, including main interfaces, dot1q, dot1ad, q-in-q, and combinations of these protocols. The test checks various operations and statistics related to Ethernet SLA, including show ethernet sla operations and detail commands, as well as display of Ethernet statistics for the interface. These operations are verified with both configuration and on-demand modes enabled, and repeated while traffic is flowing. All steps are then repeated in on-demand mode.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep scale dmm slm phy vpws basic testcases",
                "Procedure": "To verify that a thousand physical interfaces are working correctly on a Mep Device Management System Service Layer Management sessions, follow these steps. The first step is to configure an ethernet sla profile globally, which can then be applied under each interface. Next, the trigger is activated by the interface flap or removal/addition of an interface and line card reload within 10 seconds. After that, verify that the ethernet cfm local meps verbose command displays DMM sent/received counters correctly. Additionally, check the details of the ethernet sla profile and ensure that the ethernet sla statistics information is displayed accurately in the show ethernet sla statistics CLI command output. Finally, check for any traffic issues before unconfiguring the ethernet sla globally.\n\nThis test is triggered by the interface flap or removal/addition of an interface and line card reload within 10 seconds.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntestcase: \"lcreload\" and \"flapinterface\" and \"activerpreload\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep scale dmm slm phy vpws rpfo",
                "Procedure": "The test verifies that cfm upmep ethernet sla DMM slm is functioning correctly over l2vpn vpws with RPFO - 10s. This test is triggered by a configuration where CFM and Ethernet SLA delay measurements are used to monitor the network's performance in both configuration and ondemand modes. \n\nRewritten trigger sentence:\nThis test is triggered by a configuration that includes CFM (Connectivity Fault Management) and Ethernet SLA (Service Level Agreements) delay measurements for monitoring network performance in both configuration and on-demand modes.",
                "Pass/Fail Criteria": "Ha verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s downmep scale dmm slm phy vpws",
                "Procedure": "Ethernet SLA configurations are verified by performing several steps. First, the global configuration is set up for the Ethernet SLA DMM profile. Then, this configuration is applied to the interfaces. The verification process includes checking the Ethernet CFM local MEPs verbose display, which shows the DMM sent and received counters, as well as verifying the detail of the Ethernet SLA profile and ensuring that the statistics information is correctly displayed under the \"show ethernet sla statistics\" CLI command. Additionally, traffic verification is performed. Lastly, all Ethernet SLA configurations are unconfigured globally.\n\nThis test is triggered by a configuration change involving Ethernet SLA DMM along with scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s downmep scale dmm slm phy vpws trigger",
                "Procedure": "This test verifies a specific scenario involving 1 kilometer downmeasured CFP Ethernet SLA DMM SLM xconnect access circuits to pseudowires. It checks whether service level agreements (SLAs) are met in various interface configurations and operational modes, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q. This test is triggered by a trigger of 10 seconds. In both configuration and on-demand mode, the test verifies that SLA operations, details, statistics, and all associated configurations are functioning correctly with traffic flowing through the system. The same checks are repeated for the on-demand mode, where CFM (Connectivity Fault Management) and Ethernet SLA delay measurement configurations are in place.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_rollback_sla_config\" and \"unconfig_rollback_cfm\" and \"removeaddintf\" and \"shut_unshut_interface\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s downmep scale dmm slm phy vpws basic testcases",
                "Procedure": "Configuring the Ethernet SLA environment involves several steps. First, an Ethernet SLA profile is configured globally on the device. Next, this configuration is applied under each interface. Then, the trigger for these actions is initiated. After that, two verifications are performed: one checks if DMM (Data Map Message) sessions are established with 1k phy down MEPs and shows that the interface flap and remove/add interface and LC reload operations are executed within a 10-second timeframe. The second verification involves checking the Ethernet CFM Local MEPs verbose mode to ensure that DMM sent/received counters are populated correctly. Further verifications include displaying detailed Ethernet SLA profile information, verifying correct display of Ethernet SLA statistics under show ethernet sla statistics CLI command, and observing normal traffic flow during these processes. Finally, the global Ethernet SLA configuration is unconfigured.\n\nThis test is triggered by activating the configured Ethernet SLA profile on each interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntestcase: \"lcreload\" and \"flapinterface\" and \"activerpreload\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep bundle scale dmm slm phy vpws",
                "Procedure": "Phy sub-DMM scale sessions are verified with a bundle of 1K MEPs and CCM as 10 seconds - VPWS. The configuration involves setting up an Ethernet SLA DMM profile globally, applying the Ethernet SLA configuration under interfaces, verifying Ethernet CFM local MEPs verbose shows DMM sent/received counters, checking Ethernet SLA profile details, ensuring correct display of Ethernet SLA statistics information under the show Ethernet SLA statistics CLI command, and verifying traffic. This test is triggered by configuring an Ethernet SLA DMM along with scaling and interface-level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep bundle scale dmm slm remove add bundle vpws",
                "Procedure": "To verify the operation of a DMM SLM scale session, ensure that a bundle is created with 1K UP meps (Maintenance End Points) and CCM (Client Control Model). The following configuration steps must be taken: configure an Ethernet SLA (Service Level Agreement) profile globally, apply the configuration under each interface, verify that local MEPs are reporting DMM sent/received counters in verbose mode, check the detail of the Ethernet SLA profile, verify that statistics information is displayed correctly using the show ethernet sla statistics command, and ensure that traffic is passing through. This test is triggered by configuring an Ethernet SLA DMM along with scaling and interface-level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep bundle scale dmm slm flap members bundle vpws",
                "Procedure": "To verify that the Dynamic Monitoring Management (DMM) Scale Limiting Mechanism (SLM) scale sessions work as expected, we configure an Ethernet SLA profile globally, apply it under each interface, and then verify several settings and conditions. We check that the Ethernet Connectivity Fault Management (CFM) local Multi-Point Echo (MEP) display shows sent and received counters from DMM, that the Ethernet SLA profile details are correct, and that statistics are properly displayed in the show Ethernet SLA statistics CLI command output. We also send traffic to verify the function works as intended, then remove the global configuration.\n\nThis test is triggered by the presence of an Ethernet SLA DMM with scaling and interface-level sla configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep bundle scale dmm slm unconfig config bundle vpws",
                "Procedure": "To verify the DMM SLM scale sessions, a bundle of 1K UP meps and CCM as 1s is used in VPWS configuration, both unconfigured and configured. This test is triggered by the need to confirm that the Ethernet SLA DMM profile can be configured globally and applied under interfaces, while also verifying the local MEPs' received and sent counters via verbose mode, checking the profile detail, ensuring correct statistics are displayed under the CLI command for statistics, and testing traffic with unconfiguration of the global SLA. Configuration: Ethernet sla DMM along with scaling and interface level sla configurations are used.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s downmep bundle scale dmm slm phy vpws",
                "Procedure": "The configuration involves verifying the performance of phy sub-DMM scale sessions with a 1K bundle using MEPs and CCM as 10s - VPWS. This is done by configuring an Ethernet SLA DMM profile globally, applying it under each interface, checking that Ethernet CFM local MEPs show DMM sent/received counters in verbose mode, verifying the Ethernet SLA profile details, confirming that SLA statistics are displayed correctly on the CLI, and then verifying traffic flow. Finally, any configured SLA settings are unconfigured globally. This test is triggered by a configuration of Ethernet SLA DMM along with scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s downmep bundle scale dmm slm remove add bundle vpws",
                "Procedure": "To verify the DMM SLM scale sessions, you must follow these steps: configure an Ethernet SLA profile globally, apply the Ethernet SLA configuration under each interface, verify that the Ethernet CFM local MEPS is set to show DMM sent/received counters in verbose mode, and check the Ethernet SLA profile details. Additionally, ensure that the Ethernet SLA statistics information is displayed correctly using the 'show ethernet sla statistics' command. You should also verify traffic flow and then unconfigure the Ethernet SLA globally.\n\nThis test is triggered by configuring an Ethernet SLA DMM along with scaling and interface-level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s downmep bundle scale dmm slm flap members bundle 1500 vpws",
                "Procedure": "To verify the DMM SLM scale sessions, perform the following steps: Configure an Ethernet SLA DMM profile globally, apply the Ethernet SLA configuration under each interface, and then check that the Ethernet CFM local MEPs are showing the DMM sent and received counters. Additionally, verify the Ethernet SLA profile details and make sure the statistics information is displayed correctly using the show Ethernet SLA statistics CLI command. Next, generate traffic to test the setup, and finally, unconfigure the Ethernet SLA globally.\n\nThis test is triggered by verifying that an Ethernet SLA DMM along with scaling and interface level SLA configurations are properly set up.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s downmep bundle scale dmm slm unconfig config bundle 1500 vpws",
                "Procedure": "To verify that the DMM SLM scale sessions are working as expected, a series of tests must be performed using bundle 1K down meps and CCM in VPWS Config Unconfig. This includes configuring the ethernet SLA DMM profile globally, applying the configuration under the interfaces, verifying the ethernet CFM local MEPs with verbose mode to ensure counters are accurate, checking the ethernet SLA profile detail, verifying that statistics information is displayed correctly under the show ethernet SLA statistics CLI, and ensuring that traffic flows as expected. After completing these tests, unconfigure the ethernet SLA globally.\n\nThis test is triggered by: Ethernet sla DMM along with scaling and interface level sla configs",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep scale dmm slm phy vpws",
                "Procedure": "To verify the functionality of the phy sub-DMM SLM scale sessions, we perform several steps to ensure that the 1K UP meps and CCM are operating within a 10ms - VPWS timeframe. We start by configuring the ethernet SLA DMM profile globally, then apply the configuration under the interfaces. Next, we verify the ethernet CFM local MEPs with verbose settings to confirm the DMM sent/received counters. We also check the ethernet SLA profile details and statistics to ensure accurate information is displayed under the show ethernet SLA statistics CLI command. Additionally, traffic verification is performed, followed by unconfiguring the ethernet SLA globally. This test is triggered by a configuration that includes Ethernet sla DMM along with scaling and interface level sla configs.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep scale dmm slm phy vpws trigger",
                "Procedure": "The Y1731 DMM and SLM test cases utilize 1500 Physical Sub-UNI MEPs triggered by a VPWS setup with a 10ms timer. This test verifies SLA across various interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, using commands such as \"show ethernet sla operations,\" \"show ethernet sla operations detail,\" and \"show ethernet statistics interface.\" These commands are run in both configuration and on-demand modes, with traffic flowing through the network. The test is repeated for on-demand mode to ensure that all SLA measurements are accurate. This test is triggered by a set-up of VPWS with a timer of 10 milliseconds.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_rollback_sla_config\" and \"unconfig_rollback_cfm\" and \"removeaddintf\" and \"shut_unshut_interface\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep scale dmm slm phy scale vpws unconfig config l2vpn",
                "Procedure": "This test verifies the Ethernet SLM (Service Level Measurement) over l2vpn vpws physical configuration by checking the following scenarios:\n\nThe test verified SLA as below:\n- Interface types physical main interface, dot1q, dot1ad, q-in-q, dot1ad-dot1q\n- Showing ethernet sla operations and operations detail\n- Showing ethernet statistics interface\n- All of the above with both configuration and ondemand mode\n- Verifying all of the above with traffic flowing\nAnd repeating all of these steps for ondemand mode.\nThis test is triggered by configuring CFM (Connectivity Fault Management) and Ethernet SLM delay measurement.",
                "Pass/Fail Criteria": "L2vpn xconnect summary verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep scale dmm slm phy vpws basic trigger",
                "Procedure": "To verify that a 1 kilobyte (k) physical media access control (PHY) up message emission periodic (MMEP) Dynamic Management Module (DMM) Service Level Measurement (SLM) session is triggered by an interface flap, lcreload, or activerpreload-10ms event, the following steps are performed. First, configure an Ethernet Switching and Routing Link (SRL) profile globally. Then, apply this configuration under each interface. Next, perform the trigger that causes the DMM to send and receive traffic on the Ethernet network. After triggering the session, verify that the DMM sent/received counters display in the \"show ethernet cfm local meps verbose\" command output. Also verify that the Ethernet SLM profile detail is correctly displayed. Additionally, check that the statistics information for the Ethernet SLM is shown correctly under the \"show ethernet sla statistics\" CLI command. Then, send traffic over the interface to ensure it is being measured and reported correctly by the DMM. Finally, unconfigure the Ethernet SLM globally.\n\nThis test is triggered by an interface flap, lcreload or activerpreload-10ms event.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntestcase: \"lcreload\" and \"flapinterface\" and \"activerpreload\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep scale dmm slm phy vpws process trigger",
                "Procedure": "This paragraph verifies that a test case for verifying upmep vpwscfm ethernet sla DMM SLM over l2vpn xconnect ac to PW scenario is working correctly. The test checks SLA performance with various interface types, including physical main interfaces and VLANs of different types, as well as the show ethernet sla operations and detail commands. It also examines Ethernet statistics on each interface in both configuration and on-demand modes. All these steps are repeated when traffic is flowing through the network.\n\nThis test is triggered by a 10-second delay.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"Y1731ApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep scale dmm slm phy vpws rpfo",
                "Procedure": "The test verifies that Ethernet SLA DMM and SLM functions correctly over L2VPN VPWS with RPFO, taking approximately 10 seconds. It confirms that SLA is working as follows: it supports various interface types, including physical main interfaces and QinQ (dot1q and dot1ad) configurations, and displays operational statistics in both configuration and on-demand modes. The test also checks the display of Ethernet SLA operations and detailed information, as well as Ethernet statistics for each interface, with traffic flowing. This test is triggered by configuration: CFM, Ethernet SLA delay measurement.",
                "Pass/Fail Criteria": "Ha verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms downmep scale dmm slm phy vpws",
                "Procedure": "When verifying phy sub-DMM scale sessions, a series of steps are followed to ensure that all configurations are accurate. This involves configuring the Ethernet SLA DMM profile globally, applying the configuration under specific interfaces, and verifying that local MEPS counters show DMM sent/received data with a 10ms interval for VPWS. Additionally, it's necessary to verify Ethernet SLA profile details, display statistics under the \"show ethernet sla statistics\" CLI command, and confirm that traffic is flowing correctly.\n\nThis test is triggered by verifying that both phy sub-DMM scale sessions and CCM are set to 1K down MEPS with a 10ms interval for VPWS.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms downmep scale dmm slm phy vpws trigger",
                "Procedure": "This test verifies a specific scenario where Ethernet SLA (Service Level Agreement) is measured between PW (Pseudo Wire) connections over various interface types in both configuration and on-demand modes. The test checks for physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q configurations, using the \"show ethernet sla operations\" and \"show ethernet statistics interface\" commands to verify SLA measurements. Measurements are taken with a delay of 10ms. This test is triggered by traffic flow over the PW connections.\n\nTrigger sentence: This test is triggered by traffic flowing over the pseudo wire connections.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_rollback_sla_config\" and \"unconfig_rollback_cfm\" and \"removeaddintf\" and \"shut_unshut_interface\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms downmep scale dmm slm phy vpws trigger testcases",
                "Procedure": "To verify that 1,000 phy down Mep DMM sessions work correctly on an interface flap, follow these steps. First, configure an Ethernet SLA profile globally. Next, apply the Ethernet SLA configuration under each interface. Then, perform the trigger to initiate the test. After the test is initiated, verify that the Ethernet CFM local MEPs verbose shows the correct DMM sent and received counters. Also, check the Ethernet SLA profile details and ensure that the statistics information displayed under show Ethernet SLA statistics CLI are accurate. Additionally, verify that traffic flows correctly through the interface. Finally, unconfigure the Ethernet SLA globally.\n\nThis test is triggered by the interface flap event, including removing or adding an interface and a Line Card reload.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntestcase: \"lcreload\" and \"flapinterface\" and \"activerpreload\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep bundle scale dmm slm phy vpws",
                "Procedure": "Phy sub DMM scale sessions are verified with a bundle of 1K meps and CCM set to 10ms for VPWS configurations. To test this, the following steps are taken: configure an ethernet SLA DMM profile globally, apply the configuration under each interface, verify that local MEPs show DMM sent/received counters in verbose mode, check the details of the ethernet SLA profile, confirm that statistics information is displayed correctly on the 'show ethernet sla statistics' CLI command. Then, traffic verification is performed and finally, the global ethernet SLA configuration is unconfigured.\n\nThis test is triggered by an Ethernet SLA DMM configuration with scaling and interface level SLA configurations in place.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep bundle scale dmm slm remove add bundle vpws",
                "Procedure": "To verify the DMM SLM scale sessions, a bundle of 1K UP meps and CCM is used to simulate 10ms - VPWS traffic. This test is triggered by configuring an Ethernet SLA DMM profile globally, applying it under each interface, verifying that local MEPs show sent and received counters, checking the SLA profile detail, ensuring statistics are displayed correctly in the CLI, simulating traffic, and then unconfiguring the global SLA configuration, which also includes scaling and interface-level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep bundle scale dmm slm flap members bundle vpws",
                "Procedure": "The test verifies that DMM SLM scale sessions work as expected when using a bundle of 1,000 UP meps and CCM flap members with a delay of 10 milliseconds in a VPWS environment. This is done by performing the following steps: configuring an ethernet SLA profile globally, applying this configuration to individual interfaces, verifying that DMM sent/received counters are displayed in verbose mode when viewing local MEPs, checking the details of the ethernet SLA profile, ensuring that statistics are displayed correctly under the show ethernet SLA statistics CLI command, verifying traffic flow, and finally unconfiguring the ethernet SLA globally. This test is triggered by a configuration involving Ethernet SLA DMM with scaling and interface-level SLA settings enabled.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms upmep bundle scale dmm slm unconfig config bundle vpws",
                "Procedure": "To verify that the DMM SLM scale sessions work correctly, the system is configured to use a 1K bundle UP MEPs with CCM as a 10ms VPWS configuration. This test is triggered by an initial configuration of Ethernet SLA with DMM profiles applied globally and under specific interfaces, followed by verifying various Ethernet CFM and SLA metrics, then generating traffic, and finally unconfiguring the Ethernet SLA globally. The system also has Ethernet SLA DMM configurations set up at multiple levels, including scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "1s downmep bundle scale dmm slm phy vpws",
                "Procedure": "To verify the phy sub-DMM scale sessions, a bundle of 1K meps and CCM as 1s - VPWS are used. The configuration includes setting up an Ethernet SLA DMM profile globally, applying the Ethernet SLA configuration under the interfaces, verifying Ethernet CFM local MEPs with verbose mode showing DMM sent/received counters, checking the Ethernet SLA profile detail, ensuring that the Ethernet SLA statistics display correctly under the show command, and then verifying traffic. This test is triggered by configuring an Ethernet SLA DMM along with scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "1s downmep bundle scale dmm slm remove add bundle vpws",
                "Procedure": "To verify the DMM SLM scale sessions with downmep bundle 1K meps and CCM as 1s - VPWS, follow these steps. The configuration involves setting up an Ethernet SLA DMM profile globally, applying the Ethernet SLA configuration under interfaces, verifying local MEP counters are displayed in verbose mode, checking the Ethernet SLA profile details, ensuring statistics information is shown correctly on the show Ethernet SLA statistics CLI command, and monitoring traffic. This test is triggered by a configuration of Ethernet sla DMM along with scaling and interface level sla configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "1s downmep bundle scale dmm slm flap members bundle 1500 vpws",
                "Procedure": "To verify that DMM SLM scale sessions function correctly, you need to configure Ethernet SLA DMM profiles globally, apply the configuration under each interface, and then check various counters and statistics using verbose commands. This test is triggered by running a 1K bundle with Meps (Multi-Endpoint Polling) and CCM (Continuous Composite Measurement) as ones - VPWS (Virtual Private Wire Service).",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "1s downmep bundle scale dmm slm unconfig config bundle 1500 vpws",
                "Procedure": "To verify the DMM SLM scale sessions, configure the ethernet SLA DMM profile globally, apply the configuration to each interface, and then verify that the counters for DMM sent and received packets are displayed correctly in the verbose output of ethernet CFM local MEPs. Additionally, check the detailed view of the ethernet SLA profile, ensure that statistics are properly shown when running the 'show ethernet sla statistics' command, and confirm that traffic flows as expected. This test is triggered by a configuration change involving Ethernet SLA DMM alongside scaling and interface-level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "100ms hwoffload scale down mep dmm slm phy sub",
                "Procedure": "The test verifies the behavior of PHY sub-DMM and SLM when scaling sessions with 2K down MEPs and CCM with a 100ms HW-Offload timer. The test configuration includes Ethernet SLA DMM, scaling, and interface-level SLA configurations. The steps performed are as follows: Configure Ethernet SLA DMM globally; apply the Ethernet SLA configuration under each interface; verify that Ethernet CFM local MEPs show verbose details of DMM sent and received counters; verify Ethernet SLA profile details; check that Ethernet SLA statistics information is displayed correctly using the \"show ethernet sla statistics\" CLI command. Traffic verification is also performed. Finally, unconfigure Ethernet SLA globally.\n\nThis test is triggered by enabling the configuration for Ethernet SLA DMM along with scaling and interface-level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "100ms hwoffload scale down mep dmm slm phy sub ha testcases",
                "Procedure": "To verify that the phy sub DMM and SLM can scale sessions with 2K down meps and CCM as a 100ms HW-Offload timer, we perform the following steps. We configure ethernet sla dmm profiles globally, apply the configuration under the interfaces, and verify that ethernet cfm local meps verbose shows DMM sent/received counters are being tracked. We also check the ethernet sla profile detail and ensure that show ethernet sla statistics CLI displays correct information. Additionally, we verify traffic is flowing correctly before unconfiguring ethernet sla globally. This test is triggered by a configuration of Ethernet SLA DMM along with scaling and interface level SLA configs.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lcreload\" and \"router_reload\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nCfm local meps detail verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10ms hwoffload scale down mep dmm slm phy sub",
                "Procedure": "When verifying the hardware offload capabilities of a device, this test checks that physical sub-layer (PHY) functions scale sessions properly in response to a 10ms timer, which is typical for hardware-offloaded events. The test involves configuring an Ethernet Service Level Monitoring (SLM) profile globally and applying it under each interface. It then verifies that the counters for DMM-sent/received packets are displayed correctly when running `ethernet cfm local meps verbose`, checks the details of the configured SLM profile, ensures statistics from the `show ethernet sla statistics` command display accurately, and finally confirms normal traffic behavior. This test is triggered by a configuration that includes an Ethernet SLM with DMM along with scaling and interface-level configurations.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "100ms hwoffload scale down mep dmm slm bundle sub",
                "Procedure": "To verify that bundle sub-DMM and SLM scale sessions work properly with 2K down MEPs and CCM as a 100ms HW-Offload timer, configure the system by performing several steps. Configure an Ethernet SLA DMM profile globally, then apply the Ethernet SLA configuration under each interface. Verify that the Ethernet CFM local MEPS shows verbose counters for DMM sent and received messages. Check the details of the Ethernet SLA profile and verify that its statistics are displayed correctly using the CLI command to show Ethernet SLA statistics. Additionally, verify network traffic. Finally, unconfigure Ethernet SLA globally. This test is triggered by configuration: Ethernet SLA DMM along with scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "100ms hwoffload scale down mep dmm slm bundle sub ha testcases",
                "Procedure": "The test verifies that a bundle of sub-DMM and SLM sessions scales properly when 2K MEPs are brought down, using CCM as the maintenance association and a 100ms HW-Offload timer in HA scenarios. The steps involved include configuring Ethernet SLA DMM globally and under interfaces, verifying local MEP counters for received and sent DMM traffic, displaying detailed profile information, showing statistics correctly, verifying network traffic, and then unconfiguring the global Ethernet SLA setup.\n\nThis test is triggered by configuration: Ethernet SLA DMM along with scaling and interface level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"rpfo\" and \"bundle_members_add_remove\" and \"bundle_members_flap\"",
                "Pass/Fail Criteria": "Ha verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "3 3ms hwoffload scale down mep dmm slm bundle sub",
                "Procedure": "The test for verifying the Bundle sub-DMM & SLM scale sessions involves configuring Ethernet SLA DMM profile globally, applying the configuration under interfaces, and checking the counters on Ethernet CFM local Meps. It also verifies the Ethernet SLA profile detail and statistics information displayed correctly using the show Ethernet SLA statistics CLI command. Additionally, it ensures that traffic is flowing properly. This test is triggered by configuring Ethernet SLA DMM along with scaling and interface level SLA configurations.\n\nThis test is triggered by configuring Ethernet SLA DMM along with scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Cfm summary verification is performed.\nDmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nCfm local meps detail verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep scale on physical sub interface dmm validations",
                "Procedure": "Ethernet SLA is configured globally, then applied to interfaces, followed by triggering the configuration. The verification process involves checking that Ethernet CFM local MEPs are sending and receiving counters correctly in verbose mode, as well as verifying Ethernet SLA profile details and statistics displayed under the show ethernet SLA statistics CLI command. Traffic is also checked before unconfiguring the Ethernet SLA globally.\n\nThis test is triggered by configuring Ethernet SLA DMM along with scaling and interface level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration().get('triggers', ['flapinterface', 'removeaddintf', 'lcreload'])\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep scale on physical sub interface slm validations",
                "Procedure": "Ethernet SLA configuration involves several steps to ensure verification of its performance and functionality. To start, configure the Ethernet SLA profile globally, then apply the configuration under each interface individually. Verify that the Ethernet CFM local MEPs show sent/received counters in verbose mode. Next, verify the details of the Ethernet SLA profile, and confirm that statistics are displayed correctly using the 'show ethernet sla statistics' CLI command. Traffic must also be verified to ensure correct operation. Finally, unconfigure Ethernet SLA globally.\n\nThis test is triggered by configuration: Ethernet sla SLM along with scaling and interface level sla configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration().get('triggers', ['lcreload', 'mpareload', 'mpaflap', 'router_reload'])\"",
                "Pass/Fail Criteria": "Ipv4 interface detail verification is performed.\nL2vpn xconnect summary verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows SLM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep scale on physical sub interface slm and dmm validation",
                "Procedure": "Ethernet configurations are verified for 2k phy up MEPs in SLM and DMM sessions. The steps to achieve this involve configuring an Ethernet SLA SLM profile and a globally applicable DMM, applying the configuration under specific interfaces, and verifying that the Ethernet CFM local MEPs show verbose counters for sent and received SLM messages. This test is triggered by the presence of Ethernet sla SLM along with scaling and interface-level sla configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration().get('triggers2', ['None'])\"",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Up mep scale on bundle sub interface dmm validations",
                "Procedure": "To verify the functionality of the 2k bundle, multiple steps must be performed in sequence. First, configure an Ethernet SLA profile globally, then apply it under each interface. Next, trigger HA to perform a reload. After that, verify the counters for DMM sent and received data by checking the Ethernet CFM local MEPs with verbose mode enabled. Following this, confirm that the Ethernet SLA configuration is applied correctly under each interface's details. Additionally, ensure that the Ethernet SLA statistics are displayed accurately under the show ethernet sla statistics CLI command. Finally, verify traffic flow to guarantee proper operation.\n\nThis test is triggered by a High Availability (HA) reload.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration().get('triggers', ['flapinterface', 'removeaddintf', 'lcreload'])\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nEthernet CFM local meps verbose shows DMM sent/received counters verification is performed.\nEthernet SLA profile detail verification is performed.\nEthernet SLA statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep scale on bundle sub interface slm validations",
                "Procedure": "Ethernet SLA configurations must be performed in the following steps: Configure the Ethernet SLA profile globally, then apply this configuration to each interface individually. Next, verify that local meps display verbose information about SLM sent and received counters under the 'show ethernet cfm local mep detail' command. Additionally, confirm that Ethernet SLA profiles are properly displayed with detailed statistics using 'show ethernet sla statistics'. Finally, verify that traffic is passing correctly and unconfigure the Ethernet SLA globally when finished.\n\nThis test is triggered by enabling Ethernet SLA SLM along with scaling and interface level sla configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration().get('triggers', ['lcreload', 'mpareload', 'mpaflap', 'router_reload'])\"",
                "Pass/Fail Criteria": "Slm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nEthernet CFM local meps verbose shows SLM sent/received counters verification is performed.\nEthernet SLA profile detail verification is performed.\nEthernet SLA statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep scale vpls on physical sub interface dmm validations",
                "Procedure": "To verify two thousand physical up MEPs DMM sessions in a VPLS scenario with HA triggers, the following configuration and procedure are used. Configure an Ethernet SLA DMM profile globally and apply it to interfaces. The test is triggered by this test being invoked when the lc_reload, mpareload, mpaflap, or router_reload HA trigger occurs. Perform the trigger, then verify that Ethernet CFM local MEPs verbose shows DMM sent/received counters are accurate. Verify the Ethernet SLA profile details and statistics information display correctly under show ethernet SLA statistics. Finally, confirm Tgen traffic is being received and unconfigure Ethernet SLA globally.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.zap.get_testcase_configuration().get('triggers', ['lcreload', 'mpareload', 'mpaflap', 'router_reload'])\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nTraffic verification is performed.\nDmm packet increments verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw dmm",
                "Procedure": "This test verifies the functionality of cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario. The SLA verification involves interface types such as physical main interface, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, with commands including show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface, all in both configuration and ondemand mode. Additionally, the test verifies these commands while traffic is flowing, repeating the process for ondemand mode. The testing is configured using CFM, ethernet sla delay measurement.\n\nThis test is triggered by verifying that SLA metrics are accurately measured across different types of interfaces (physical main interface, dot1q, dot1ad, q-in-q, and dot1ad-dot1q) when using commands such as \"show ethernet sla operations\", \"show ethernet sla operations detail\", and \"show ethernet statistics interface\" in both configuration and ondemand modes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw slm",
                "Procedure": "This test verifies cfm ethernet sla SLM over l2vpn xconnect ac to PW scenario. The test involves verifying SLA as follows: it checks interface types such as physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, using commands like \"show ethernet sla operations\", \"show ethernet sla operations detail\", and \"show ethernet statistics interface\". This is done in both configuration and ondemand modes, with all steps repeated while traffic is flowing. The test specifically focuses on configuring CFM and ethernet sla delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw probe send burst once dmm",
                "Procedure": "The test verifies that a cfm ethernet SLA DMM works over L2VPN XConnect to PW scenarios, where a probe is sent as a single burst. It checks various interface types, including physical main interfaces and dot1q and dot1ad VLANs, and monitors SLA operations and statistics in both configuration and on-demand modes. The test also verifies that all this works when traffic is flowing, and repeats these steps for the on-demand mode. This test is triggered by a configuration of CFM ethernet SLA delay measurement.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw probe send burst once slm",
                "Procedure": "The test verifies SLA over L2VPN XConnect AC to PW scenario by sending a probe as a single burst. It checks Ethernet SLM and confirms that SLA is working correctly in both configuration and on-demand modes with various interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q. The test also verifies that the above-mentioned configurations work properly when traffic is flowing. This test is triggered by verifying the CFM Ethernet SLA delay measurement configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw pop push rewrite dmm",
                "Procedure": "The test verifies Ethernet SLA DMM over L2VPN XConnect to PW scenario with rewrite ingress tag pop and push. The test checked various interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, using the 'show ethernet sla operations' and 'show ethernet statistics interface' commands in both configuration and on-demand modes. It also verified these tests while traffic was flowing. The test repeated all steps for on-demand mode and used CFM (Connectivity Fault Management) with Ethernet SLA delay measurement.\n\nThis test is triggered by enabling the CFM, Ethernet SLA DMM over L2VPN XConnect to PW scenario with rewrite ingress tag pop and push configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrewrite_mode: \"ApData.rewrite_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nCfm peer meps verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw pop push rewrite slm",
                "Procedure": "The test verifies a scenario where Service-Level Measurement (SLM) over Layer 2 VPN Xconnect Access Circuits to Pseudowire is used with Cisco Feature Manipulation (CFM). The Ethernet SLM configuration uses the rewrite ingress tag pop and push feature. The test was verified in several ways, including checking the SLA performance on various interface types such as physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, both with and without rewrite mode activated. The verification included showing Ethernet SLM operations and details, as well as displaying Ethernet statistics for the interface in both configuration and on-demand modes. The test was repeated while traffic was flowing to ensure that all scenarios were covered. This test is triggered by a CFM ethernet sla delay measurement configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrewrite_mode: \"ApData.rewrite_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nCfm peer meps verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw probe send packets dmm",
                "Procedure": "The test verifies a cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario by sending probe packets. This test is triggered by a configuration that includes CFM and ethernet sla delay measurement. The test checks the SLA as follows: it tests interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and combinations of these, using show commands such as \"show ethernet sla operations\", \"show ethernet sla operations detail\", and \"show ethernet statistics interface\". These tests are performed in both configuration mode and ondemand mode, with traffic flowing through the network. The same steps are repeated for ondemand mode before the test is complete.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw probe send packets slm",
                "Procedure": "The test verifies the cfm ethernet sla SLM over l2vpn xconnect ac to PW scenario with probe as packets. It tests various interface types including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q. The test also involves running commands such as \"show ethernet sla operations\", \"show ethernet sla operations detail\", and \"show ethernet statistics interface\" in both configuration and ondemand modes. Additionally, it verifies that these operations are functioning correctly while traffic is flowing, and repeats this process for the ondemand mode. This test is triggered by a configuration that uses CFM (Connectivity Fault Management) for ethernet sla delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw probe send packets no aggregate dmm",
                "Procedure": "The test verifies that CFM Ethernet SLA DMM functions correctly over an L2VPN xconnect to PW scenario without aggregating buckets. It checks the following scenarios in both configuration and on-demand modes: interface types including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q; show ethernet sla operations and detail commands; and show ethernet statistics interface commands. Traffic is flowing during these tests to ensure accurate results. This test is triggered by CFM Ethernet SLA DMM configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw probe send packets no aggregate slm",
                "Procedure": "The test verifies the cfm ethernet sla SLM over l2vpn xconnect ac to PW scenario without aggregation of buckets. It tested the SLA performance under various interface types, including physical main interfaces, dot1q, dot1ad, and q-in-q, as well as combinations such as dot1ad-dot1q. The test also involved using various commands like 'show ethernet sla operations', 'show ethernet sla operations detail', and 'show ethernet statistics interface' in both configuration and on-demand modes, with traffic flowing through the network to ensure accurate results. The same tests were repeated for on-demand mode.\n\nThis test is triggered by setting up a configuration that includes CFM (Connectivity Fault Management) and Ethernet SLA delay measurement configurations.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw dmm bins buckets per probe",
                "Procedure": "This test is triggered by verifying that a cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario with multiple bins per bucket works as expected. The test verified SLA for interface types including physical main interface, dot1q, dot1ad, q-in-q, and combinations of these, using commands such as \"show ethernet sla operations\", \"show ethernet sla operations detail\", and \"show ethernet statistics interface\". The configuration included aggregate bin setup, bin width definition, and number of buckets per probe, with traffic flowing to test the entire setup. CFM and ethernet sla delay measurement were also configured for verification.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw slm bins buckets per probe",
                "Procedure": "The test verifies that a cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario works correctly, including multiple bins per bucket, by checking several interface types such as physical main interfaces and q-in-q. It checks the show ethernet sla operations and detail commands, the show ethernet statistics interface command, and ensures that all configured aggregation bin settings are correct while traffic is flowing. The test also verifies that configuration for CFM and ethernet sla delay measurement is in place.\n\nThis test is triggered by verifying that an SLA (Service Level Agreement) meets certain criteria, specifically interface types such as physical main interfaces and q-in-q.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw probe send burst once negative dmm",
                "Procedure": "The test verifies the cfm Ethernet SLA DMM over L2VPN XConnect AC to PW scenario by covering various negative scenarios. The test involves verifying the SLA through multiple interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, as well as displaying Ethernet SLA operations, detailed information on these operations, and statistics for each interface. This test is triggered by a configuration of CFM and Ethernet SLA delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nVerify verification is performed.\nTraffic verification is performed.\nCfm peer meps verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw process trigger dmm",
                "Procedure": "The test verifies that a cfm Ethernet SLA DMM (Device Management Method) works properly over an L2VPN xconnect access circuit to a PW (Pseudowire) scenario with process restart. The test involves checking the SLA as follows: it checks interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and combinations of these, using commands such as show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface. It performs all of these steps in both configuration mode and on-demand mode, verifying that the SLA works with traffic flowing. This test is triggered by the process restarting, which requires the CFM (Connectivity Fault Management) and Ethernet SLA delay measurement to be configured.\n\n Triggered by: the restart of the device management process, which necessitates the configuration of CFM and Ethernet SLA delay measurement settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"Y1731ApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw process trigger slm",
                "Procedure": "The test verifies that a cfm ethernet sla SLM over l2vpn xconnect ac to PW scenario operates correctly with process restart and crash. The SLA is verified as follows: interface types such as physical main interface, dot1q, dot1ad, q-in-q, and dot1ad-dot1q are checked using commands like show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface. These checks are performed with both configuration and ondemand mode enabled, and all the above steps are repeated while traffic is flowing. This test is triggered by configuring CFM and Ethernet SLA delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"Y1731ApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw rpfo dmm",
                "Procedure": "The test verified that a cfm ethernet sla DMM over l2vpn vpls ac to ac scenario with RPFO works correctly in both configuration and on-demand modes. It tested various interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q configurations, as well as the show ethernet sla operations and show ethernet statistics interface commands. The test also verified that these functions work with traffic flowing through the network, repeating all steps in both configuration and on-demand modes. This test is triggered by a configuration that includes CFM and Ethernet SLA delay measurement.",
                "Pass/Fail Criteria": "Ha verification is performed.\nSla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw rpfo slm",
                "Procedure": "The test verifies Ethernet Service Level Monitoring (SLM) over Layer 2 VPN cross-connects to pseudowire scenarios with Remote Performance Feedback Optimization (RPFO). It tests several SLA functions, including interface types such as physical main interfaces and VLAN subinterfaces. The test checks the output of various show commands, including \"show ethernet sla operations\" and \"show ethernet statistics interface\", both in configuration mode and on-demand mode. Additionally, it ensures that all these operations work correctly when traffic is flowing. To perform this testing, the network uses CFM (Connectivity Fault Management) with Ethernet SLM delay measurement configurations.\n\nThis test is triggered by configuring a scenario that involves a Layer 2 VPN cross-connect to pseudowire and enabling Remote Performance Feedback Optimization (RPFO).",
                "Pass/Fail Criteria": "Ha verification is performed.\nSla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Check sla dmm with span on core interfaces",
                "Procedure": "The IFD CSCvv05976 test verifies a Cfm Ethernet Sla DMM with span configuration on the core interfaces. It checks several interface types, including physical main interface, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, and configures an Ethernet SLA delay measurement profile. The test then applies this profile to various interfaces, enables SPAN in TX direction, and configures global span settings on the core interfaces. It verifies that DMM counters are being sent and received by checking verbose local MEPs for Ethernet CFM and also checks Ethernet SLA statistics. Finally, it unconfigures the SLA profiles and span configurations.\n\nThis test is triggered by the configuration of CFM, ethernet sla delay measurement, and Span on the system.",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla Statistics verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw mpa triggers dmm",
                "Procedure": "The test verifies the cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario with MPA. This test is triggered by verifying SLA operations, including physical main interfaces and dot1q/q-in-q/dot1ad-dot1q interfaces, as well as show commands for ethernet sla operations, detail, and interface statistics, both in configuration mode and ondemand mode, under normal conditions and when traffic is flowing.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.mpa_triggers\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw master sc reload dmm",
                "Procedure": "The test verifies a cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario with Master SC Reload. It checks SLA performance as follows: interface types include physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q; the \"show ethernet sla operations\" and \"show ethernet sla operations detail\" commands are used; show ethernet statistics interface is also tested; and all these checks are done both in configuration mode and ondemand mode. In addition, traffic must be flowing during the tests, which are repeated for ondemand mode.\n\nThis test is triggered by a Master SC Reload event in the cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario.",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw slave sc reload dmm",
                "Procedure": "This test verifies that a cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario with Slave SC Reload works correctly in both configuration and on-demand modes. The test includes various verification steps such as checking interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q; displaying Ethernet SLA operations and statistics; verifying that all of the above functions work with traffic flowing through the network. This test is triggered by configuring CFM (Connectivity Fault Management) and enabling Ethernet SLA (Service Level Agreement) delay measurement.",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw active rp reload dmm",
                "Procedure": "The test verified SLA operation in various interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q configurations. It also checked show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface commands in both configuration and on-demand modes. The test was performed with traffic flowing, and all the above steps were repeated for on-demand mode.\n\nThis test is triggered by a scenario where there is an Active RP Reload over l2vpn xconnect ac to PW.",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw standby rp reload dmm",
                "Procedure": "The test verified that a cfm ethernet sla DMM over l2vpn xconnect ac to PW scenario functions correctly with Standby RP Reload. It checked interface types including physical main interfaces and various Q-in-Q configurations, as well as SLA operations in both configuration and on-demand modes. The test also included verifying these operations while traffic was flowing and repeating the checks for on-demand mode. Configuration involved using CFM for ethernet sla delay measurement. This test is triggered by a Standby RP Reload event.",
                "Pass/Fail Criteria": "Ha verification is performed.\nSla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw reload router dmm",
                "Procedure": "The test verifies that cfm ethernet sla DMM works correctly over l2vpn xconnect ac to PW in a scenario where the router is reloaded. This involved checking the SLA as follows: interface types were verified with physical main interfaces, dot1q, dot1ad, q-in-q, and combinations of these, using show commands such as ethernet sla operations, ethernet sla operations detail, and ethernet statistics interface. The above steps were repeated in both configuration and ondemand mode, with traffic flowing between the devices. This test is triggered by CFM, ethernet sla delay measurement configuration.",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to pw commit replace dmm",
                "Procedure": "This test verifies a cfm Ethernet SLA DMM over L2VPN XConnect AC to PW scenario with Commit Replace & Rollback. The test confirmed that SLA works as expected under various interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q. It also verified the show ethernet sla operations and show ethernet statistics interface commands in both configuration and on-demand modes, with traffic flowing. Additionally, it repeated these steps for the on-demand mode to ensure all scenarios are covered.\n\nThis test is triggered by a commit replace rollback operation.",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to ac dmm",
                "Procedure": "The test verifies the operation of cfm ethernet sla DMM over l2vpn xconnect ac to ac scenario. The SLA was verified as follows: it checks interface types such as physical main interfaces and multiple VLAN tagging configurations including dot1q, dot1ad, q-in-q, and dot1ad-dot1q. It also examines show commands for ethernet sla operations, both in detail and with statistics, and checks these operations in both configuration and ondemand modes. The test further verifies that all the above steps are successful when traffic is flowing. This test is triggered by a configuration using CFM for ethernet sla delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to ac slm",
                "Procedure": "The test verifies that Ethernet Service Level Monitoring (SLM) works correctly in a Layer 2 VPN xconnect access to access scenario. This test is triggered by verifying SLA as follows: Interface types include physical main interface, dot1q, dot1ad, q-in-q, and combinations of dot1ad-dot1q, with commands such as show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface used in both configuration and on-demand modes. The test verifies all these operations while traffic is flowing, and repeats the steps for on-demand mode.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to ac probe send packets dmm",
                "Procedure": "The test verifies a scenario where a cfm ethernet SLA DMM is used to measure delays over an L2VPN xconnect connection between two devices. The test checks that the SLA works correctly in both configuration and on-demand modes, verifying various interface types including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q configurations. It also checks show commands such as ethernet sla operations and details, and shows statistics for the interface. This test is triggered by sending packets from a probe.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to ac probe send packets slm",
                "Procedure": "The test verifies Ethernet Service Level Measurement (SLM) over Layer 2 VPN XConnect Access Circuit to Access Circuit scenarios, including probe packets sent as Ethernet frames. It checks SLA performance from various interface types, such as physical main interfaces and VLAN tagged interfaces, using commands like \"show ethernet sla operations\" and \"show ethernet statistics interface\". This test is triggered by a configuration of Ethernet SLM delay measurement with CFM.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to ac probe send packets no aggregate dmm",
                "Procedure": "This test verifies SLA for a cfm ethernet sla DMM over L2VPN XConnect AC to PW scenario without aggregation. The test checks interface types, including physical main interfaces and VLAN-aware bridges with double-tagged frames, as well as the display of Ethernet SLA operations in detail. It also examines Ethernet statistics on an interface. All these tests are performed in both configuration mode and on-demand mode, with traffic flowing. This test is triggered by the use of CFM for ethernet sla delay measurement configurations.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla statistics interface verification is performed.\nEthernet sla operations detail interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to ac probe send packets no aggregate slm",
                "Procedure": "The test verified the Ethernet SLA DMM over L2VPN xconnect AC to AC scenario without aggregation. It checked several interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, using various commands such as \"show ethernet sla operations\" and \"show ethernet statistics interface\". The test was performed in both configuration mode and on-demand mode, with traffic flowing. The same steps were repeated for the on-demand mode. This test is triggered by CFM (Connectivity Fault Management) and Ethernet SLA delay measurement configurations.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla statistics interface verification is performed.\nEthernet sla operations detail interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla xc ac to ac probe send burst once negative dmm",
                "Procedure": "This test verified SLA (Service-Level Agreement) operation over L2VPN XConnect AC-to-AC connections with cfm (connectivity fault management) and Ethernet SLa DMM (delay measurement method) when used in negative scenarios. The test confirmed that the interface types of physical main interface, dot1q, dot1ad, q-in-q, and dot1ad-dot1q were functioning correctly, as demonstrated by commands such as 'show ethernet sla operations' and 'show ethernet statistics interface', both with configuration and ondemand modes enabled. Traffic was also verified to be flowing through the connections during these tests, which were repeated for both modes. This test is triggered by configuring CFM (Connectivity Fault Management) and Ethernet SLa DMM delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nTraffic verification is performed.\nCfm peer meps verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to pw dmm",
                "Procedure": "The test verifies communication over a CFM Ethernet SLA DMM through an L2VPN bridge domain to a pseudowire (PW) scenario. It includes verifying SLA operations for various interface types, including physical main interfaces and VLAN tags such as dot1q, dot1ad, q-in-q, and combinations of these tags. The test also involves displaying Ethernet SLA operation details, interface statistics, and repeating these steps in both configuration and on-demand modes while traffic is flowing. Additionally, the test verifies all operations with CFM and Ethernet SLA delay measurement configured.\n\nThis test is triggered by verifying that a cfm ethernet sla DMM over l2vpn bridge domain ac to PW scenario has been successfully established.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to pw slm",
                "Procedure": "The test verifies that Ethernet SLM (Service Level Measurement) over L2VPN Bridge Domain AC to PW scenario works correctly. This test is triggered by verifying SLA as follows: interface types physical main interface, dot1q, dot1ad, q-in-q, and dot1ad-dot1q; checking show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface in both configuration and on-demand modes; and verifying that all of these steps work correctly with traffic flowing. The test also repeats the above steps for on-demand mode and is performed using CFM (Connectivity Fault Management) and Ethernet SLM delay measurement configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to pw pop push rewrite dmm",
                "Procedure": "This test verifies that Ethernet SLA DMM works correctly over L2VPN Bridge Domain AC to PW scenarios with ingress tag pop and push rewrite. The test verified Service Level Agreements (SLAs) as follows: it checked interface types such as physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q; displayed Ethernet SLA operations and detailed information; showed Ethernet statistics for the interface; and performed all of these actions both with configuration mode and on-demand mode enabled. The test also verified that these operations occurred while traffic was flowing over the network. To accomplish this, it repeated the steps in on-demand mode as well. This test is triggered by a Configuration: CFM, ethernet sla delay measurement setup.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrewrite_mode: \"ApData.rewrite_mode\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to pw pop push rewrite slm",
                "Procedure": "This test verifies connectivity between a Bridge Domain AC (B-DAC) and a Provider Edge (PE) device over an L2VPN using Ethernet SLM and CFM in a scenario where ingress tags are popped and pushed. The test confirms that SLA is functioning as expected by checking interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q, with rewrite mode enabled for both pop and push operations. Additionally, it verifies Ethernet SLA operations, shows Ethernet statistics on the interface, and checks these conditions in both configuration and on-demand modes. The test ensures all steps are accurate when traffic is flowing and repeats them for both push and pop rewrite modes. This test is triggered by a CFM and Ethernet SLA delay measurement configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrewrite_mode: \"ApData.rewrite_mode\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to pw process trigger dmm",
                "Procedure": "The test verified that a device can perform cfm ethernet sla DMM over l2vpn Bridge domain ac to PW scenario with process restart and crash. The verification included several aspects such as interface types (physical main interface, dot1q, dot1ad, q-in-q, and dot1ad-dot1q) using commands like show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface in both configuration and ondemand modes. Additionally, the test ensured that all these functionalities work correctly with traffic flowing. The same steps were repeated for the ondemand mode.\n\nThis test is triggered by a configuration of CFM (Connectivity Fault Management) and Ethernet SLA (Service Level Agreement) delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"Y1731ApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to pw process trigger slm",
                "Procedure": "The test verifies a specific scenario involving Ethernet SLM over L2VPN Bridge Domain AC to PW. It covers multiple interface types, including physical main interfaces and various VLAN configurations such as dot1q, dot1ad, q-in-q, and combinations of these, with measurements taken using CFM and ethernet sla delay measurement. The test includes several commands: show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface, in both configuration and on-demand modes. This test is triggered by the need to verify SLA performance under normal traffic flow conditions and during restarts and crashes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"Y1731ApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to pw rpfo dmm",
                "Procedure": "This test verifies SLA over L2VPN VPLS Bridge Domain AC to PW scenario with RPFO by checking various interface types such as physical main interface, dot1q, dot1ad, q-in-q, and dot1ad-dot1q. The test monitors Ethernet SLA operations in both configuration and on-demand modes, using commands like \"show ethernet sla operations\" and \"show ethernet statistics interface\". Additionally, the test verifies these metrics while traffic is flowing, and repeats all these steps for the on-demand mode. The test also checks CFM (Connectivity Fault Management) and Ethernet SLA delay measurement configurations. This test is triggered by selecting the appropriate configuration from the drop-down menu.",
                "Pass/Fail Criteria": "Ha verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to pw rpfo slm",
                "Procedure": "The test verifies a cfm Ethernet Service Level Measurement (SLM) over Layer 2 VPN Bridge domain access circuit to pseudowire scenario with Resource Priority Fast Re-Route. The test checks that the SLM functions as expected for various interface types, including physical main interfaces and various VLAN configurations. It also examines the output of show ethernet sla operations commands in both configuration and ondemand modes, as well as the output of show ethernet statistics interface commands to verify that all the above work with traffic flowing. This test is triggered by a configuration using CFM for Ethernet SLM delay measurement.",
                "Pass/Fail Criteria": "Ha verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to ac dmm",
                "Procedure": "The test verifies that a cfm Ethernet SLA DMM works over an L2VPN Bridge Domain across ac to ac connections. This test is triggered by testing interface types such as physical main interfaces, dot1q, dot1ad, q-in-q, and combinations of dot1ad-dot1q using show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface commands in both configuration and on-demand modes. The test verifies these functions with traffic flowing between connections and repeats the steps for on-demand mode.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla bd ac to ac slm",
                "Procedure": "The test verifies Ethernet Service Level Monitoring (SLM) over Layer 2 VPN bridge domain access to access (AC-to-AC) scenario. This test is triggered by a configuration that includes physical main interface and various subinterfaces such as dot1q, dot1ad, q-in-q, and dot1ad-dot1q. The test ran multiple show commands including \"show ethernet sla operations\", \"show ethernet sla operations detail\", and \"show ethernet statistics interface\" in both configuration and on-demand modes. All of these tests were performed while traffic was flowing over the network, and the process was repeated for the on-demand mode. The underlying technology used for this test is Ethernet SLM with delay measurement enabled through CFM (Connectivity Fault Management).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla l2 downmep dmm",
                "Procedure": "The test verifies the operation of a CFM Ethernet Service Level Agreement (SLA) over Layer 2 interfaces. This test is triggered by attempting to verify SLA using a specific configuration and traffic flow.\n\nConfiguration: \n- Interface types physical main interface, dot1q, dot1ad, q-in-q, dot1ad-dot1q\n- show ethernet sla operations\n- show ethernet sla operations detail\n- show ethernet statistics interface\n\nAll the above with both configuration and on-demand mode. Verify all the above with traffic flowing. Repeat all the above steps for on-demand mode\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla l2 downmep slm",
                "Procedure": "The test verifies Ethernet SLM (Service Level Monitoring) over L2 interfaces with CFM (Connectivity Fault Management). It tests SLA (Service Level Agreement) verification as follows: it checks interface types including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q; displays ethernet sla operations and detailed operations; shows ethernet statistics for each interface; performs all the above with both configuration and ondemand mode enabled; verifies these conditions while traffic is flowing. The test repeats these steps for ondemand mode. This test is triggered by configuring CFM and Ethernet SLA delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla l3 downmep dmm",
                "Procedure": "The test verifies SLA by checking multiple interface types including physical main interfaces, dot1q, dot1ad, q-in-q, and dot1ad-dot1q configurations. It checks show commands such as \"show ethernet sla operations\", \"show ethernet sla operations detail\", and \"show ethernet statistics interface\" in both configuration and ondemand modes. The test also ensures that these checks are successful even when traffic is flowing. This test is triggered by configuring CFM and enabling Ethernet SLA delay measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sla l3 downmep slm",
                "Procedure": "The test verifies that Ethernet Service Level Monitoring (SLM) works correctly over Layer 3 interfaces using Connectivity Fault Management (CFM). The test checks SLA functionality in various interface types, including physical main interfaces, dot1q, dot1ad, q-in-q, and combinations of dot1ad-dot1q. It also verifies that the show ethernet sla operations, show ethernet sla operations detail, and show ethernet statistics interface commands work as expected with both configuration and on-demand modes enabled. The test is repeated while traffic is flowing to ensure accurate results. This test is triggered by configuring CFM and Ethernet SLM delay measurement.\n\nNote: I rephrased the original text into a natural-sounding paragraph, and rewrote the trigger sentence in proper English as per your request.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\noper_mode: \"ApData.oper_mode\"",
                "Pass/Fail Criteria": "Sla packet increments verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla operations ondemand interface all detail verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale dmm bund 250 vpws",
                "Procedure": "To verify bundle DMM sessions, configure an Ethernet SLA DMM profile globally and apply the configuration under each interface. Next, verify that Ethernet CFM local MEPs show sent and received counters in verbose mode, then check the details of the Ethernet SLA profile and ensure that statistics are displayed correctly using the 'show ethernet sla statistics' CLI command. Additionally, traffic must be present on all interfaces for verification to occur. Finally, unconfigure the Ethernet SLA globally.\n\nThis test is triggered by configuring an interface with both Ethernet SLA DMM and scaling, as well as interface-level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale dmm phy 800 vpws",
                "Procedure": "To verify phy sub-DMM scale sessions with 800 UP MEPs and CCM as ones, follow these steps. First, configure the Ethernet SLA DMM profile globally, then apply the configuration under the interface. Next, verify that the Ethernet CFM local MEPs verbose shows the DMM sent/received counters. After that, check the details of the Ethernet SLA profile using its detail command. The statistics information should be displayed correctly under the show Ethernet SLA statistics CLI command. Verify traffic is also necessary. Finally, unconfigure the Ethernet SLA globally. This test is triggered by a configuration of Ethernet SLA DMM along with scaling and interface-level SLA configurations.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale dmm phy 1k vpws",
                "Procedure": "To verify the phy sub-DMM scale sessions, configure a 1K UP MEPs and CCM as 1s - VPWS configuration with the following steps: Configure an Ethernet SLA DMM profile globally, then apply the Ethernet SLA configuration under each interface. Verify that the Ethernet CFM local MEPs show verbose DMM sent/received counters. Also verify the Ethernet SLA profile details and ensure that statistics information is displayed correctly in the \"show ethernet sla statistics\" CLI command output. In addition to these steps, traffic verification should also be performed. Finally, unconfigure the Ethernet SLA globally.\n\nThis test is triggered by configuring a 1K UP MEPs and CCM as 1s - VPWS configuration with a specific Ethernet SLA DMM profile.",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale dmm phy 2k vpws",
                "Procedure": "To verify the phy sub DMM scale sessions, a test is performed using 2K UP meps and CCM as 1s - VPWS. The steps taken include configuring an ethernet SLA DMM profile globally, applying the configuration under the interfaces, verifying the ethernet CFM local MEPs with verbose showing DMM sent/received counters, checking the ethernet SLA profile details, confirming that ethernet SLA statistics information is displayed correctly under the show ethernet SLA statistics CLI command, and verifying traffic. This test is triggered by a configuration that involves Ethernet SLA DMM alongside scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Y1731 scale global config verification is performed.\nDmm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm phy 2k vpws",
                "Procedure": "Phy sub DMM scale sessions are verified using 2K UP meps and CCM as 1s - VPWS. This test is triggered by configuring an Ethernet SLM profile globally, applying the Ethernet SLA configuration under each interface, verifying that local MEPs show sent/received counters from the DMM in verbose mode, checking the details of the Ethernet SLA profile, ensuring that statistics are displayed correctly in the CLI, verifying traffic flow, and finally unconfiguring the global Ethernet SLA settings. The configuration includes both Ethernet SLA DMM along with scaling and interface level SLA configurations.",
                "Pass/Fail Criteria": "Y1731 scale global config verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale slm dmm phy 2k vpws",
                "Procedure": "The test verifies that phy sub DMM scale sessions function correctly with 2K UP meps and CCM as 1s in VPWS mode, including the verification of various configurations and statistics. This test is triggered by a configuration: Ethernet SLA DMM along with scaling and interface level SLA configs.",
                "Pass/Fail Criteria": "Y1731 scale global config verification is performed.\nTraffic verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale dmm phy 2k vpws basic testcases",
                "Procedure": "To verify the operation of a 2k phy up MEP DMM session, follow these steps: Configure an Ethernet SLA profile globally, then apply it under each interface. Next, perform the trigger to initiate the verification process. Verify that the Ethernet CFM local MEPs display verbose counters for sent and received DMM data, and check the details of the Ethernet SLA configuration. Ensure that the show ethernet sla statistics command displays accurate information. In addition, verify that traffic is passing as expected. Finally, unconfigure the Ethernet SLA globally.\n\nThis test is triggered by a simple interface flap or removal/addition event to ensure that the DMM session is properly reestablished in such scenarios.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntestcase: \"flapinterface\" and \"removeaddintf\" and \"lcreload\" and \"mpareload\" and \"mpaflap\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet cfm local meps verbose shows DMM sent/received counters verification is performed.\nethernet sla profile detail verification is performed.\nethernet sla statistics verification is performed.\nTraffic Verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "10s upmep scale dmm slm phy vpws process trigger",
                "Procedure": "The test verifies the performance of the upmep vpwscfm ethernet sla DMM SLM over l2vpn xconnect ac to PW scenario, triggered by a process after a 10-second wait. It checks several aspects, including the verification of SLA as follows: interface types such as physical main interfaces and dot1q, dot1ad, q-in-q, and dot1ad-dot1q; show ethernet sla operations and detail; and show ethernet statistics interface for both configuration and on-demand modes. The test also ensures that all these aspects are verified with traffic flowing. For the on-demand mode, it repeats these steps to confirm proper operation in this scenario, where CFM and ethernet sla delay measurement are configured.\n\nThis test is triggered by a process after a 10-second wait.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"Y1731ApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Dmm packet increments verification is performed.\nSlm packet increments verification is performed.\nTraffic verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nethernet sla operations and statistics verification is performed.\nTraffic - verify sla operation with traffic flowing verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "hsrp_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Hsrp group id priority version",
                "Procedure": "The test checks the configuration of group ID. It verifies that the config is set up correctly for a given group ID by trying out various different values for the HSRP (HSRP, or Hot Standby Router Protocol) group ID in the configuration.\n\nThis test is triggered when multiple different values are configured for the HSRP group ID.",
                "Pass/Fail Criteria": "hsrp: Verify hsrp group id is configurable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrp timers configuration",
                "Procedure": "The configuration of the hello and hold timer for HSRP is being tested by verifying that different values are configured. This test is triggered by testing the configuration of hello and hold timer.",
                "Pass/Fail Criteria": "hsrp: Verify hsrp hello and hold timer is configurable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 default timers",
                "Procedure": "The configuration involves setting up HSRP on the IPv4 address family with a default timer. To verify this, an HSRPV4 test with a default advertisement timer is run. This test verifies that an HSRPV4 session is established, that default timer values are in place, and that traffic flows properly.\n\nThis test is triggered by running HSRPV4 with a default advertisement timer.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nhsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 cscvw71537",
                "Procedure": "This test verifies that IPv6 support works correctly in a high availability scenario involving a host (hs) running on an RP (Router Protocol) device. The configuration includes hsRP settings.\n\nThis test is triggered by the presence of an IPv6 address in the hsRP configuration.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nhsrp: Verify hsrp session is established verification is performed.\nMaster SWO verification is performed.\nStandby address verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 ac rem add bvi",
                "Procedure": "The test verifies the operation of hsrpv4 in a Border Virtual Interface (BVI) environment with an Access Concentrator (AC) removed and added. To conduct this test, configure HSRP on the v4 address family with default timers. Next, verify that an HSRP session is established and UUT1 (the device under test 1) is active. Then, remove the AC from the BVI. Verify that UUT2 (device under test 2) becomes active. After re-adding the AC, verify that UUT1 resumes being active.\n\nThis test is triggered by a change in network topology or configuration affecting the HSRP session.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nhsrp: Verify hsrp session is active it UUT1 again verification is performed.\nTraffic: no traffic here. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 default timers61 phydot1q vrf",
                "Procedure": "The goal of this test is to verify the functionality of HSRPv4 with a default advertisement timer. To accomplish this, HSRP must be configured on the v4 address family with the default timer enabled. The test verifies that an HSRP session has been established and that the default timer values are in place, after which it checks for proper traffic flow. This test is triggered by configuring HSRP on a device supporting the v4 address family with its default advertisement timer.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nhsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 default timers62 phyqinq",
                "Procedure": "Here is the rewritten paragraph and trigger sentence:\n\nConfiguring HSRP on a v4 address family with the default timer settings involves setting up the protocol, verifying that an HSRP session has been established, checking for correct default timer values, and ensuring that traffic flows properly. This test verifies HSRP on IPv4 addresses with default advertisement timers by following these steps - configure HSRP with its default parameters, verify the establishment of the HSRP session, confirm the timer settings are at their defaults, and check for proper network connectivity. \n\nThis test is triggered by the configuration of HSRP with its default parameters on an IPv4 address family device.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nhsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 71 bunddot1q vrf member mod",
                "Procedure": "Here's the rewritten paragraph:\n\nTo verify HSRPv4 with a default advertisement timer, we configure HSRP on a v4 address family using the default timer. We then establish an HSRP session and verify that the default timer values are being used correctly. Finally, we ensure that traffic is flowing properly through the network.\n\nThis test is triggered by configuring HSRP on a V4 address family with a default advertisement timer.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nhsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 default timers72 bundqinq vrf",
                "Procedure": "Hsrpv4 is tested with a default advertisement timer. The test involves configuring HSRP on the IPv4 address family using the default timer, verifying that an HSRP session is established, checking that the default timer values are as expected, and ensuring that traffic is flowing properly.\n\nThis test is triggered by the configuration of HSRP on the IPv4 address family with a default advertisement timer.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nhsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 commit rollback",
                "Procedure": "The test is designed to verify the functionality of HSRPv4, specifically with commit and rollback configurations. To accomplish this, HSRP is first configured on a V4 address family. The test then attempts to roll back the configuration.\n\nThis test is triggered by the presence of the hsrpv4 feature in the commit message.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nhsrp: Verify hsrp session is established verification is performed.\nhsrp: Verify rollback is successful verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 election default priority ip noip",
                "Procedure": "The test verifies HSRPv4 with default advance timer settings by configuring the protocol on a v4 address family without specifying any priority, shutting and unshutting the interface to verify that the correct device becomes active, configuring one of the devices with a higher IP address and repeating the shutdown procedure, and finally setting an explicit higher priority on the standby device.\n\nThis test is triggered by verifying HSRPv4 default advance timer settings.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nhsrp: Verifies default electoin without priority command. verification is performed.\nTraffic: Verifies default electoin using priority command. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 with tracking enabled",
                "Procedure": "Here is a rewritten version of the text in a single, natural-sounding paragraph:\n\nThis test verifies hsrpv4 with Interface Tracking by configuring it with the tracking option and enabling preempt configuration. When the tracking interface on UUT1 goes down, bringing its priority up by 110, we shut down the tracking interface and verify that UUT2 becomes active. We then unshut the tracking interface and ensure that UUT2 returns to standby mode.\n\nThis test is triggered by shutting down a tracked interface on one device while keeping all other configurations unchanged.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nShut verification is performed.\nNoshut verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nHsrp: After interface is shut, verify priority value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 interface shut rpfo",
                "Procedure": "The hsrpv4 test involves shutting down an interface and configuring a Redundancy Protocol for One (RPFO) setup on the v4 address family with the Hot-Standby Router Protocol (HSRP) outer address set to the Under Test (UUT) device's address. The HSRP session must be established, and the Vrouter address should match the UUT's address. This test is triggered by a configuration of HSRP on the v4 address family with an HSouter addr as UUT address.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nShut verification is performed.\nNoshut verification is performed.\nHsrp: Verify hsrp session is established and hsouter is UUT's address verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 interface ipverify rpfo cfd1",
                "Procedure": "The test for the hsrpv4 interface IP checks that it has been configured correctly after a router priority feature change. It verifies that HSRP on the v4 address family is functioning as expected, with the HSRouter address set to the UUT's address, and confirms that an HSRP session is established between the devices. The test also checks that the Vrouter address matches the UUT's IP address.\n\nThis test is triggered by a change in the router priority feature being applied.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrpv4 interface IP after RPFO.CFD verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 interface ipverify int shutrpfo cfd1",
                "Procedure": "The test involves verifying that HSRPV4 functions properly when the interface is shut down and RPFO is enabled, while also confirming the standby IP address. This is done by configuring HSRP on a v4 address family with the outer address set to the UUT's address, then verifying that an HSRP session is established and that the Vrouter address matches the UUT's address.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrpv4 with interface shut and RPFO and verify standbyip verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 interface flap trafficloss role change",
                "Procedure": "The test for verifying HSRPv4 functionality with interface flap trafficloss_role_change involves configuring HSRP on a v4 address family, establishing an HSRP session, and starting traffic. Then, the interface is shut down, and it's verified that HSRP ownership switches over successfully. After stopping the traffic, it's checked that the traffic flow remains within tolerance. The process is repeated by shutting off the interface, verifying a successful rollback of HSRP ownership, and checking that the traffic flow is still within tolerance. This test is triggered by an interface flap event.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nShut verification is performed.\nTraffic stop verify verification is performed.\nNoshut verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nHsrp: Verify hsrp ownership switcheover happens verification is performed.\nHSRP: Verify hsrp with traffic flow verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 multiple groups",
                "Procedure": "This test involves setting up multiple HSRPV4 groups to serve both the Master and Slave roles, with separate configurations for each. One group is set up with a Master role on a v4 address family, while another is configured with a Slave role on the same address family. The test then verifies that an HSRP session has been established between the two roles and checks their default timer values.\n\nThis test is triggered by multiple HSRPV4 groups serving both Master and Slave roles.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established for Master and Slave groups verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 with secondary ip",
                "Procedure": "HSRPv4 is tested when a secondary IP is configured. The test involves configuring HSRP on the V4 address family with a secondary IP, verifying that an HSRP session is established using this secondary IP, and confirming that default timer values are in place.\n\nThis test is triggered by configuration of secondary IP with HSRPv4.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 bundle interfaces in l2vpn group",
                "Procedure": "HSRPv4 tests are conducted on both the BVI interface and bundle interface within an L2VPN group. To verify that HSRPv4 functions correctly, configure it for the v4 address family on the BVI interface, ensure an HSRP session is established, verify default timer values, and confirm that traffic is flowing as expected.\n\nThis test is triggered by verifying all HSRPv4 configurations are successfully applied to the L2VPN group.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 with process restart",
                "Procedure": "The test for verifying the operation of hsrpv4 when a process is restarted involves configuring HSRP on a device with an IPv4 address, using the default timer settings. Once the configuration is in place, the verification step confirms that the HSRP session has been successfully established. To further test its resilience, the relevant process is then restarted, and the system checks to ensure that the HSRP continues to function properly.\n\nThis test is triggered by the restart of a process relevant to HSRP operation on an IPv4 address.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nHsrp: After process verify hsrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 scale",
                "Procedure": "The test for HSRPV4 at scale verifies the operation of both HSRPV6 and HSRPV4 with their default advertisement timers. The setup involves configuring HSRP on devices that support both IPv6 and IPv4 address families, using the default timer values. Once configured, the test verifies that an HSRP session is established and that the default timer settings are in effect. Finally, it checks to ensure that traffic flows properly through the network.\n\nThis test is triggered by configuration of HSRP on devices with both v6 and v4 address families using default timer values.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 scale bvi",
                "Procedure": "Hsrp is tested for both IPv4 and IPv6 configurations, using the default advertisement timer. The test involves configuring HSRP on an interface that supports both address families with the default timer setting, verifying that a HSRP session is established, checking that the default timer values are in effect, and confirming that traffic is flowing normally. This test is triggered by the scale configuration.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 default timers",
                "Procedure": "HSRPv6 with default advertization timer tests verify that HSRP operates correctly when the advertization timer is set to its default value. To test this, configure HSRP on a v6 address family with the default timer settings, then verify that an HSRP session is established and that traffic flows properly through it. The configuration used for this test involves enabling HSRP.\n\nThis test is triggered by configuring a device with HSRPv6 enabled on a v6 address family with the advertization timer set to its default value.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify Hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 bundle addrem vriinfo",
                "Procedure": "Hsrpv6 is tested with bundle add removal and VRI info verification. This test verifies that the protocol operates correctly when using the default advertisement timer, which involves configuring HSRP on a device with an IPv6 address family and the default timer setting, verifying the establishment of an HSRP session, checking that the default timer values are as expected, and confirming that traffic is flowing properly.\n\nThis test is triggered by adding/removing bundle interface and VRI info verification.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nIpv6 nd vrinfo verification is performed.\nHsrp: Verify Hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 ac rem add bvi",
                "Procedure": "HSRPv6 is tested on a BVI with Active Component removal and addition. The test verifies HSRPv6 operation with default advertisement timer configuration, including establishing an HSRP session and verifying that UUT1 is active. With the Active Component removed from the BVI, verification ensures that UUT2 becomes active. The process is then repeated by adding the Active Component back to the BVI, which should cause UUT1 to become active again.\n\nThis test is triggered by configuring HSRP on a v6 address family with default timer settings.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nhsrp: Verify hsrp session is active it UUT1 again verification is performed.\nTraffic: no traffic here. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 default timers61",
                "Procedure": "Hsrpv6 is tested with a default advertisement timer. To verify this, HSRP is configured on a v6 address family with the default timer settings, and then it's confirmed that an HSRP session has been established, the default timer values are correct, and traffic is flowing properly.\n\nThis test is triggered by enabling HSRP on a v6 address family.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify Hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 default timers62",
                "Procedure": "HSRPv6 with a default advertisement timer is tested by verifying that it functions correctly. The test involves configuring HSRP on an IPv6 address family with a default timer, then checking that the HSRP session is established and that the default timer values are correct. With this setup, traffic should flow properly. This test is triggered by configuring HSRP on the v6 address family with the default advertisement timer.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify Hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 default timers71",
                "Procedure": "Hsrp on a v6 address family with the default timer is tested. The test involves configuring hsrp, verifying that an hsrp session is established, checking default timer values, and ensuring that traffic is flowing properly. This test is triggered by HSRP configuration on a v6 address family with the default timer.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify Hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 default timers72",
                "Procedure": "HSRPv6 is tested with the default advertisement timer. This test verifies that an HSRP session is established when HSRP is configured on a V6 address family with a default timer, and checks that default timer values are correct and that traffic flows properly.\n\nThis test is triggered by configuring HSRP on a v6 address family with default timers.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify Hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 commit rollback",
                "Procedure": "hsrpv6 is tested with a default advertisement timer. The test also verifies that hsrp works for IPv4, including committing and rolling back the configuration. To do this, hsrp is configured on an IPv4 address family. Then, the configuration is rolled back.\n\nThis test is triggered by configuring hsrp on a non-preferred interface and checking that it does not come up as active.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nhsrp: Verify hsrp session is established verification is performed.\nhsrp: Verify rollback is successful verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 election default priority",
                "Procedure": "HSRPv6 tests with default Role Election involve verifying the protocol's functionality when configured with a default advertisement timer. To test this, HSRP is first enabled on a v6 address family without specifying an explicit priority for either device. The interface is then shut down and brought back up to verify that the correct UUT becomes active. Next, explicit higher priority is configured on the standby UUT. Finally, the interface is shut down and brought back up again to confirm that the correct device remains active. This test is triggered by configuring HSRP with a default advertisement timer as described in the configuration: hsRP.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nhsrp: Verifies default electoin without priority command. verification is performed.\nTraffic: Verifies default electoin using priority command. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 with tracking enabled",
                "Procedure": "Hsrpv6 tests are run with tracking enabled. The test verifies the functionality of Hsrp on a device with IPv6 address family and tracking option enabled. A configuration is set up to establish an Hsrp session. It also checks if the configured priority value, decrement value, and tracked interface are verified. This test is triggered by configuring HSRP on a v6 address family with a tracking option.\n\nRewritten trigger sentence: \nThis test is triggered by configuring HSRP on a v6 address family with a tracking option.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nHsrp: After interface is shut, verify priority value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 multiple groups",
                "Procedure": "The test verifies multiple Hsrpv6 groups serving both Master and Slave roles by configuring one Hsrp group on a v6 address family for the Master role, another group for the Slave role, then verifying that an Hsrp session is established between them with default timer values. This test is triggered by the configuration of HSRP.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established for Master and Slave groups verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 router prioroty with ip",
                "Procedure": "Hsrpv6 with router priority is verified by configuring HSRP on the v6 address family with a vRouter address as the UUT address. A stable HSRP session is then established and verified, followed by verifying that the hrouter address is indeed the UUT's address. This test is triggered by an attempt to configure HSRP on a v6 address family with a vRouter address.\n\n(Trigger sentence)",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established and vrouter is UUT's address verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 with secondary ip",
                "Procedure": "HSRPv6 is tested with a secondary IP address configured. To verify this, the HSRP protocol is set up on a V6 address family using a secondary IP address, and it's checked that an HSRP session is established with this secondary IP address present. Default timer values are also verified during the test. This test is triggered by configuring HSRP.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 interface flap trafficloss role change",
                "Procedure": "Hsrpv6 is tested with interface flap, traffic loss, and role change in a series of scenarios. First, HSRP is configured on a v6 address family, and a session is established. Traffic is then started, and the interface is shut down to simulate an HSRP switchover. The test verifies that HSRP ownership switches over correctly. Once this is confirmed, traffic is stopped and verified to flow within tolerance. This test is triggered by the need to ensure that HSRP functions as expected when an interface is shut down. Finally, the interface is unshut, and HSRP ownership rolls back to its original state; again, traffic flow is verified to be within tolerance.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nTraffic stop verify verification is performed.\nHSRP: Verify hsrp session is established verification is performed.\nHSRP: Verify hsrp ownership switcheover happens verification is performed.\nHSRP: Verify hsrp with traffic flow verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle interfaces in l2vpn group",
                "Procedure": "HSRPv6 is tested on both BVI interfaces and Bundle interfaces within an L2VPN group. To verify that it's working as expected, HSRP needs to be configured for the v6 address family on the BVI interface, after which the test should confirm that the HSRP session has been established. Additionally, default timer values are verified and traffic is checked to ensure it's flowing correctly.\n\nThis test is triggered by configuration of HSRP on v6 address family for BVI interface in L2VPN group.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 with process restart",
                "Procedure": "The test for verifying the functionality of hsrpv6 in scenarios involving process restarts. This test is triggered by configuring HSRP on a device that supports the IPv6 address family with the default timer, establishing an HSRP session, and then restarting the relevant process to verify the continued operation of HSRP.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nHsrp: After process verify hsrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 scale",
                "Procedure": "Hsrpv6 tests are conducted at scale, verifying the protocol's functionality in a multi-device environment. The test configuration includes setting up HSRP with the default timer on a network with an IPv6 address family, and then confirming that HSRP sessions are successfully established. Additionally, traffic is monitored to ensure it is flowing properly throughout the network.\n\nThis test is triggered by configuring hsrp on v6 address family with default timer.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv6 scale bvi",
                "Procedure": "The configuration for this test involves setting up HSRP on both IPv6 and IPv4 addresses using the default advertisement timer. This allows verification of the HSRP session establishment, default timer values, and proper traffic flow between devices. This test is triggered by a network with HSRP configured across multiple address families.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4v6 default timers",
                "Procedure": "HSRPv6 and HSRPv4 are configured with the default advertisement timer. The setup involves configuring HSRP on both IPv6 and IPv4 address families with the default timer enabled. Once the configuration is in place, the test verifies that an HSRP session has been established, checks for correct default timer values, and ensures that traffic flows properly.\n\nThis test is triggered by the configuration of HSRP on a device supporting both IPv6 and IPv4 address families.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4v6 default timers v2 with prioritycmd with reload",
                "Procedure": "Configuring HSRP on both IPv6 and IPv4 address families with the default advertising timer, we verify that a session is established between routers with the default timer values. Traffic is then ensured to be flowing properly between the routers. We test two scenarios: when a router with high priority becomes active during normal operation, and again after a reload. This test is triggered by verifying HSRP on both IPv6 and IPv4 address families with the default advertising timer.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly after reload verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4v6 with tracking enabled",
                "Procedure": "HSRP tests verify operation with tracking enabled. The test involves configuring HSRP on both IPv4 and IPv6 address families with the tracking option, establishing an HSRP session, verifying the priority value, and checking that it decrements when a tracked interface goes down.\n\nThis test is triggered by enabling tracking in the HSRP configuration.",
                "Pass/Fail Criteria": "Hsrp details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nHsrp: After interface is shut, verify priority value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4v6 multiple groups",
                "Procedure": "Multiple groups of both HSRPv6 and HSRPv4 are tested, serving in both Master and Slave roles. The configuration involves setting up one HSRP group on a v6 address family for the Master role, another for the Slave role, as well as ones for the Master and Slave roles on a v4 address family. Following this, it's verified that an HSRP session is established and default timer values are in place.\n\nThis test is triggered by the configuration of HSRP groups on both IPv6 and IPv4 address families.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established for Master and Slave groups verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4v6 router default prioroty with ip with reload",
                "Procedure": "HSRPv6 and HSRPv4 with router priority are tested in this feature to verify that they are functioning correctly. The test configures HSRP on both v6 and v4 address families, using the vrouter address as the UUT address. It then verifies that an HSRP session is established and checks the active and standby status of the routers (UUT2 is active and UUT1 is standby). The router is reloaded, and after reloading, it's verified again that UUT2 is active and UUT1 is standby. This test is triggered by configuration: HSRP.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established and vrouter is UUT1 is active before and after Reload for V4 and V6 verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4v6 with secondary ip",
                "Procedure": "HSRP is configured on both IPv4 and IPv6 addresses, with a secondary IP address. The test verifies that an HSRP session is established with the secondary IP address and uses default timer values. This test is triggered by a configuration of HSRP on a device with a specific address family (IPv4 and/or IPv6) and a secondary IP address configured.",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4v6 with process restart",
                "Procedure": "This test verifies the functionality of HSRP (Hot Standby Routing Protocol) versions six and four, including how it responds to process restarts. It involves configuring HSRP on both IPv6 and IPv4 address families with their default timers set. The next steps are verifying that an HSRP session is successfully established. Then, the relevant processes are restarted, after which it's confirmed that the HSRP configuration remains intact.\n\nThis test is triggered by the restart of a process involved in HSRP operation.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nHsrp: After process verify hsrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4v6 with triggers",
                "Procedure": "HSRP configuration is set up for both IPv6 and IPv4 address families, using a default timer. HSRP sessions are then verified as being established. To test how HSRP responds to certain events, specific triggers are introduced and their effects on the HSRP session are checked.\n\nThis test is triggered by: Performing the desired action that tests how HSRP handles various scenarios.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Hsrp interface details verification is performed.\nTraffic stop verify verification is performed.\nInterface detail verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nHsrp: After trigger verify hsrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrpv4 scale mgbl",
                "Procedure": "Hsrpv4 is tested at scale, verifying both Hsrpv6 and Hsrpv4 with a default advertisement timer. The configuration involves setting up hsrp on both v6 and v4 address families with the default timer. Once configured, it's verified that an hsrp session has been established, and that the default timer values are as expected. Furthermore, the test checks to ensure traffic is flowing properly.\n\nThis test is triggered by HSRP configuration at scale.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmodel_type: \"ApData.mgbl_config['model_type']\"\nverification_protocol: \"ApData.mgbl_config['verification_protocol']\"\nverification_operation: \"ApData.mgbl_config['verification_operation']\"\nverification_subscription_type: \"ApData.mgbl_config['subscription_type']\"\nconfiguration_protocol: \"ApData.mgbl_config['configuration_protocol']\"\nconfiguration_gnmi_type: \"ApData.mgbl_config['configuration_gnmi_type']\"\nconfiguration_netconf_type: \"ApData.mgbl_config['configuration_netconf_type']\"",
                "Pass/Fail Criteria": "Hsrp summary verification is performed.\nHsrp: Verify hsrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hsrp v4 v6 scale",
                "Procedure": "HSRP IPv4v6 sessions scale sessions as per available & unused links along with HA triggers. To test this, verify that role negotiation is properly established on HSRP sessions scaled after a plain configuration before triggering HA; then perform the HA trigger by flapping an interface, using rpfo, changing priority, or rolling back the global configuration. Verify role negotiation on HSRP sessions after the HA trigger is activated.\n\nThis test is triggered by performing actions such as flapping an interface, using rpfo, changing priority, or rolling back the global configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nintf_type: \"ApData.zap.get_testcase_configuration().get('scaling_on', ['bundle_sub', 'physical_sub'])\"\ntrigger: \"ApData.zap.get_testcase_configuration().get('triggers', ['change_priority', 'flapinterface', 'rpfo', 'rollback_global_config'])\"",
                "Pass/Fail Criteria": "Scaled hsrp sessions verification is performed.\nHSRP sessions are established in complete Active / Standby verification is performed.\nHSRP role negotiations are proper after HA trigger verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "erspan_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Erspan gre tunnel",
                "Procedure": "The ERSpan (Encapsulated Remote Span) test involves checking if a mirroring session is properly configured to use a GRE (Generic Routing Encapsulation) tunnel. The configuration should specify the destination as a GRE tunnel, and traffic verification on the tunnel interface is necessary. Configurations are set up within the test case module. \n\nThis test is triggered by verifying that the ERSpan gre tunnel configuration matches a mirroring session's destination in a mirroring setup.",
                "Pass/Fail Criteria": "Start arp and verify verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tunnel traffic",
                "Procedure": "To determine if an erspan is enabled, check the status of an erspan session on a device connected to a network with a destination tunnel interface by verifying that the configuration for the erspan and its destination tunnel interface are correct and active.\n\nThis test is triggered when verifying the status of a CLI command \"show monitor_session status\" after shutting down the tunnel interface.",
                "Pass/Fail Criteria": "Start arp and verify verification is performed.\nInterface detail verification is performed.\nTraffic verification is performed.\nCli \"show monitor_session status\" verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan diffrent tunnel",
                "Procedure": "When switching to a different tunnel, it's necessary to check for the Erspan status. To do this, we first configure the Erspan with the destination tunnel interface and then shut down the tunnel interface to simulate a failure. Next, we verify the status of the session using the CLI command \"show monitor_session status\". \n\nThis test is triggered by switching the network topology to force a tunnel change.",
                "Pass/Fail Criteria": "Start arp and verify verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nCli \"show monitor_session status\" verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan with mpls",
                "Procedure": "To test ERSpan with MPLS traffic, we check for the ERSpan session status using the destination tunnel interface. The configuration is done in the setup module and involves configuring ERSPan with a destination tunnel interface, shutting down the tunnel interface, and verifying the status of the CLI \"show monitor_session status\".\n\nThis test is triggered by configuring an ERSpan session with a destination tunnel interface, then disabling the tunnel interface to simulate a network failure.",
                "Pass/Fail Criteria": "Start arp and verify verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nCli \"show monitor_session status\" verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan status gre tunnel",
                "Procedure": "To test for erspan status, we check the session status with the destination tunnel interface by configuring the erspan with that interface, shutting down the tunnel interface, and verifying the status using the CLI command \"show monitor_session status\".\n\nThis test is triggered when a configuration has been made in the setup module.",
                "Pass/Fail Criteria": "Span status verification is performed.\nCli \"show monitor_session status\" verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Show tech for erspan",
                "Procedure": "The test checks that the show tech is functioning correctly on the erspan. It verifies that the show tech works, but does not require any additional configurations as all necessary setup has been completed beforehand. This test is triggered by performing a verification of the show-tech for erspan.",
                "Pass/Fail Criteria": "erspan normal mode verification is performed.\nshow monitor_session status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup class testerspanfunctional",
                "Procedure": "The test setup for TestErspanFunctional performs two operations: checking the bundle status and verifying the data path connectivity. It relies on pre-configured settings, with no additional configurations specified.\n\nThis test is triggered by the execution of the TestErspanFunctional test class itself.",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nErspan tunnel arp status verification is performed.\nBundle status and reachability via ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan physical bundle",
                "Procedure": "The Espan test checks both its ability to monitor a physical interface and a bundle interface. It performs two basic operations: ensuring it can keep track of the physical interface and verifying its capacity to monitor the bundle interface. The configuration for this test is minimal, as all necessary settings were completed during setup. This test is triggered by the user performing some action with Espan that would normally require monitoring capabilities, such as connecting a physical interface or bundle.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan remove add bundle member",
                "Procedure": "When testing erspan, simply remove and add a bundle member to see if it works. The test performs two main operations: checking that bundle members can be removed and added without issue, and ensuring that the erspan tool is able to monitor the bundle interface successfully. All required configurations have been set up beforehand, so no further changes are needed.\n\nThis test is triggered by removing and adding a bundle member to verify the functionality of erspan.",
                "Pass/Fail Criteria": "Span status verification is performed.\nBundle brief verification is performed.\nTraffic verification is performed.\nMonitor session status detail verification is performed.\nInterface detail verification is performed.\nMonitor session status internal verification is performed.\nerspan is able to monitor bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan shut noshut",
                "Procedure": "The test checks the Erspan's ability to monitor physical, bundle, and in-tunnel interfaces when a source or destination is shut or no-shut. It performs three operations: checking the Erspan's capability to monitor physical interfaces after shutdown, checking its capability to monitor bundle interfaces after shutdown, and checking its capability to monitor in-tunnel interfaces after shutdown. No special configurations are required for this test; all necessary settings were done prior to running it.\n\nThis test is triggered by shutting or no-shutting a source or destination interface.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nShut verification is performed.\nNoshut verification is performed.\nInterface detail verification is performed.\nerspan is able to monitor physical and bundle after shut/noshut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan save config commit replace",
                "Procedure": "The test saves the ERSpan configuration and commits a replacement. It checks if the ERSpan configuration can be saved, then performs a commit replace operation. The necessary configurations are set up beforehand.\n\nThis test is triggered by the ability to save the ERSpan config and perform a commit replace operation.",
                "Pass/Fail Criteria": "Span status verification is performed.\nerspan is able to monitor physical and bundle after shut/noshut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan acl in source interface",
                "Procedure": "The test checks the ERSPAN ACL on the source interface and verifies that IPv6 traffic is allowed. The test performs two operations: it checks the ERSPAN ACL on the source interface, and then it examines the data traffic to ensure that IPv6 packets are being transmitted correctly. No specific configurations are required for this test, as all necessary settings were already implemented during setup.\n\nThis test is triggered by a packet with the source IP address in IPv6 format.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status detail verification is performed.\nInterface detail verification is performed.\nerspan is able to monitor with acl enabled span verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan portlevel with subinterface",
                "Procedure": "ERSPAN functionality is tested in a subinterface with port-level mirroring on the main interface. This test checks that ESPAN works correctly in both physical and bundle subinterfaces, and verifies that data traffic is transmitted properly. The required configurations are performed during setup and do not need to be reconfigured for this test.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nInterface detail verification is performed.\nTraffic verification is performed.\nerspan is able to monitor with acl enabled span verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan subinterface physical bundle",
                "Procedure": "To test ESPAN functionality, you need to configure a subinterface without a port level. The testing process involves performing the following operations: checking that ESPAN works properly on both physical and bundle subinterfaces and verifying that data traffic is being generated. There are no specific configurations required for this test; all necessary settings were established in the initial setup.\n\nThis test is triggered by the need to verify the functionality of ESPAN in a subinterface without a port level.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nMonitor session status internal verification is performed.\nInterface detail verification is performed.\nTraffic verification is performed.\nerspan is able to monitor with acl enabled span verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan src bundle dest tunnel underlying bundle",
                "Procedure": "Testing ERSpan functionality requires an underlying tunnel interface that is a bundle. This test performs several operations, including checking ERSpan configurations such as the bundle interface, MTU, IPv4 and IPv6 addresses, static routes, GRE tunnels, and Span.\n\nThis test is triggered by the need to verify the configuration of various network features related to ERSpan functionality.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor with acl enabled span verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tx traffic",
                "Procedure": "This test performs two operations: checking whether ERSpan can monitor traffic on a physical interface and checking whether it can also monitor traffic on a bundled interface. No additional configurations are needed, as all necessary settings were taken care of during the setup process.\n\nTrigger: This test is triggered by verifying the setup for monitoring network interfaces with ERSpan.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan rx tx traffic",
                "Procedure": "The test for rx/tx traffic checks if ERSpan is able to monitor both physical interfaces and bundle interfaces. No additional configurations are needed, as all settings were applied during the initial setup.\n\nThis test is triggered by checking the ability of ERSpan to monitor both physical interfaces and bundle interfaces.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan gre parameters",
                "Procedure": "During testing, testers will work with GRE parameters. The test performs several operations, including checking the ERSpan behavior under various GRE parameter settings. There are no specific configurations to be set for this test, as all necessary setups have been completed beforehand. This test is triggered by applying different GRE parameters in a test environment.",
                "Pass/Fail Criteria": "Interface detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nMonitor session status detail verification is performed.\nMonitor session status internal verification is performed.\nerspan is able to monitor physical and bundle after shut/noshut verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan gre route",
                "Procedure": "The tester performs two types of checks: it ensures that an Ethernet Span port operates correctly when the underlying GRE tunnel's next hop address is changed, and it verifies that the port continues to function properly even if there are multiple GRE tunnels with different next hop addresses. The necessary configurations for these tests were done as part of the setup process.\n\nThis test is triggered by changes to the next-hop address or the number of GRE multipaths associated with a GRE tunnel.",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle with nexthop changes verification is performed.\nerspan is able to monitor physical and bundle with multipath verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan with udf l3outer permit",
                "Procedure": "Erspan tests are performed with UDF for permit action. These tests involve checking the functionality of Erspan with User Defined Fields (UDF) and enabling UDF with permit for both physical and bundle interfaces. The configurations used in these tests include Erspan, OSPF, bundle, and UDF.\n\nThis test is triggered by verifying that UDF is enabled with permit action on the network interface for both physical and bundle connections.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nMonitor session status internal verification is performed.\nerspan is able to monitor the permit traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan with udf l3outer deny",
                "Procedure": "Erspan performs functionality checks with user-defined filters that enable denial of service actions for both physical and bundle interfaces. This test is triggered by configurations involving Erspan, OSPF, bundle, and user-defined filters (udf).",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nMonitor session status internal verification is performed.\nerspan is able to monitor the deny traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan with udf l3outer permit deny",
                "Procedure": "Here is a rewritten version of the text.\n\nThe test assesses ERSpan functionality with User Defined Filter (UDF), enabling permit and deny operations. It performs several key operations, including checking ERSpan's UDF capabilities. The test also involves configuration settings for ERSpan, OSPF, bundle, and UDF. This test is triggered by the requirement to verify the integration of ERSpan with User Defined Filter (UDF).",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nMonitor session status internal verification is performed.\nerspan is able to monitor the permit and deny traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan interface change",
                "Procedure": "To test the erspan interface, perform the following operations. Check that the erspan functionality is working as expected after changing the source port, and also verify its functionality after modifying the destination port. No specific configurations are required for this test, as all necessary settings have been completed prior to running it.\n\nThis test is triggered by changes made to either the source or destination ports of the erspan interface.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nMonitor session status internal verification is performed.\nerspan is able to monitor physical and bundle after port change verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan delete config",
                "Procedure": "When testing ERSpan functionality, a deletion test is performed to verify its operation. This involves checking how the system behaves when an ERSpan configuration is deleted. No additional configurations are needed beyond what has been set up, as all relevant settings have already been put into place.\n\nThis test is triggered by attempting to delete the ERSpan configuration that was previously configured for testing purposes.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nInterface detail verification is performed.\nerspan functionality after config delete verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erpsan multi session",
                "Procedure": "The testers evaluate the Erspan functionality across multiple sessions by performing several key operations. This includes checking how the system functions with multiple session configurations. No specific configurations need to be set up for this test, as all necessary settings were established beforehand.\n\nTrigger: This test is triggered by evaluating the Erspan functionality in a multi-session environment.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nInterface detail verification is performed.\nTraffic verification is performed.\nerspan is able to monitor multiple session verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erpsan resolved unresolved ms cscvy65365",
                "Procedure": "The testers span multiple sessions to perform a test that checks the functionality of Erspan, both when resolving and not resolving MS. No specific configurations are required for this test, as all necessary settings were established beforehand.\n\nThis test is triggered by the need to check Erspan's functionality in various scenarios involving resolved and unresolved network messages.",
                "Pass/Fail Criteria": "Monitor session status internal verification is performed.\nMonitor session status detail verification is performed.\nInterface detail verification is performed.\nTraffic verification is performed.\nerspan is able to monitor the resolved and unresolved ms verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup class testerspanha",
                "Procedure": "This test setup class is used to configure and set up a TestErspanHA instance for testing purposes.\n\nThe configurations required for this test are still being determined. \n\nTrigger: This test is triggered by a configuration that has been established as TBD (To Be Determined).",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nSpan status verification is performed.\nErspan tunnel arp status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan process interface flap",
                "Procedure": "The Test E-Span Process Interface Flap configuration is completed during the common setup process. \n\nThis test is triggered by the completion of common setup for configurations involving the E-Span Process Interface Flap.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nInterface detail verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan process restart",
                "Procedure": "When the erspan process needs to be restarted, the system triggers a test called \"test_erspan_process_restart\". This test is triggered by the need to restart the erspan process.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"SpanApBase.get_process_list(SpanApBase.zap, 'test_erspan_process_restart')\"",
                "Pass/Fail Criteria": "Traffic start stop verify verification is performed.\nSpan status verification is performed.\nInterface detail verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan process crash",
                "Procedure": "Test for errors in the erspan process that cause it to crash is currently a work in progress.\n\nThis test is triggered by an error condition in the erspan process resulting in its termination.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"SpanApBase.get_process_list(SpanApBase.zap, 'test_erspan_process_crash')\"",
                "Pass/Fail Criteria": "Traffic start stop verify verification is performed.\nSpan status verification is performed.\nInterface detail verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan process stop start",
                "Procedure": "The testers can stop and start the erspan process.\n\nThis test is triggered by user actions to stop and start the erspan process.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"SpanApBase.get_process_list(SpanApBase.zap, 'test_erspan_process_stop_start')\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nInterface detail verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan stress monitor sessoin add remove",
                "Procedure": "The TestERSpanStressMonitorSessoinAddRemove test is not currently documented. It is unclear what configurations are required for this test.\n\nThis test is triggered by a configuration that has yet to be defined (TBD).",
                "Pass/Fail Criteria": "Traffic verification is performed.\nInterface detail verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nMonitor session status internal verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan stress gre tunnel add remove",
                "Procedure": "The test for spanning stress GRE tunnel add/remove is still in the configuration phase. This test is triggered by a specific scenario involving the addition and removal of Generic Routing Encapsulation (GRE) tunnels while under stress conditions.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nInterface detail verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nMonitor session status internal verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan stress commit replace",
                "Procedure": "The test is known as \"erspan stress commit replace.\" It appears to be a configuration for testing purposes, with no specific details provided. This test is triggered by the command line argument \"--test erspan_stress_commit_replace\".",
                "Pass/Fail Criteria": "Traffic verification is performed.\nInterface detail verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan hw trigger",
                "Procedure": "The test checks the Erspan status, performs different triggers to ensure its functionality, and verifies the configuration of Erspan.\n\nThis test is triggered by checking the Erspan status before execution.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"SpanApBase.get_process_list(SpanApBase.zap, 'test_erspan_hw_trigger')\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan hw mpa trigger",
                "Procedure": "The functionality of Erspan is checked and verified to ensure it works correctly. Various configurations are performed to test its capabilities. Before initiating the trigger, a check on the Erspan status is conducted to confirm readiness. After triggering, further checks are made to verify the operation of Erspan.\n\nThis test is triggered by checking the Erspan configuration settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"SpanApBase.get_mpa_triggers_list(SpanApBase.zap, 'test_erspan_hw_mpa_trigger')\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nMonitor session status internal verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mgmt",
                "Procedure": "The test performs checks to ensure Erspan is allowed in the management interface, and it does not require any additional configurations beyond those set up previously. This test is triggered by performing a series of operations that verify the Erspan function within the management interface.",
                "Pass/Fail Criteria": "Configuration should not be allowed verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Source as destination",
                "Procedure": "When the test source and destination are the same, it performs a specific set of operations. These include checking if spanners are allowed for the same source and destination. The configurations for this test are not applicable, as all necessary settings were completed during the setup process. This test is triggered by when the test source and destination have identical values.",
                "Pass/Fail Criteria": "Configuration should not be allowed verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span rspan",
                "Procedure": "The Test span is not supported in SpitFire.\n\nThis test case is triggered by: The need to verify that the SpitFire application does not support testing of data spans.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Erspan direction",
                "Procedure": "Testing erSPAN direction is not supported. The test performs a series of checks, including verifying that erSPAN is allowed to be configured with a direction of either \"tx-only\" or both. All configurations for this test were completed during the initial setup and no additional configurations are required.\n\nThis test is triggered by checking if erSPAN is allowed to configure its direction as transmit only (tx) or bi-directional (both).",
                "Pass/Fail Criteria": "Configuration should not be allowed verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan max session rejection",
                "Procedure": "ERSPAN max session configuration is performed by testing whether it's possible for ERSpan to configure a maximum supported session. This test is triggered by verifying that the necessary configuration has been completed as part of the setup process, with no additional configurations required.",
                "Pass/Fail Criteria": "Configuration should not be allowed more than maximum verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan udf config",
                "Procedure": "A test is performed on a User Defined Function (UDF) with names of varying lengths. The test checks that the UDF can be configured and operates correctly regardless of the name's length.\n\nThis test is triggered by configuring a UDF with different lengths of names.",
                "Pass/Fail Criteria": "Configuration should not be allowed more than maximum verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan with acl phy bun main",
                "Procedure": "The test spans physical and bundle interfaces with ACLs, performing various operations to ensure ERSpan functionality. These include checking the status of a monitor session, verifying whether an interface can be monitored with or without an ACL, and testing that only the specified ACL is used when monitoring either a physical or bundle interface under a specific monitor session. This test is triggered by the presence of all required configurations in the setup, with no additional settings applied specifically for this test.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan capture to nocapture vice versa phy bun main",
                "Procedure": "The testers verify the physical and bundle interfaces with ACL. They perform checks to ensure that ERSpan can monitor changes from capture to no-capture mode, both for physical and bundle interfaces. All necessary configurations are set up prior to testing.\n\nThis test is triggered by the need to verify the functionality of ERSpan in monitoring interface status changes under various configuration settings.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nerspan is able to monitor physical and bundle when capture changes to no capture verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan with deny acl phy bun main",
                "Procedure": "The test spans both physical and bundle interfaces while denying access. It checks that Erspan is able to monitor the physical interface when access is denied, but does not allow forwarding further on the physical interface. Similarly, it verifies that Erspan can monitor the bundle interface with access denied, without allowing forwarding further on the bundle interface. No additional configurations are required; all necessary settings have been completed during setup.\n\nThis test is triggered by checking whether Erspan is able to monitor a physical or bundle interface when access is denied while preventing it from forwarding further traffic on that specific type of interface.",
                "Pass/Fail Criteria": "erspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan with acl phy bun sub",
                "Procedure": "The test checks the ability of ERSpan to monitor both physical and bundle sub-interfaces with ACL capture. It performs several operations, including checking that ERSPan can monitor physical sub-interfaces with ACL capture enabled, cannot monitor them with ACL no capture enabled, can monitor bundle sub-interfaces with ACL capture enabled, and cannot monitor them with ACL no capture enabled. Additionally, it checks that ERSpan monitors only the required ACLs under a monitor session for both physical and bundle sub-interfaces. The test is run without any specific configurations, as all necessary setup has been completed beforehand. This test is triggered by the need to verify ERSpan's functionality in various network scenarios.",
                "Pass/Fail Criteria": "erspan is able to monitor physical and bundle sub-intf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan with deny phy bun sub",
                "Procedure": "ESPs can monitor both physical and bundle sub-interfaces, even if they are denied by an access control entry. The test performs two main operations: it checks whether the ESP can monitor a physical sub-interface that is restricted by an ACE but cannot forward traffic for that interface, and similarly for a bundle sub-interface. There are no specific configurations required for this test, as all necessary settings were done in the setup phase.\n\nThis test is triggered when verifying the ability of an ESP to monitor network interfaces while enforcing access control restrictions.",
                "Pass/Fail Criteria": "erspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Negative ms dest sub intf",
                "Procedure": "The purpose of this test case is to verify the status of an ERSPAN monitor session, specifically when its destination is a sub-interface. The configuration for this test is based on the common setup, and the verification focuses on confirming that the monitor session status is accurate. This test is triggered by the absence of any specific requirements or conditions.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan flexcli",
                "Procedure": "The test verifies the basic functionalities of Erspan through FelxCLI by performing several operations. It checks the Span status, data path connectivity, removes Erspan from an interface, and ensures that packet mirroring is disabled. Additionally, it overrides the default FlexCLI settings with manual span configurations.\n\nThis test is triggered by a span configuration.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic check verification is performed.\nSpan status and reachability via ping verification is performed.\nOverriding the group with Manual config verification is performed.\ninterfaces with regex pattern verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Tunnel source destination",
                "Procedure": "The test checks the tunnel source, TOS, TTL, and destination by performing two main operations. It first verifies the span status and then confirms that the data path is connected properly. The necessary configurations for this test were completed during the setup process.\n\nThis test is triggered by the need to verify the tunnel's integrity from the source, through its traversing properties (TOS and TTL), to the final destination.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic check verification is performed.\nSpan status and reachability via ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Exclude group",
                "Procedure": "To test the exclude functionality of the flexCLI group, perform the following operations and configurations. The test involves checking the Span status and data path connectivity while excluding the group from the applied group.\n\nThis test is triggered by testing the exclusion functionality of a specific flexCLI group.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic check verification is performed.\nSpan status and reachability via ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flex erspan save config commit replace",
                "Procedure": "The test checks if the commit replacement successfully recovers the span sessions, and it's performed through the use of flexCLI. The operation involves checking the status of the spans and ensuring that there is a connection to the data path. No additional configurations are required beyond what was set up initially.\n\nThis test is triggered by attempting to recover span sessions using the commit replace operation with flexCLI in a group context.",
                "Pass/Fail Criteria": "Erspan stress commit replace verification is performed.\nSpan status and reachability via ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flexcli process ha",
                "Procedure": "To test the process restart and crash, a test is performed that checks the Span status and data path connectivity. This test is triggered by performing all required configurations as part of the setup, without any additional configurations being made.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"SpanApBase.get_process_list(SpanApBase.zap, 'test_erspan_process_restart')\"",
                "Pass/Fail Criteria": "Erspan process restart verification is performed.\nErspan process crash verification is performed.\nSpan status and reachability via ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flexcli hw trigger",
                "Procedure": "The test checks the various hardware triggers by recovering the span sessions using FlexCLI group. It performs a series of operations, including checking the Span status and verifying data path connectivity. No specific configurations are necessary for this test, as all required settings were completed during setup.\n\nThis test is triggered by hardware events.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"SpanApBase.get_process_list(SpanApBase.zap, 'test_erspan_hw_trigger')\"",
                "Pass/Fail Criteria": "Erspan hw trigger verification is performed.\nSpan status and reachability via ping verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flex erspan subinterface physical bundle",
                "Procedure": "This test checks Erspan functionality on a subinterface without a port level. It performs several operations, including checking that Erspan works correctly on both physical and bundle subinterfaces, as well as monitoring data traffic. No specific configurations are needed for this test, as all necessary settings were handled during the setup process.\n\nThis test is triggered by testing Erspan functionality on a subinterface without a port level.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic check verification is performed.\nerspan is able to monitor with span verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel",
                "Procedure": "The network is set up to use a GREv6 tunnel, which involves checking the mirroring session's destination as a GRE tunnel and also configuring it with -span as the destination in a v6 format.\n\nThis test is triggered by checking if the configuration is correct for using a GREv6 tunnel.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel remove add",
                "Procedure": "The test verifies that adding or removing a bundle member and a tunnel interface from an ERSpan GREv6 tunnel works correctly.\n\nThis test is triggered by a configuration with the spanning destination set to a v6 tunnel.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel shut noshut",
                "Procedure": "ERSpan GREv6 tunnels are tested to ensure they function properly even when the shutdown command is issued on a source interface.\n\nThis test is triggered by the ERSpan GREv6 tunnel configuration with the span destination configured as a v6 tunnel.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nMonitor session status internal verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel span acl",
                "Procedure": "To test ERSpan GREv6 tunnel with a Span ACL in the source interface for both IPv4 and IPv6 traffic, you must first configure a Span and then set up a Security ACL. Once these configurations are in place, verify that both IPv4 and IPv6 data traffic can pass through.\n\nThis test is triggered by configuring a Span and setting up a Security ACL, which allows IPv4 and IPv6 traffic to be monitored with the ERSpan GREv6 tunnel enabled.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel security acl",
                "Procedure": "ERSPAN GREV6 tunnel with security ACL in source interface is configured to handle both IPv4 and IPv6 traffic. This test case verifies the functionality of ERSPAN GREV6 with a security ACL on the source interface for both v4 and v6 data traffic.\n\nThis test is triggered by configuring a SPAN (Switched Port Analyzer) that includes a security ACL (Access Control List) on the source interface, which enables it to handle IPv4 and IPv6 traffic.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel span and security acl",
                "Procedure": "A test case is designed to verify the functionality of an Ethernet Remote Switched Port Analyzer (ERSPAN) GREv6 tunnel with a Source Interface (Source INTF) having both IPv4 and IPv6 traffic. The configuration involves setting up a Span, configuring a Security Access Control List (ACL), and checking for IPv4/IPv6 data traffic. \n\nThis test is triggered by the existence of a Span ACL in a source interface handling both v4 & v6 traffic.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 with subinterface",
                "Procedure": "ERSpan GREv6 tunnels can be tested using a specific configuration, which includes setting the destination as a v6 tunnel and checking the ERSpan GREv6 tunnel with subinterface source. This test is triggered by the span destination being set to a v6 tunnel in the configurations.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nMonitor session status internal verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel change tos ttl param sequence number verification",
                "Procedure": "Testers spanned GREv6 tunnels after verifying changes in ToS (Type of Service) and TTL (Time-To-Live) sequence numbers. The configurations included setting the destination as a v6 tunnel.\n\nThis test is triggered by configuring the span destination as a v6 tunnel.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 process restart",
                "Procedure": "When testing a GREv6 tunnel after a process has restarted, it's essential to check if the mirroring session is properly configured. This test is triggered by checking for a mirroring session destination set up through a GRE (Generic Routing Encapsulation) protocol with the capability to handle IPv6 traffic and the process restart functionality. The configuration involves setting the destination as a v6 tunnel.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"tunl_gre_ea\" and \"span_ma\" and \"span_mgr\" and \"span_ea\"",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 remove readd monitor session",
                "Procedure": "The test to remove a redundant monitor session from an GRE (Generic Routing Encapsulation) tunnel with IPv6 support is triggered by the fact that there's a mirroring session configured for the destination of the tunnel, which is using the same GRE setup but without redundancy.\n\nThis test is triggered by the presence of a mirroring session for the tunnel's destination using a similar GRE configuration without redundancy.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 hw trigger",
                "Procedure": "The test involves checking the Erspan status beforehand, performing various checks to ensure its functionality is maintained after the trigger. This test is triggered by changes made to the erspan configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_oir\" and \"reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan gre v4 v6 tunnel",
                "Procedure": "When testing spans with v4 and grev6 tunnels, it's necessary to check if the mirroring session destination is set up correctly as a v4 or v6 tunnel. This test is triggered by configurations that specify the span destination either as a v6 tunnel or as a v4 tunnel.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nMonitor session status internal verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 two tunnel same destination interface",
                "Procedure": "When testing two GRE tunnels that share the same destination, it's a good idea to check if there is a mirrored session between them. This test is triggered by verifying whether configurations are set up correctly for both IPv6 and IPv4 destinations in a tunnel-span setup.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 grev4 rpfo cscvy74261",
                "Procedure": "Before triggering the test, check the Erspan status. The test checks if a mirroring session is set up with a v6 to v4 GRE tunnel. After verifying these conditions, it checks that Erspan functions as expected.\n\nThis test is triggered by a configuration where there's an active mirroring session using a v6 to v4 GRE tunnel.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"rpfo\"",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel nexthop bundle",
                "Procedure": "The test targets a GREv6 tunnel with next-hop as bundle, and also checks the mirroring session destination as a GRE tunnel with next-hop as bundle. The relevant configurations include specifying the span destination as a V6 tunnel.\n\nThis test is triggered by checking for mirror session destination as GRE tunnel with nexthop as bundle in configurations that specify -span destination as v6 tunnel.",
                "Pass/Fail Criteria": "Monitor session status internal verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel nexthop phy",
                "Procedure": "The test checks if a tunnel is being spanned by a GRE (Generic Routing Encapsulation) protocol with a next-hop that is physical, and also verifies the mirroring session destination for a GRE tunnel with a next-hop that is physical. This test is triggered by configurations where the span destination is set as a v6 tunnel.",
                "Pass/Fail Criteria": "Monitor session status internal verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 nexthop tunnel ttl tos src dest changes",
                "Procedure": "To test a GREv6 tunnel with a next hop bundle, you can change the tunnel's TOS (Type of Service), TTL (Time To Live), source address, and destination address. This process also checks for mirroring session destinations that are set up as GRE tunnels with next hop bundles by changing those same parameters. Configurations for this test include setting the span destination as a v6 tunnel.\n\nThis test is triggered by configurations where the span destination is set as a v6 tunnel.",
                "Pass/Fail Criteria": "Monitor session status internal verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel nexthop commit replace",
                "Procedure": "To test a GREv6 tunnel with commit-replace, we first check if there's a mirroring session destination that matches the configuration of a GRE tunnel with commit-replace. The configuration includes specifying the destination as a v6 tunnel.\n\nThis test is triggered by the presence of a mirror-session-destination matching a GRE-v6 tunnel with commit-replace configuration and destination specified as a v6 tunnel.",
                "Pass/Fail Criteria": "Monitor session status internal verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan grev6 tunnel nexthop bundle dynamic",
                "Procedure": "The test checks a GREv6 tunnel with a next-hop address resolved dynamically, and also verifies the configuration of a mirroring session that uses a GRE tunnel with a next-hop address resolved dynamically.\n\nThis test is triggered by verifying the configurations for a GREv6 tunnel with a destination as a V6 tunnel, OSPFv3.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMonitor session status internal verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nSpan traffic verification . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl",
                "Procedure": "The test verifies that a spanning access control list (ACL) in the source interface correctly filters both IPv4 and IPv6 traffic. This test is triggered by configuring span ACL with different ACEs such as protocol-specific rules for IPv4, IPv6, TCP, UDP, ICMP, IGMP, and PIM, and then checking that data traffic is appropriately blocked or allowed according to these configurations.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl remove readd monitor session cscvu20260",
                "Procedure": "Span access control lists (ACLs) are verified by monitoring session globally. To accomplish this, the following steps are taken. First, a global SPAN configuration is set up. Next, span and security ACLs are configured to check both IPv4 and IPv6 data traffic. The test verifies that these configurations work correctly.\n\nThis test is triggered by CSCvu20260.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl atomic replacement",
                "Procedure": "To verify span acl in after atomic replacement of span acl, the test procedures include configuring span, setting up span and security ACL, and checking both IPv4 and IPv6 data traffic. Additionally, the configurations involve setting global SPAN parameters and defining ACL rules.\n\nThis test is triggered by changes made to the Span Access Control List (ACL) during an atomic replacement operation.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl inplace modification",
                "Procedure": "To verify that span ACLs function correctly after an in-place modification, the following test procedure is used. First, configure a global SPAN and ensure that both v4 and v6 data traffic are enabled. Next, apply a security access control list (sec ACL) to the span configuration, along with any other necessary settings. After making these changes, check that the span ACLs are correctly applied to all incoming traffic. This test is triggered by an in-place modification of the span ACL's configuration.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span add remove bundle members cscvu64804 cscvu64813",
                "Procedure": "Span ACL is tested to ensure it functions properly when bundle members are added or removed, particularly in relation to issues described by CSCvu64804 and CSCvu64813. This test is triggered by verifying that span ACL works correctly for both IPv4 and IPv6 data traffic after removing and re-adding bundle members configured under a global SPAN instance, with appropriate security ACLs also set up.\n\nTrigger sentence: This test is triggered by verifying that span ACL works correctly for both IPv4 and IPv6 data traffic after removing and re-adding bundle members configured under a global SPAN instance, with appropriate security ACLs also set up.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span sec acl capture",
                "Procedure": "To test the span access control list (ACL) with a capture keyword, follow these steps after disabling the span ACL. The procedure involves verifying that the span ACL functions correctly when the capture keyword is used. This test is triggered by configuring the system to analyze and monitor network traffic using the Global SPAN feature, then setting up both a standard ACL and a security ACL. The final step involves checking that v4 and v6 data traffic can be filtered as intended through these configurations.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl process restart",
                "Procedure": "When the system undergoes a process restart, it's essential to verify that the Span Access Control List (ACL) function correctly. To test this functionality, first configure Span on the system and then implement a security ACL in conjunction with Span. Afterward, check both IPv4 and IPv6 data traffic to ensure that the ACL is functioning as expected.\n\nThis test is triggered by the system's process restart event.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl scale sf f and sf d cscvu36871 cscvu33415",
                "Procedure": "The test case for testing span Acl with scale is verified when configuring Span, setting up the Span and security Access Control List (ACL), checking both IPv4 and IPv6 data traffic. To accomplish this, the steps include configuring a global Service Provider Network (SPAN) and setting up an Access Control List (ACL). This test is triggered by triggering CSCvu36871 and CSCvu33415 as well as SF-F and SF-D scales in Span ACL.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl scale gb f and gb d",
                "Procedure": "To verify the functionality of span Acl with scale, several test cases need to be performed. The tests involve configuring a global Span and setting up security access control lists (ACLs) for both IPv4 and IPv6 data traffic. Specific configurations are required, including GB-F and GB-D, in addition to CSCvu36871 and CSCvu33415. This test is triggered by the requirement to verify that span Acl with scale functions as expected.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl scale dnx",
                "Procedure": "To test span acl with scale ACE, verify that span acl works correctly with scale ACE. The test procedures are as follows: first, configure the span; second, configure both the span and security access control list (ACL); third, check data traffic for both IPv4 and IPv6 protocols. The configurations required include setting up global Span Port Aggregation Network (SPAN) and configuring an ACL.\n\nThis test is triggered by any data traffic attempting to traverse a network configured with a scale Access Control Entry (ACE).",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl copy",
                "Procedure": "To test the span access control list (ACL) with a copy ACL, we need to verify that it works correctly. This involves several steps: first, configure the Span; then, set up both the Span and security ACL; after that, check the IPv4 and IPv6 data traffic. In terms of configuration, you'll need to set up Global SPAN, followed by configuring an ACL. \n\nThis test is triggered by verifying span acl with copy acl functionality.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl change gre tunnel destination",
                "Procedure": "To verify span acl with change gre tunnel destination, we configure Span and its associated security access control list (sec ACL) to monitor incoming and outgoing IPv4 and IPv6 data traffic. The test procedure involves checking if the configuration is correct by verifying that the span and sec ACL are functioning as intended.\n\nThis test is triggered by configuring a global SPAN with an ACL that allows GRE tunnel destination changes.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl qos",
                "Procedure": "The test case involves verifying the behavior of a network's Quality of Service (QOS) when applied in conjunction with a Security Access Control List (ACL). To set up for this test, first configure Span and QOS, then configure both Span and security ACLs. Next, check that both IPv4 and IPv6 data traffic are properly handled according to these configurations. The network's global Span should be configured as part of the setup, along with a specific Access Control List.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status detail verification is performed.\nShow policy map interface verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl show commands cscvu28715",
                "Procedure": "The test case for verifying span ACL with CLI show access list uses the following configuration: configure a global SPAN, configure an ACL, and then check both IPv4 and IPv6 data traffic. The test span ACL is triggered by configuring a Span on hardware, displaying its details in ingress mode at location CSCvu28715.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl v4 acl v6 traffic cscvu21659",
                "Procedure": "Span ACL tests involve configuring the device to apply a version 4 access control list (ACL) while allowing version 6 traffic to flow, as per CSCvu21659. To test this scenario, follow these steps: Configure Span by setting up global SPAN on the device. Then, configure the span and security ACLs according to your requirements. After that, verify whether the version 4 and version 6 data traffic is flowing correctly through the configured ACL.\n\nThis test is triggered when a version 4 access control list (ACL) is applied while allowing version 6 traffic to flow, as per CSCvu21659.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl acl remove bundle modification cscvu64822",
                "Procedure": "When verifying the functionality of a spanning ACL, it's essential to test the span configuration after removing an ACL and a bundle member with CSCvu64822. To do this, follow these procedures. First, configure Span and apply security access control lists (ACL) in both v4 and v6 formats. Next, configure global Span on all devices involved.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl rpfo cscvu35508",
                "Procedure": "The test spans ACL in after RPFO CSCvu35508, verifying that it functions correctly. This test is triggered by a specific configuration scenario where the global span and access control list (ACL) are configured, and data traffic for both IPv4 and IPv6 protocols is being checked. To accomplish this, the following configurations must be in place: configure global span and configure ACL.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan pcap file seq no verfication cscvu06948",
                "Procedure": "Span ACL testing involves verifying sequence numbers in conjunction with the verification of CSCvu06948. The test process includes configuring a span, setting up a security access control list (ACL), and checking IPv4 and IPv6 data traffic. To perform this test, first configure global switch port analysis protocol (SPAN) and then set up an ACL.\n\nThis test is triggered by configuring Span, setting up the span and sec ACL, and verifying the configuration settings to ensure sequence number verification with CSCvu06948.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan pcap file gre prototype verification cscvx83401 rx",
                "Procedure": "The purpose of this test is to verify ERSpan with GRE protocol verification (CSCvx83401) specifically for RX-only ERSPAN. To achieve this, the following steps must be taken: Configure ERSPAN and check that both v4 and v6 data traffic are being captured. Capture the traffic in question and then inspect it to ensure that the GRE protocol is being correctly processed.\n\nTriggered by: This test case verifies ERSpan with GRE prototype verification (CSCvx83401) for rx-only ERSPAN configurations.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan pcap file gre prototype verification cscvx83401 tx",
                "Procedure": "ERSPAN with GRE prototype verification is a test case that checks the functionality of ERSPAN with GRE protocol. To verify this, first configure ERSPAN and ensure that IPv4 and IPv6 data traffic are flowing through it. Then capture the traffic to check for correct GRE protocol implementation. This test is triggered by configuring Global SPAN.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl lc reload seq no verfication",
                "Procedure": "To verify the Span ACL functionality in after Local Collector (LC) reload with sequence number verification, a test is conducted to ensure that data traffic for both IPv4 and IPv6 protocols can be checked. The test procedures include configuring Span, setting up span and security Access Control Lists (ACL), and verifying that they function as expected. To set up the configuration, the global SPAN must be configured, along with ACL, in order to verify that sequence number verification is functioning correctly after an LC reload.\n\nThis test is triggered by the need to verify the functionality of Span ACL in a system's Local Collector after it has been reloaded and sequence numbers have been verified.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl router reload",
                "Procedure": "To verify that the span access control list (ACL) is working correctly after a router reload, follow these steps. First, configure a Span and a security ACL on the router. Then, ensure that both IPv4 and IPv6 data traffic can be properly monitored by checking for incoming and outgoing packets in each direction. The router should also have Global SPAN configured to capture all relevant network traffic.\n\nThis test is triggered by configuring a Span and an access control list (ACL) on the router, then checking for inbound and outbound data traffic for both IPv4 and IPv6 protocols after a router reload.",
                "Pass/Fail Criteria": "Monitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf bundle physical tx dnx",
                "Procedure": "The testcase verifies the non-default functionality of the erspan configuration using a bundle/physical source interface for transmitting data on a DNX. This test is triggered by configuring the span, verifying ERSpan VRF configurations, and setting up necessary configurations such as the ERSpan config.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf bundle physical",
                "Procedure": "The testcase verifies the non-default functionality of erspan using a bundle/physical source interface. The test performs several operations, including configuring the span and verifying the erspan VRF (Virtual Routing and Forwarding) configuration. The test configurations include setting up an erspan configuration.\n\nThis test is triggered by the need to verify that erspan operates correctly in non-default scenarios with a bundle or physical source interface.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf bundle physical sub",
                "Procedure": "The testcase verifies the non-default functionality of the erspan on a device that has a bundle/physical subsource interface. The test performs several operations, including configuring span and verifying erspan VRF configuration. ERSpan is configured with specific settings.\n\nThis test is triggered by performing the standard ERSpan configurations: erspan config.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf src with triggers",
                "Procedure": "The testcase verifies non-default ERSpan functionality with various High Availability (HA) triggers. To perform this test, the following operations are conducted: configurations for ERSpan are set up, and then a span is verified within a Virtual Routing and Forwarding (VRF) context. This test is triggered by the different HA triggers associated with non-default ERSpan functionality.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"lc_oir\" and \"rpfo\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf src with process restart",
                "Procedure": "The testcase verifies the non-default functionality of erspan with different process restarts. It performs a series of operations, including configuring span and verifying that span is enabled on a VRF. The configurations for this test include setting up an erspan configuration.\n\nThis test is triggered by the need to verify the non-default behavior of erspan during process restarts.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"tunl_gre_ea\" and \"span_ma\" and \"span_mgr\" and \"span_ea\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf stress",
                "Procedure": "The testcase verifies the non-default functionality of erspan under stress conditions. The test performs several key operations, including configuring a span and verifying an erspan VRF. This test is triggered by the erspan configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"gre_int_shut_noshut\" and \"remove_rollback_interface_ms\" and \"remove_rollback_gre_tunnel\" and \"remove_rollback_ms\" and \"remove_rollback_vrf\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf src in same vrf",
                "Procedure": "The testcase verifies that non-default ERSpan functionality works correctly when using the source interface within the same VRF. To do this, it performs two key operations: first, it configures a Span; second, it checks to see if the ERSpan configuration is working as expected within the specified VRF. This test is triggered by the configuration of an ERSpan with a src interface in the same VRF.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf src in diff vrf",
                "Procedure": "The testcase verifies non-default ERSpan functionality using the source interface in different VRFs. It performs several operations, including configuring SPAN and checking ERSpan configurations within a specific VRF. The following configurations are used: ERSpan is configured.\n\nThis test is triggered by the requirement to verify that the system can handle ERSpan non-default scenarios with the src interface across various VRFs.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf bundle physical grev4 grev6",
                "Procedure": "The testcase verifies non-default ERSpan functionality using a physical source interface with GREv4 and GREv6 tunnels, performing the following operations: it configures Span and verifies ERSPan VRF. This test is triggered by an ERSpan configuration.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf bundle physical stress",
                "Procedure": "The testcase verifies the non-default functionality of erspan using GREv4 and v6 tunnel add/remove VRF. The test performs several key operations, including configuring a span and verifying the ERSpan VRF configuration. \n\nThis test is triggered by the necessity to verify the functionality of erspan in various network configurations.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan vrf grev4 grev6 multiple vrf",
                "Procedure": "The testcase verifies the non-default functionality of ERSpan with both v4 and v6 tunnels, as well as bundle/physical source interfaces in different VRFs. The test performs a series of operations: it configures Span, then verifies the ERSpan VRF configurations. \n\nThis test is triggered by an ERSpan configuration.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev4",
                "Procedure": "The testcase verifies the ERSpan functionality with MPLS using a physical or bundle source interface over GREv4. To perform this test, the following steps are taken: configuring span and setting up configurations for ERSpan. This test is triggered by configuring an ERSpan configuration.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical sub grev4",
                "Procedure": "The testcase verifies the erspan function with MPLS capabilities on a bundle or physical subsource interface using GREv4. This test is triggered by performing configurations such as configuring SPAN and setting up an ERSpan configuration. \n\nTrigger sentence: This test is triggered by performing configurations, including the setup of Span and the configuration of ERSpan.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev6",
                "Procedure": "The testcase verifies that ERSPAN works correctly with MPLS functionality, specifically when using a physical or bundle source interface and GREv6 tunnel. It performs two key configurations: configuring ERSPAN and setting up various configurations.\n\nThis test is triggered by the need to verify the interoperability of ERSPAN with MPLS in network environments.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical sub grev6",
                "Procedure": "The testcase verifies the erspan feature in conjunction with MPLS functionality, specifically when using a bundle or physical sub-source interface and GREv6 tunnel. The test performs the following steps: it configures the span, which involves setting up various configurations including an erspan configuration. This test is triggered by configuring a source interface that uses a GREv6 tunnel to support Bundle/Physical sub-source interfaces with MPLS functionality enabled.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev4 negative",
                "Procedure": "The testcase verifies ERSpan functionality with MPLS, specifically on a bundle/physical source interface (GREv4), in negative scenarios. It performs several operations including configuring span and verifying monitor sessions, traffic mirroring, and interface accounting. The test repeatedly checks that everything is working as expected, which includes triggering.\n\nThis test is triggered by the need to verify ERSpan functionality with MPLS under certain specific conditions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"gre_int_shut_noshut\" and \"remove_rollback_ms_interface\" and \"remove_rollback_interface_ms\" and \"remove_rollback_gre_tunnel\" and \"remove_rollback_ms\" and \"ms_intf_shut_noshut\" and \"core_intf_shut_noshut\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status , show cef , interface accounting verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev4 mpls triggers",
                "Procedure": "The testcase verifies E-SPAN functionality with MPLS, using a bundle/physical source interface (GREv4), which is triggered by this test being run when MPLS triggers are in effect. The test performs several operations: it configures the span, then verifies that monitoring sessions, traffic mirroring, and interface accounting are all functioning correctly. After performing these verifications, the test repeats them to ensure everything continues to work as expected. Configurations for E-SPAN are also involved.\n\nThis test is triggered by MPLS triggers being in effect.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_rollabck_mpls\" and \"remove_rollabck_int_mpls\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status , show cef , interface accounting verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev6 negative",
                "Procedure": "The testcase verifies the erspan feature in conjunction with MPLS functionality on a bundle or physical source interface within a GREv6 tunnel. It includes a series of configurations, starting with the setup of a Span operation, followed by specific configurations including an ERSpan configuration.\n\nThis test is triggered by Configurations: - erspan config\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"gre_int_shut_noshut\" and \"remove_rollback_ms_interface\" and \"remove_rollback_interface_ms\" and \"remove_rollback_gre_tunnel\" and \"remove_rollback_ms\" and \"ms_intf_shut_noshut\" and \"core_intf_shut_noshut\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev6 mpls triggers",
                "Procedure": "The testcase verifies the ERSpan functionality with MPLS, specifically using a bundle or physical source interface and GREv6 tunnel with MPLS triggers. To perform this test, it first configures Span, followed by various configurations including an ERSpan configuration.\n\nThis test is triggered by configuring ERSpan with MPLS functionality.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"remove_rollabck_mpls\" and \"remove_rollabck_int_mpls\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev4 partial packet",
                "Procedure": "The testcase verifies ERSpan with MPLS functionality, utilizing a bundle or physical source interface GREv4 and involving only partial packet transmission. The test performs two key configurations: it first configures Span, followed by configuring an ERSpan-specific setup.\n\nThis test is triggered by the need to verify that the system functions correctly when using ERSpan with MPLS in conjunction with a bundle or physical source interface GREv4, particularly under conditions of partial packet transmission.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical sub grev4 partial packet",
                "Procedure": "The testcase verifies that ERSpan works correctly with MPLS functionality, using a bundle or physical subsource interface over GREv4. It performs two main operations: first it configures the SPAN, and then sets up the configurations for ERSPan. This test is triggered by a scenario where partial packets are transmitted.\n\nThis test is triggered by a scenario where partial packets are transmitted.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev6 partial packet",
                "Procedure": "The testcase verifies Espan with MPLS functionality using a bundle or physical source interface over a GREv6 tunnel, but only for partial packet testing. To perform this test, the following operations are performed: configuration of Span with partial packet support and setup of the required Espan configurations.\n\nThis test is triggered by configuration of Espan with partial packet support.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical sub grev6 partial packet",
                "Procedure": "The testcase verifies ERSpan functionality with MPLS using a bundle or physical sub-source interface GREv6 tunnel and also checks for partial packet transmission.\n\nThis test is triggered by configuring Span and applying specific configurations including an ERSpan configuration.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev4 ha testcases",
                "Procedure": "The test case verifies ERSPAN functionality with MPLS, specifically using a bundle/physical source interface (GREv4), while also testing HA scenarios. It performs various operations to ensure everything works correctly, including configuring span, verifying monitoring sessions and traffic mirroring, and checking interface accounting. The test is repeated to confirm that all settings are still in place.\n\nThis test is triggered by the following conditions: Configuration of ERSPAN settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"lc_oir\" and \"rpfo\" and \"commit_replace_rollback\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status , show cef , interface accounting verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev4 process restart",
                "Procedure": "The testcase verifies the functionality of MPLS with an erspan configuration, using a bundle/physical source interface (GREv4). It performs several operations to test its stability. These include configuring span, verifying monitoring sessions, traffic mirroring, and interface accounting. Additionally, it restarts the process to check that everything continues working as expected.\n\nThis test is triggered by a configuration of the ERSpan function.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"tunl_gre_ea\" and \"span_ma\" and \"span_mgr\" and \"span_ea\" and \"spp\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status , show cef , interface accounting verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev6 ha testcases",
                "Procedure": "The testcase verifies that MPLS functionality works correctly when using a GREv6 tunnel on a bundle or physical source interface in High Availability (HA) scenarios. It performs the following operations: configuring a span and an ERSpan configuration.\n\nThis test is triggered by configuring a span and the related ERSpan configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"lc_oir\" and \"rpfo\" and \"commit_replace_rollback\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev6 process restart",
                "Procedure": "The testcase verifies ERSpan with MPLS functionality using a bundle or physical source interface over a GRE v6 tunnel, and also performs a process restart. It accomplishes this by configuring Span and performing certain configurations related to ERSpan.\n\nThis test is triggered when an application restarts the process after setting up an ERSpan configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"tunl_gre_ea\" and \"span_ma\" and \"span_mgr\" and \"span_ea\" and \"spp\"",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev6 with mpls traffic",
                "Procedure": "The testcase verifies the erspan function with MPLS functionality, using a bundle or physical source interface over an IPv6 GRE tunnel and transporting MPLS traffic. It performs two main operations: configuring the span and setting up various configurations including the erspan configuration. This test is triggered by the configuration of the required ERSpan settings to ensure that the MPLS functionality works as expected with a GREv6 tunnel.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nTftp read pcap verification is performed.\nspan status with mpls traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls bundle physical grev4 with mpls traffic",
                "Procedure": "The testcase verifies er-span functionality with MPLS, specifically using a bundle or physical source interface and GREv4, while also sending MPLS traffic.\n\nThis test is triggered by configuration of an er-span setup with MPLS and GREv4.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nTftp read pcap verification is performed.\nspan status with mpls traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls with acl grev4",
                "Procedure": "When configuring a spanning interface for access control lists (ACL), it's essential to verify that the ACL is functioning correctly. To test this, configure the Span and ACL on the source interface while allowing both IPv4 and IPv6 traffic to pass through. The verification process involves checking data traffic for both versions of IP. For accurate testing, multiple ACEs should be used with various protocols such as IPv4, IPv6, TCP, UDP, ICMP, IGMP, and PIM configured in the ACL.\n\nThis test is triggered by configuring a Span interface for access control lists (ACL) that include IPv4 and IPv6 traffic.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv4 detail verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls with acl grev6",
                "Procedure": "The test case is designed to verify the functionality of an Ethernet Spanning Tree Protocol (ERSPAN) tunnel that supports both IPv4 and IPv6 traffic, with a Source Interface (Source Intf) configured with an Access Control List (ACL). To accomplish this, the test procedure involves configuring Span, setting up a Security ACL and then testing it with v4/v6 data traffic. This test is triggered by the need to validate that ERSpan GREv6 operates correctly when applied to a Source Interface with both IPv4 and IPv6 traffic subject to Span Access Control List rules.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nCef ipv6 detail verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls physical sub grev4 scale",
                "Procedure": "The testcase verifies erspan with mpls functionality using a physical subsource interface and GREv4, at a scale of 8. It performs two operations: it configures a scaled span, and it sets up several configurations for ERSpan.\n\nThis test is triggered by configuring an ERSPAN configuration.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nCef ipv4 detail verification is performed.\nSpan status verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan mpls physical sub grev6 scale",
                "Procedure": "The testcase verifies that ERSPAN works with MPLS functionality when using a physical sub-source interface and GREv6. The test performs two main operations: configuring a scaled SPAN, and setting up an ERSPAN configuration.\n\nThis test is triggered by the need to verify interoperability between different network components in a large-scale environment.",
                "Pass/Fail Criteria": "Ospf neighbors verification is performed.\nMpls ldp neighbor verification is performed.\nTraffic verification is performed.\nInterface accounting verification is performed.\nCef ipv6 detail verification is performed.\nSpan status verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet bundle physical",
                "Procedure": "The testcase verifies the partial_packet functionality of a erspan with a physical source interface. It performs several configurations, including setting up an erspan configuration. This test is triggered by the need to verify that the partial_packet functionality works as expected with a bundle/physical source interface.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan partial packet bundle physical sub",
                "Procedure": "The testcase verifies the partial packet functionality of the erspan feature using a physical sub-source interface. It performs the following operations: The configuration involves setting up an erspan configuration.\n\nThis test is triggered by the presence of specific configurations, including an erspan configuration being set up.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet bundle physical frame 320",
                "Procedure": "The testcase verifies the partial packet functionality of a bundle/physical source interface with an erspan configuration, specifically with a frame size of 320. It performs several operations including configuring the span and setting up specific erspan configurations.\n\nThis test is triggered by the verification that erspan is configured correctly on the system.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet bundle physical frame 349",
                "Procedure": "The testcase verifies the partial packet functionality of the erspan configuration, which involves a physical source interface and a frame size of 349. The test performs several operations, including configuring the span and setting up an erspan configuration with specific parameters.\n\nThis test is triggered by configuring the span and applying various erspan configurations to verify their effects on the system.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet bundle physical frame 477",
                "Procedure": "The testcase verifies the partial_packet functionality of erspan with a physical source interface, using a frame size of 477. It performs the following operations: configuring span and configuring the erspan configuration. This test is triggered by configuring a bundle/physical source interface for erspan.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan partial packet src with triggers",
                "Procedure": "The testcase verifies the partial packet functionality for Erspan with different High Availability (HA) triggers. The test performs the following operations: it configures a span and sets up an Erspan configuration.\n\nThis test is triggered by various HA events, such as a network partition or a hardware failure.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"lc_oir\" and \"rpfo\" and \"commit_replace_rollback\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan partial packet src with process restart",
                "Procedure": "The testcase verifies the functionality of erspan's partial_packet feature after a process restart by performing several configurations. It starts by setting up the configuration for erspan, which involves multiple settings.\n\nThis test is triggered by an attempt to restart the process while using erspan's partial_packet feature.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"span_ma\" and \"span_mgr\" and \"span_ea\" and \"spp\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan partial packet stress",
                "Procedure": "The testcase verifies the partial packet functionality of erspan in a stressful scenario. It performs several operations, including configuring span and verifying erspan VRF configuration. The configurations involved include setting up an erspan configuration.\n\nThis test is triggered by the need to verify the functionality of erspan under stress conditions, specifically when dealing with partial packets.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"gre_int_shut_noshut\" and \"remove_rollback_interface_ms\" and \"remove_rollback_gre_tunnel\" and \"remove_rollback_ms\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet bundle physical grev6",
                "Procedure": "The testcase verifies the partial packet functionality of erspan using a bundle/physical source interface and a grev6 tunnel. To perform this test, several operations are carried out: Config span is configured, followed by the configurations of erspan.\n\nThis test is triggered by an action that requires configuring a span with specific settings for erspan, including its configuration details.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet bundle physical grev6 frame 320",
                "Procedure": "The testcase verifies the partial_packet functionality of erspan with a bundle/physical source interface and a GRE v6 tunnel, specifically testing frames of size 320. This test performs the following operations: configuring the span and setting up an erspan configuration with specific parameters. \n\nThis test is triggered by the need to verify the functionality of erspan's partial_packet feature in a particular network topology involving GREv6 tunnels and physical interfaces.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet bundle physical grev6 frame 349",
                "Procedure": "The testcase verifies the partial packet functionality of erspan using a physical source interface and a GREv6 tunnel, specifically with a frame size of 349. It performs the following configurations: configuring the span and setting up an erspan configuration.\n\nThis test is triggered by the need to verify the correct operation of erspan's partial packet handling in a specific scenario involving a bundle/physical source interface and a GREv6 tunnel.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet bundle physical grev6 frame 477",
                "Procedure": "The testcase verifies the partial_packet functionality of a erspan configuration using a physical source interface and a grev6 tunnel. The test performs various operations, including configuring a span and setting up an erspan configuration with certain parameters.\n\nThis test is triggered by the configuration of a specific bundle/physical source interface grev6 tunnel with a frame size of 477 bytes.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan partial packet with normal erspan session",
                "Procedure": "The testcase verifies the partial packet truncation functionality of erspan by configuring a span for partial packets and an erspan session, with configurations including an erspan configuration.\n\nThis test is triggered by the need to ensure that erspan can properly handle partial packets in its normal spanning operation.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Setup erspan partial packet bundle physical",
                "Procedure": "The testcase verifies the partial packet functionality of erspan using a bundle/physical source interface. It performs several key operations, including configuring the span and verifying ERSpan VRF configurations.\n\nThis test is triggered by configuration of an erspan config.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status internal verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan rx only phy bun",
                "Procedure": "This test performs checks on an ERSpan device, verifying its ability to monitor both physical and bundle interfaces. The tests cover two main areas of functionality: monitoring a physical interface and monitoring a bundle interface. All necessary configurations are handled before running this test. \n\nTriggered by the need to check if an ERSpan device can handle both types of interfaces simultaneously in order to gauge its overall capabilities.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nspanSource, id: \"(SpanApBase.zap.get_interface('R1_R3_1.R1').name, 0)\" and \"(SpanApBase.zap.get_interface('Bundle-Ether100.R1').name, 1)\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tx only phy bun",
                "Procedure": "The test checks whether the Erspan tool can monitor both physical and bundle interfaces. No additional configurations are needed, as all necessary settings have been established prior to this test.\n\nThis test is triggered by a need to verify that the Erspan tool's functionality for monitoring physical and bundle interfaces is operational.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nspanSource, id: \"(SpanApBase.zap.get_interface('R1_R3_1.R1').name, 1)\" and \"(SpanApBase.zap.get_interface('Bundle-Ether100.R1').name, 0)\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan rx with tx not set phy bun",
                "Procedure": "The test performs a series of checks, including verifying that an ERSpan can monitor both physical interfaces and bundle interfaces. No specific configurations are required for this test, as all necessary settings were completed during the initial setup.\n\nThis test is triggered by attempting to perform operations with an erspan where the transmit (tx) not set phy bun.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nspanSource, id: \"(SpanApBase.zap.get_interface('R1_R3_1.R1').name, 0)\" and \"(SpanApBase.zap.get_interface('Bundle-Ether100.R1').name, 1)\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tx with rx not set phy bun",
                "Procedure": "The test performs two main operations. It checks whether Erspan can monitor a physical interface and also verifies its ability to monitor a bundle interface. All necessary configurations have been completed prior to running this test.\n\nThis test is triggered by the absence of both transmit and receive settings for the PHY bundle unit.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nspanSource, id: \"(SpanApBase.zap.get_interface('R1_R3_1.R1').name, 1)\" and \"(SpanApBase.zap.get_interface('Bundle-Ether100.R1').name, 0)\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan destination rx tx tunnel src phy bun",
                "Procedure": "The test performs two main operations. It checks whether an ERSpan system can monitor a physical interface and whether it can also monitor a bundle interface. No specific configurations are required for this test, as all necessary settings have been taken care of beforehand.\n\nThis test is triggered by the presence of a destination RX/TX tunnel in the erspan destination configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nspanSource: \"SpanApBase.zap.get_interface('R1_R3_1.R1').name\" and \"SpanApBase.zap.get_interface('Bundle-Ether100.R1').name\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger shut no shut destination rx tx tunnel src phy bun",
                "Procedure": "The testers perform several operations. These include checking that ERSpan is capable of monitoring a physical interface and checking that it can also monitor a bundle interface. No additional configurations are necessary as all the required settings were already made during setup. This test is triggered by testing the ability to capture both individual port traffic and aggregated bundle traffic for analysis.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nspanSource: \"SpanApBase.zap.get_interface('R1_R3_1.R1').name\" and \"SpanApBase.zap.get_interface('Bundle-Ether100.R1').name\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger bundle members src bun dest rx tx tunnels",
                "Procedure": "The test performs two operations: it checks if ErSPAN is able to monitor a physical interface, and then checks if it can monitor a bundle interface. This test is triggered by the need to verify that ErSPAN can properly monitor traffic on both physical and bundle interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"shut_no-shut\" and \"remove_readd\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger delete bundle rollback src bun dest rx tx tunnels",
                "Procedure": "The test performs two main operations: it checks whether ERSPAN is capable of monitoring a physical interface and whether it can also monitor a bundle interface. All the necessary configurations are handled during the setup process, so no additional configurations are required for this test.\n\nThis test is triggered by test_erspan_trigger_delete_bundle_rollback_src_bun_dest_rx_tx_tunnels.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger ip change rollback with destination rx tx tunnel src phy bun",
                "Procedure": "The tester performs two checks on ERSPAN's monitoring capabilities: it first verifies that ERSPAN can monitor a physical interface, and then it confirms that ERSPAN can also monitor a bundle interface. All necessary configurations have been completed prior to this test.\n\nThis test is triggered by the change of IP address at the source device in the tunnel Rx/Tx/Source/PHY/BUN.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nspanSource: \"SpanApBase.zap.get_interface('R1_R3_1.R1').name\" and \"SpanApBase.zap.get_interface('Bundle-Ether100.R1').name\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger source interface change rollback with destination rx tx tunnel src phy bun",
                "Procedure": "The test checks if ERSpan is able to monitor both physical interfaces and bundle interfaces. The required configurations were set up prior to this test, so no additional configurations are needed.\n\nThis test is triggered by a change to the ERSpan destination's RX/TX tunnel source interface or PHY/BUN settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nspanSource: \"SpanApBase.zap.get_interface('R1_R3_1.R1').name\" and \"SpanApBase.zap.get_interface('Bundle-Ether100.R1').name\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan proc restart destination rx tx tunnel src phy bun",
                "Procedure": "The test checks if ERSpan is capable of monitoring both physical and bundle interfaces. The required configurations have already been set up, so no further adjustments are needed.\n\nThis test is triggered by the ability to restart the destination Rx/Tx tunnel from the source PHY/BUN.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"span_ea\" and \"span_ma\"\nspanSource: \"SpanApBase.zap.get_interface('R1_R3_1.R1').name\" and \"SpanApBase.zap.get_interface('Bundle-Ether100.R1').name\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger reloads destination rx tx tunnel src phy bun",
                "Procedure": "The test performs several operations. It checks if an erspan instance is able to monitor a physical interface and also verifies its ability to monitor a bundle interface. All required configurations for this test were set up beforehand.\n\nThis test is triggered by the need to verify that an erspan instance can successfully monitor both physical and bundle interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"rpfo\" and \"lc_oir\"\nspanSource: \"SpanApBase.zap.get_interface('R1_R3_1.R1').name\" and \"SpanApBase.zap.get_interface('Bundle-Ether100.R1').name\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan 4 scale destination rx tx tunnel src phy bun",
                "Procedure": "The test performs several operations, including checking if the ERSpan can monitor both physical interfaces and bundle interfaces. No specific configurations are needed for this test, as all necessary settings were completed during the setup process.\n\nThis test is triggered by a need to verify the capabilities of an ERSpan in monitoring network devices.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan 4 scale remove readd session destination rx tx tunnel src phy bun",
                "Procedure": "The test performs two main operations. It checks whether ERSPAN is able to monitor both physical interfaces and bundle interfaces, which are types of network connections. No specific configurations need to be set for this test, as all the necessary settings were applied during the setup process.\n\nThis test is triggered by the removal and re-addition of a session's destination RX/TX tunnel source PHY and BUN.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan 7 scale destination rx tx tunnel src phy bun",
                "Procedure": "The test performs two operations: it checks whether ERSPAN is able to monitor physical interfaces and whether it can also monitor bundle interfaces. The test configurations are minimal, as all necessary settings were established during the setup process.\n\nThis test is triggered by a configuration that includes no specific setup beyond what was completed in the initial setup.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nMonitor_direction: \"rx-only\" and \"tx-only\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nerspan is able to monitor physical and bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main",
                "Procedure": "When testing the span ACL in a four-scale mixed-mode RX L3 BUN main configuration, this test verifies that it works as expected with always-on or on-demand sessions for both IPv4 and IPv6 traffic. To do this, you must first configure Span, then set up the span Access Control List (ACL). Finally, check that data traffic is correctly filtered for both types of IP addresses, ensuring that the configuration includes a global SPAN setting as well as an ACL setup. This test is triggered by configuring Span to trigger on demand or always-on four-scale mixed-mode RX L3 BUN main configurations with IPv4 and IPv6 traffic in mind.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger bundle members on demand or always on four scale mixed mode rx l3 main",
                "Procedure": "A test case is needed to verify that a span ACL works correctly in a four-scale mixed mode RX L3 main configuration, where the monitoring session is set up with either always-on or on-demand access for both IPv4 and IPv6 traffic.\n\nThis test is triggered by: This test is intended to be run when testing the Span ACL functionality under various configurations, specifically those involving mixed mode operation.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"shut_no-shut\" and \"remove_readd\"",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger bundle source interf on demand or always on four scale mixed mode rx l3 bun main",
                "Procedure": "To verify the span ACL with a four-scale monitor session in mixed mode, the following configurations are required. The test starts by configuring global SPAN and then setting up a span ACL. With these configurations in place, the tester checks for both v4 and v6 data traffic to ensure that the span ACL is functioning as expected.\n\nThis test is triggered by the need to verify the functionality of a four-scale monitor session with always on or on-demand capabilities using both IPv4 and IPv6 traffic.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan add ace on demand or always on four scale mixed mode rx l3 main",
                "Procedure": "To verify the span ACL, we need to configure a monitoring session for either always-on or on-demand mode, with four scale mixed mode RX L3 main configuration. This test is triggered by configuring Span and ACL settings, checking both IPv4 and IPv6 data traffic configurations, setting up Global SPAN, and configuring ACL in that order.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan modify acl on demand or always on four scale mixed mode rx l3 main",
                "Procedure": "The test case verifies the functionality of a Span ACL in a four-scale monitoring environment, where sessions are configured to operate either always on or on demand. This test is triggered by configurations involving global Span and ACL setups that allow for the testing of both IPv4 and IPv6 traffic data. To verify correct operation, follow these procedures: configure Span, configure span ACL, and then check for v4/v6 data traffic under the specified configurations.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan remove all acl rollback on demand or always on four scale mixed mode rx l3 main",
                "Procedure": "To verify that a span ACL works correctly in a mixed-mode environment, the following configuration is used. A four-scale monitor session with always-on or on-demand replication is set up, and both IPv4 and IPv6 data traffic are tested to ensure proper forwarding of packets.\n\nThis test is triggered by configuring Span and its related components, including Global SPAN and ACLs.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan modify ipv6 acl on demand or always on four scale mixed mode rx l3 main",
                "Procedure": "To test the modification of IPv6 ACL in a four-scale mixed mode, this test case verifies that the span ACL works as expected with both on-demand and always-on configurations for L3 main. The test procedure involves configuring Span, then configuring a span ACL to monitor traffic from IPv4 and IPv6 sessions. The configuration includes setting up Global SPAN and an Access Control List (ACL) to filter data packets.\n\nThis test is triggered by four-scale mixed mode RX main with v4 and v6 traffic.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan delete readd ipv4 acl  on demand or always on four scale mixed mode rx l3 main",
                "Procedure": "Span access control lists are verified in this test case, which checks how they function when used in conjunction with four scale monitor sessions that are always on or active on demand for both IPv4 and IPv6 traffic. The test procedures involve configuring a Span, setting up an access control list for it, and then checking the data traffic of both IPv4 and IPv6 protocols. This test is triggered by configuring global SPAN and ACL.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 phy main",
                "Procedure": "The test verifies that a network monitor's span ACL works correctly in four-scale mode when used with either always-on or on-demand configurations, and it tests both IPv4 and IPv6 traffic. To perform the test, you need to configure the Span settings, add a span ACL, and check for data traffic from both v4 and v6 addresses. This test is triggered by configuring global SPAN settings and an access control list (ACL).",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger source interface on demand or always on four scale mixed mode rx l3 phy main",
                "Procedure": "The test case verifies the span access control list (ACL) with a four-scale monitoring session for both always-on and on-demand configurations, using IPv4 and IPv6 traffic. The test procedures involve configuring Span, then setting up the span ACL, and checking the data traffic for both v4 and v6 protocols. To trigger this test, it is triggered by Global SPAN being configured and an ACL also being set up.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"shut_no-shut\"",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan add ace on demand or always on four scale mixed mode rx l3 phy main",
                "Procedure": "To verify that span access control lists (ACLs) work correctly, a four-scale monitor session is set up in mixed mode Rx on L3 physical interface. This test case checks the functionality of the ACL with both v4 and v6 traffic. To perform this test, the following steps are followed: Configure Span - Configure span ACL - check v4/v6 data traffic. The configurations required include setting up global SPAN and configuring ACL. This test is triggered by configuring a network scenario to verify that span ACLs function as expected with always-on or on-demand monitoring in both IPv4 and IPv6 environments.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan modify acl on demand or always on four scale mixed mode rx l3 phy main",
                "Procedure": "To verify that a span ACL works correctly, you need to set up the network so that it captures and monitors all relevant traffic. This can be done by configuring both global Span settings and Access Control Lists (ACLs), which dictate what specific types of data get recorded. The test then checks for both IPv4 and IPv6 traffic on the system, ensuring that the span ACL handles both protocols correctly.\n\nThis test is triggered by testing span acl with four scale monitor session of always on or on demand with v4 and v6 traffic.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan remove all acl rollback on demand or always on four scale mixed mode rx l3 phy main",
                "Procedure": "To verify that the span ACL works correctly in a mixed mode environment, follow these steps. First, configure Span and set up a span ACL on your four-scale system. Next, create a monitoring session for always-on or on-demand traffic with both IPv4 and IPv6 data types. Finally, check that the v4 and v6 data traffic is properly configured.\n\nThis test is triggered by: Configuring Span, setting up a span ACL, creating a monitoring session for always-on or on-demand traffic with both IPv4 and IPv6 data types.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan modify ipv6 acl on demand or always on four scale mixed mode rx l3 phy main",
                "Procedure": "The test case for testing span ACL in IPv6 mixed mode involves verifying the functionality of the span ACL with four scale monitoring sessions that are either always on or on demand, and handling both v4 and v6 traffic. To perform this test, the following procedures must be followed: configure Span, configure a span ACL, and check data traffic for both v4 and v6 networks. The configurations required include setting up global SPAN and configuring an ACL.\n\nThis test is triggered by configuration of Global SPAN and configuration of ACL.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan delete readd ipv4 acl  on demand or always on four scale mixed mode rx l3 phy main",
                "Procedure": "To verify span ACL, a global SPAN is configured along with an ACL that monitors both IPv4 and IPv6 traffic. The test then checks for data traffic on all four scale monitor sessions, which can be either always-on or triggered by the configuration of \"This test is triggered by the requirement to test the delete and re-add functionality of IPv4 ACL in four-scale mixed mode RX-L3 PHY main.\"",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun sub main",
                "Procedure": "To verify that the span ACL works correctly, configure a monitoring session with an always-on or on-demand setting for four-scale mode. This test is triggered by verifying that all necessary configurations are in place, including configuring Span, enabling span ACL, and checking traffic of both v4 and v6 data types, as well as setting up global SPAN and ACL configurations.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 phy sub main",
                "Procedure": "The test case verifies the functionality of a span ACL with four scale monitoring sessions in both always-on and on-demand modes, using IPv4 and IPv6 traffic. To perform this test, first configure Span by enabling it globally and setting up the relevant access control lists (ACLs). Then verify that data traffic for both IPv4 and IPv6 addresses is being captured as expected.\n\nThis test is triggered by configuration changes to Global SPAN settings and ACL setup.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger on demand or always on four scale mixed mode rx l3 phy main",
                "Procedure": "The test case is designed to verify the functionality of a span ACL, specifically in the context of four scale monitoring sessions. To accomplish this, the following steps are taken: the Span and span ACL are configured, and then both v4 and v6 data traffic are checked. This test is triggered by configuring Global SPAN and an ACL.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Erspan on demand or always on four scale mixed mode rx l3 phy main verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan process restart on demand or always on four scale mixed mode rx l3 bun main",
                "Procedure": "When testing a network's ability to handle both IPv4 and IPv6 traffic, this test is triggered by the need to verify that a span Access Control List (ACL) works as expected in a four-scale mixed-mode RX/L3 environment. To do this, several steps are followed: first, Span is configured on the device; next, the Span ACL is also set up; then, IPv4 and v6 data traffic is checked to ensure it is being properly handled by the network's configuration, which includes both global SPAN and ACL configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_res: \"span_ea\" and \"span_ma\" and \"span_mgr\"",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan scale on demand or always on eight scale mixed mode rx l3 bun sub main",
                "Procedure": "To verify the span ACL, a test case is run with four scale monitor sessions of always-on or on-demand mode using both IPv4 and IPv6 traffic. The procedures involved are configuring Span, setting up the Span ACL, and checking for data traffic over both IPv4 and IPv6 networks. To perform this test, one needs to configure Global SPAN and set up an Access Control List (ACL) accordingly.\n\nThis test is triggered by configuring a Span, then setting up its corresponding access control list (ACL).",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan scale on demand or always on eight scale mixed mode rx l3 phy sub main",
                "Procedure": "A test case for verifying the span ACL with four scale monitor sessions in mixed mode RX/L3/PHY/submain configurations, which includes both always-on and on-demand settings. The test procedures involve configuring Span, setting up a span ACL, and checking data traffic for v4 and v6 protocols. Configurations include setting up global SPAN and an Access Control List (ACL). This test is triggered by the need to verify the behavior of a network device with a mixed mode RX/L3/PHY/submain configuration under various Span ACL scenarios involving four scale monitor sessions, always-on or on-demand modes for both v4 and v6 traffic.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan scale on demand or always on eight scale mixed mode rx l3 bun phy main",
                "Procedure": "Span Acl Verification for Eight Scale Mixed Mode Rx L3 Bun Sub Main verifies the functionality of Span ACL with four scale monitor sessions, including always on and on demand configurations, when dealing with both IPv4 and IPv6 traffic. To conduct this test, first set up a Span configuration, followed by configuring a span Access Control List (ACL). Next, verify that both IPv4 and IPv6 data traffic are correctly routed. This test is triggered by the fact that it only applies to systems using eight scale mixed mode Rx L3 Bun Sub Main configurations.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main same sec acl",
                "Procedure": "A test case for verifying span ACL is set up in a four-scale mixed mode RX L3 bundle main same sec ACL configuration, where both IPv4 and IPv6 traffic are monitored using always-on or on-demand sessions. To perform the test, the following steps should be taken: configure Span, configure span ACL, and then check data traffic for both IPv4 and IPv6. This test is triggered by configuring Global SPAN and ACL.",
                "Pass/Fail Criteria": "Tftp read pcap verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main dscp bitmask",
                "Procedure": "Span ACLs are verified in this test, which monitors sessions with four scales for both always-on and on-demand modes with V4 and V6 traffic. To conduct the test, follow these procedures: configure Span, configure a Span ACL, and verify that it blocks or allows V4/V6 data traffic accordingly. A Global SPAN is configured, as are any necessary ACLs. This test is triggered by configurations involving DSCP bitmask on main bun for L3 four scale mixed mode RX in always-on or on-demand modes with both IPv4 and IPv6 traffic.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 phy main dscp bitmask",
                "Procedure": "To test the spanning of ACLs, verify that a four-scale monitor session can capture both IPv4 and IPv6 traffic in either always-on or on-demand mode. To do this, first configure Span with ACLs to match specific traffic patterns, then check for data transmission from both v4 and v6 sources.\n\nThis test is triggered by the need to confirm correct ACL spanning functionality in a mixed network environment that includes both IPv4 and IPv6 protocols.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun sub dscp bitmask",
                "Procedure": "When testing the span ACL in a mixed mode RX L3 BUN Sub DSCP bitmask, this test case verifies that it works correctly with four scale monitor sessions of either always-on or on-demand configurations for both IPv4 and IPv6 traffic. To verify this, the test procedures involve configuring Span, setting up span ACLs, and checking data traffic for both versions of IP. The necessary configurations include setting up Global SPAN and configuring ACL.\n\nThis test is triggered by configuring a four scale monitor session in mixed mode RX L3 BUN Sub DSCP bitmask with either always-on or on-demand options for IPv4 and IPv6 traffic.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 phy sub dscp bitmask",
                "Procedure": "Span ACLs are verified in this test case, where a four-scale monitor session is established for both always-on and on-demand modes, with support for IPv4 and IPv6 traffic. The test procedures involve configuring Span, setting up a span Access Control List (ACL), and verifying data traffic for both v4 and v6 protocols. This test is triggered by the configuration of a Global SPAN and an ACL.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan insert ace on demand or always on four scale mixed mode rx l3 bun main dscp bitmask",
                "Procedure": "The test verifies a span ACL with a four-scale monitoring session for both on-demand and always-on modes, using IPv4 and IPv6 traffic. To perform the test, the following procedures must be followed: first, configure Span; second, configure a span Access Control List (ACL); and third, check that IPv4 and IPv6 data traffic is being monitored. The required configurations include setting up Global SPAN and configuring an ACL. This test is triggered by the presence of specific DSCP bitmask values in the main BUN configuration.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan insert ace on demand or always on four scale mixed mode rx l3 phy main dscp bitmask",
                "Procedure": "The test case verifies the span Access Control List (ACL) in a four-scale monitoring session of always on or on-demand with both IPv4 and IPv6 traffic. To do this, follow these steps: Configure Span to monitor all data traffic, then configure a span ACL to filter specific traffic. Finally, set up global SPAN configuration and an ACL with the desired settings.\n\nThis test is triggered by configuring Global SPAN and spanning ACL on four scale mixed mode RX L3 PHY main DSCP bitmask.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan modify ace on demand or always on four scale mixed mode rx l3 phy main dscp bitmask",
                "Procedure": "The test case for span ACL involves verifying the functionality of a four-scale monitoring session for both always-on and on-demand scenarios, using both IPv4 and IPv6 traffic. To conduct this test, one must first configure Span and its associated access control list (ACL), then verify that data traffic from both IPv4 and IPv6 sources is being correctly captured by the ACL. This test is triggered by configuring a Global SPAN and an ACL to monitor all traffic, including both v4 and v6 packets.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan add remove ace on demand or always on four scale mixed mode rx l3 phy main dscp bitmask",
                "Procedure": "When testing the span ACL in mixed mode RX L3 PHY main DSCP bitmask, this test verifies that span ACL is correctly implemented with four scale monitor session of always on or on demand with both IPv4 and IPv6 traffic. To accomplish this, the tester follows these steps: configure Span settings, set up a span ACL to filter specific traffic, check the flow of v4 and v6 data packets, globally enable SPAN, and define an Access Control List (ACL).",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan delete acl on demand or always on four scale mixed mode rx l3 phy main dscp bitmask",
                "Procedure": "A test case for verifying the functionality of a Span ACL in four-scale mixed mode RX L3 PHY main DSCP bitmask configuration is being implemented. This includes configuring Span, setting up a Span ACL, and then testing both v4 and v6 data traffic flows to ensure correct packet handling. The test procedures involve enabling Global SPAN and an ACL for the specified network interface. This test is triggered by a change in the Global SPAN or ACL configuration.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan rem readd next hop on demand or always on four scale mixed mode rx l3 bun main dscp bitmask",
                "Procedure": "The test for spanning tree protocol range readd next hop verifies the span ACL in a four-scale mixed mode rx L3 BUN main DSCP bitmask configuration. This test is triggered by configuring Span, enabling a Span ACL to monitor sessions of always on or on-demand traffic from both IPv4 and IPv6 sources.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan diff dscp bitmask on demand or always on four scale mixed mode rx l3 bun main",
                "Procedure": "Span ACL is verified with a four-scale monitoring session, either always on or on-demand, for both IPv4 and IPv6 traffic. To perform this test, configure Span and its ACL, then verify that IPv4/IPv6 data traffic is being captured correctly. This test is triggered by configuring the Global SPAN and an ACL.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan diff src dst ip on demand or always on four scale mixed mode rx l3 bun main",
                "Procedure": "Span ACL testing involves verifying a monitoring session's behavior in four scale mode, where the configuration can be either always on or on demand. The test checks how both IPv4 and IPv6 data traffic are affected by this setup. To perform the test, one must first configure Span and then configure the span Access Control List (ACL). Next, verify that both IPv4 and IPv6 data traffic is being checked as part of the process.\n\nThis test is triggered by configuring Global SPAN and ACL settings in accordance with the specified requirements.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan v6 on demand or always on four scale mixed mode rx l3 bun main dscp bitmask",
                "Procedure": "SPAN ACL is verified by monitoring sessions of always-on or on-demand mode with both IPv4 and IPv6 traffic. To do this, the test process involves configuring a SPAN (Switched Port Analyzer) session and then checking for both v4 and v6 data traffic, which also requires configuration of Global SPAN and an Access Control List (ACL). This test is triggered by the configuration of Span ACL in mixed mode on four scale monitor sessions with always on or on demand four scale main dscp bitmask.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger on demand or always on four scale mixed mode rx l3 bun main dscp bitmask",
                "Procedure": "To verify span ACL with a four-scale monitor session in mixed mode, the test combines IPv4 and IPv6 traffic. It involves configuring global SPAN, setting up the span ACL, checking for both v4 and v6 data traffic, and monitoring the session on demand or always-on basis. This test is triggered by the configuration of the main DSCP bitmask.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Erspan on demand or always on four scale mixed mode rx l3 bun main dscp bitmask verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on eight scale mixed mode rx l3 bun phy main dscp bitmask",
                "Procedure": "The test verifies span access control lists with four scale monitoring sessions, checking both IPv4 and IPv6 data traffic in mixed mode, L3, BUN PHY, and DSCP bitmask configurations. To trigger this test, the Span is configured to operate in a specific mode, where ACL is enabled on all eight interfaces, and global SPAN and ACL are set up for testing.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main dscp bitmask same sec acl",
                "Procedure": "The test case verifies the Span ACL with a four-scale monitor session using either always-on or on-demand mode for both IPv4 and IPv6 traffic. To accomplish this, it involves several steps: configuring Span, setting up span ACLs, checking IPv4 and IPv6 data traffic, establishing global SPAN configurations, and configuring ACLs. This test is triggered by the combination of an Always On or On Demand monitoring session with a four-scale configuration in Mixed Mode RX L3 BUN MAIN DSCP bitmask same Secondary ACL.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main dscp bitmask diff sec acl",
                "Procedure": "The test case verifies the span ACL in a mixed-mode RX configuration using L3 and BUN main DSCP bitmask difference with secondary ACL, when there are four scale monitor sessions of always-on or on-demand traffic. The test procedures include configuring Span, configuring Span ACL, checking v4/v6 data traffic, configuring Global SPAN, and configuring ACL. This test is triggered by the need to verify span ACL behavior in a mixed-mode RX configuration using L3 and BUN main DSCP bitmask difference with secondary ACL.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main dscp bitmask same sec acl add rem",
                "Procedure": "To verify span access control lists (ACLs) with four-scale monitoring sessions in both always-on and on-demand modes, a test is conducted with IPv4 and IPv6 traffic. The test procedures include configuring the Span feature and the Span ACL, as well as verifying data traffic for both IPv4 and IPv6 protocols. Configurations are set up by enabling Global SPAN and defining the ACL.\n\nThis test is triggered by configuring span access control lists (ACLs) with four-scale monitoring sessions in both always-on and on-demand modes to verify that IPv4 and IPv6 traffic can be handled correctly.",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan process restart on demand or always on four scale mixed mode rx l3 bun main dscp bitmask",
                "Procedure": "The test case verifies the span access control list (ACL) when there are four scale monitor sessions of always on or on demand with both IPv4 and IPv6 traffic. The test procedures involve configuring a Span, configuring a span ACL, and checking data traffic for both v4 and v6. Configurations include global SPAN configuration and ACL configuration.\n\nThis test is triggered by the tester_span_process_restart_on_demand_or_always_on_four_scale_mixed_mode_rx_l3_bun_main_dscp_bitmask parameter.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_res: \"span_ea\" and \"span_ma\" and \"span_mgr\"",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main dnx",
                "Procedure": "To verify the span ACL, a test case is used to check how it handles four scale monitor sessions with always-on or on-demand traffic on a DNX device. This involves several steps and configurations: configuring Span, setting up span ACLs, verifying v4 and v6 data traffic flow, global SPAN configuration, and ACL setup.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 phy main dnx",
                "Procedure": "The test case for spanning on-demand or always-on four-scale mixed mode L3 PHY main DNX verifies the span ACL with a four-scale monitor session of always-on or on-demand, using both IPv4 and IPv6 traffic. To perform this test, you must follow these procedures: configure Span to capture network data; configure a Span Access Control List (ACL) to filter the traffic; and verify that it is successfully filtering v4/v6 data traffic. The necessary configurations include setting up global Span and defining an ACL.\n\nThis test is triggered by configuring Global SPAN and Configure ACL.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan process restart on demand or always on four scale mixed mode rx l3 bun main dnx",
                "Procedure": "To verify the span ACL, this test case configures a DNX system to run in mixed mode RX L3 BUN main with four scale monitoring session on demand or always. With process restart involved, it checks v4 and v6 data traffic against configured Span and ACL settings.\n\nThis test is triggered by configuring Global SPAN and setting up an ACL configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_res: \"span_ea\" and \"span_ma\" and \"span_mgr\" and \"ipv4_acl_mgr\" and \"pfilter_ma\" and \"ifmgr\" and \"ipv6_acl_daemon\" and \"sysdb_mc\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan commit replace on demand or always on four scale mixed mode rx l3 phy main dnx",
                "Procedure": "The span ACL test case verifies the functionality of span ACLs when used in a four-scale monitoring session, where traffic is being transmitted both as IPv4 and IPv6. This test case requires that you first configure the Span and then set up the span Access Control List (ACL). Once these configurations are complete, check for data traffic to ensure that both v4 and v6 packets can pass through. The test case assumes the use of a DNX device with both global SPAN and ACL configured.\n\nThis test is triggered by the requirement to verify the interaction between Span and ACL in a mixed mode scenario involving IPv4 and IPv6 traffic on a four-scale monitoring session with always-on or on-demand configuration.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan trigger on demand or always on four scale mixed mode rx l3 phy main dnx",
                "Procedure": "To verify the span ACL, configure a global SPAN and an ACL to monitor sessions of always-on or on-demand traffic with both IPv4 and IPv6 traffic on a DNX device.\n\nThis test is triggered by a mixed mode Rx L3 PHY main DNX tester span trigger on demand or always on four scale mode.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan interface ms triggers on demand or always on four scale mixed mode rx l3 bun main dnx",
                "Procedure": "The test verifies the span ACL with a four-scale monitor session of always on or on-demand, using both IPv4 and IPv6 traffic on a DNX device with bundle interface/member triggers. To perform this test, the Span must be configured and the span ACL must also be configured. The test procedure involves checking for both v4 and v6 data traffic.\n\nThis test is triggered by configuring Global SPAN and ACL.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"shut_no-shut_members\" and \"remove_readd_members\" and \"remove_readd_intf\" and \"flap_intf\" and \"remove_ms_intf\" and \"remove_readd_tunnel_ip\" and \"remove_global_ms\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main dnx with deny sec acl",
                "Procedure": "A test case for verifying the behavior of a security access control list (ACL) in relation to spanning sessions, particularly those on a four-scale mixed-mode network with Layer 3 bonding and DNX devices. The setup involves configuring global Span, setting up span ACLs to filter traffic based on Layer 4 and higher protocols, then testing v4 and v6 data transmission through the network under normal and on-demand session conditions. This test is triggered by the requirement that the security ACL should deny access for specific security reasons.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on mixed mode rx l3 bun main multiple interfaces scale dnx",
                "Procedure": "The testcase verifies the span ACL with four scale monitor sessions of always-on or on-demand, with both IPv4 and IPv6 traffic, on a DNX device with multiple Bundle Main interfaces. To achieve this, follow these steps: Configure Span; configure span ACLs to control which traffic is spanned; check that both IPv4 and IPv6 data traffic are being monitored. This test is triggered by the configuration of Global SPAN and Access Control Lists (ACL).",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on mixed mode rx l3 phy main multiple interfaces scale dnx",
                "Procedure": "A test case verifies the functionality of a Span Access Control List (ACL) on a DNX device that has multiple physical main interfaces. It checks whether four scaled monitoring sessions can be established in either always-on or on-demand mode, handling both IPv4 and IPv6 traffic. To set this up, the configuration includes: configuring Global SPAN and ACL, checking IPv4/IPv6 data traffic.\n\nThis test is triggered by verifying that a Span ACL functions correctly on a DNX device with multiple physical main interfaces under different scale scenarios.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan remove all acl rollback on demand or always on four scale mixed mode rx l3 bun main dnx",
                "Procedure": "On a DNX system in mixed-mode RX L3 BUN, this test case verifies the span ACL with four scale monitor sessions that are either always on or triggered on demand. The test involves configuring span and span ACL, then checking both v4 and v6 data traffic. This test is triggered by removing all ACLs and rolling back any changes made during testing.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan remove all acl rollback on demand or always on four scale mixed mode rx l3 phy main dnx",
                "Procedure": "On a four-scale mixed mode, the test verifies that the span ACL works as expected when traffic is monitored with either always on or on-demand settings. The test involves configuring global SPAN and an ACL, then checking for both IPv4 and IPv6 data traffic. This test is triggered by removing all ACLs and rolling back the changes to ensure that the functionality remains consistent under different conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan on demand or always on four scale mixed mode rx l3 bun main dnx with permit anyany deny sec",
                "Procedure": "To verify the functionality of a Security Policy (SP) in mixed mode, four different scenarios must be tested: with and without ACLs, and with both IPv4 and IPv6 traffic. This test is triggered by the creation of an L3 Bun Main DNX session with \"always on\" or \"on demand\" settings for Span monitoring. \n\nRewritten trigger sentence:\nThis test is triggered by the creation of an L3 Bun Main DNX session with \"always on\" or \"on demand\" settings for Span monitoring.",
                "Pass/Fail Criteria": "Span status verification is performed.\nMonitor session status detail verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nspan and normal traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop all traps",
                "Procedure": "The test, titled \"test_drop_all_traps\", performs a series of operations including dropping packets collected by the following traps: rxtrapipv4versionerror, rxtrapauthsaportfail (l3 wrong mac), rxtrapipv4checksumerrorr, rxtrapipv4ttl0, rxtrapipv6versionerror, rxtraparpmyip (unknown vlan), and rxtraptrillunknownuc (flooding uc disable). Additionally, it checks whether the span is able to monitor forward dropped packets. The test does not require any specific configurations but rather relies on setup tasks completed beforehand.\n\nThis test is triggered by none of the specified conditions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrap: \"['test_drop_Ipv4VersionError', 'rxtrapipv4versionerror']\" and \"['test_drop_incorrectMAC', 'rxtrapauthsaportfail (l3 wrong mac)']\" and \"['test_drop_Ipv4_ChecksumError', 'rxtrapipv4checksumerror']\" and \"['test_drop_ttl0', 'rxtrapipv4ttl0']\" and \"['test_drop_unknown_vlan', 'rxtraparpmyip (unknown vlan)']\" and \"['test_drop_Ipv6VersionError', 'rxtrapipv6versionerror']\" and \"['test_drop_unknown_ethtype', 'rxtraptrillunknownuc (flooding uc disable)']\" and \"['test_drop_mpls_disabled', 'rxtrapmymacandmplsdisable']\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet no route",
                "Procedure": "The packet_drop_no_route test drops a packet due to a lack of route and checks if it can be monitored by the span to file feature, which allows for tracking forward dropped packets. There are no specific configurations or verifications for this test, and it does not trigger any events.\n\nThis test is triggered by: A packet being dropped with no available route.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop glean adjancency",
                "Procedure": "The test_drop_glean_adjacency test performs two main operations. It first drops a packet due to the inability to rewrite the L2 MAC address, which is necessary for collecting in IPv4 GLEAN. Next, it checks if the span can be written to a file and monitor forward dropped packets. There are no specific configurations required for this test, as all relevant settings should have been done during setup.\n\nThis test is triggered by the inability of the system to rewrite the L2 MAC address.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nspan to file is able to monitor forward drop verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop ttl1",
                "Procedure": "The test drops a packet due to having an IPv4 time-to-live of 1, and checks whether the packets can be monitored by Span to File when they are forwarded and dropped. Configurations required for this test were set up separately. The test verifies that packets being forwarded and dropped can indeed be monitored by Span to File.\n\nThis test is triggered by packets with an IPv4 time-to-live of 1 being dropped due to forwarding.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop acl punt",
                "Procedure": "The test_drop_acl_punt Test Performs the below operations: drops packet due to no packets not matching acl group, checks if span to file is able to monitor forward dropped packets. Configurations are none; all required configuration was done in setup. To verify the functionality, check that span to file can indeed monitor forward drop.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet ipv4 null0",
                "Procedure": "The test involves dropping a packet due to a NULL0 nexthop and collecting it in the ipv4_NULL0 trap, as well as verifying that erspan can monitor forward dropped packets. There are no special configurations required for this test beyond those already set up.\n\nThis test is triggered by the absence of any specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet ipv6 null0",
                "Procedure": "The test performs the following operations: it drops a packet due to a NULL0 nexthop and collects it in an ipv6_NULL0 trap, and also checks whether erspan can monitor forward dropped packets. No specific configuration is required for this test, as all necessary settings have been done beforehand. To verify that this test works correctly, the system must be able to monitor forwarded packets that are being dropped.\n\nThis test is triggered by any situation where a packet is dropped due to a NULL0 nexthop and collected in an ipv6_NULL0 trap.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop bug cscvp63301",
                "Procedure": "When packets with a header length of 0x0 or total length errors hit a Cisco switch, they trigger the checksumerror trap rather than the headerLengthErr trap. This is because of a bug (CSCvp63301), which causes traffic to be directed to the CRC error trap in the BCM FLP instead of the expected header length error trap. The test performs two operations: it drops packets due to these errors and collects them in the checksumerror trap, and then checks that the device's span is able to monitor forward dropped packets.\n \nThis test is triggered by transit traffic or a forwarded packet with its header length set to 0x0 hitting a CRC error trap in the BCM FLP.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrap: \"test_drop_totallength_error\" and \"test_drop_headerlength_error\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nerspan is able to monitor forward drop verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet hw trigger",
                "Procedure": "The test_drop_packet_hw_trigger performs several operations, including configuring before triggering, reloading the router, and calling a forward drop function. Configurations involve setting up SPAN to file, while verifications check the number of packets in the created file. The test triggers on the event of \"router_reload\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\"",
                "Pass/Fail Criteria": "Drop packet no route verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet remove readd monitor session",
                "Procedure": "The test \"test_drop_packet_remove_readd_monitor_session\" performs several operations, including removing and readding monitor session configuration and calling a forward drop function. The configurations for this test include SPAN TO FILE, while the verifications involve checking the number of packets in the file created. This test is triggered by none.",
                "Pass/Fail Criteria": "Drop all traps verification is performed.\nDrop ttl1 verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet process restart",
                "Procedure": "When a packet drop occurs, the test performs a series of operations to ensure system recovery. It restarts the process, checks if a file has been created with information about the dropped packets, and verifies that the correct number of packets have been recorded in this file. The test is designed for scenarios where SPAN (Switched Port Analyzer) traffic is being sent to a file. This test is triggered by a process_restart event.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"span_mgr\" and \"span_ea\" and \"spp\"",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop flap interface",
                "Procedure": "The test performs operations such as checking packet drop with shut/noshut, verifying that ERSpan can monitor forward drops after a flap of the source interface or tunnel interface. Configurations are not required as all necessary settings were done in the setup process. Verifications include checking that ERSPan is able to monitor forward drops on physical and bundle interfaces.\n\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet remove readd tunnel configuration",
                "Procedure": "The test performs the operations of removing and re-adding tunnel configuration, as well as verifying that erspan can monitor forward dropped packets. The required configurations have already been set up, so there are no additional steps needed in this regard. To verify the success of this test, we check if erspan is able to monitor forward drops. This test is triggered by a lack of specific triggers.\n\nTrigger: This test has no specific triggers.",
                "Pass/Fail Criteria": "Drop packet no route verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop change destination",
                "Procedure": "The test performs several operations, including changing the span destination from tunnel to file and back to tunnel, as well as checking if erspan can monitor forward drops. The required configurations are not listed here, but rather were done in a separate setup phase. To verify the functionality of erspan, it is checked on both physical and bundle devices.\n\nThis test is triggered by events that do not have any specific triggers.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nPcapng file verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop tunnel unreachable",
                "Procedure": "The test for a tunnel that cannot be reached performs the following operations: making the tunnel interface unreachable, checking whether erspan can still monitor forwarded packets that are dropped. There are no required configurations beyond what was set up beforehand, and the verification involves ensuring that erspan can monitor forward drops even after the tunnel is made reachable. This test has no specific triggers.\n\nThis test is triggered by none of the usual conditions.",
                "Pass/Fail Criteria": "Shut verification is performed.\nNoshut verification is performed.\nTraffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop span with acl",
                "Procedure": "The ttest_drop_span_with_acl Test performs the following operations: it configures an ACL on a source interface and checks that the Span can monitor forwarded packets being dropped. No additional configurations are required as they were already set up, and the verification is to ensure that ERSPAN can monitor forward drops.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Drop packet no route verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop netflow",
                "Procedure": "The test, known as test_drop_netflow, performs a series of operations including configuring netflow and verifying that a file containing information on dropped packets is being correctly generated. It does this by checking to see if files are being written according to the SPAN TO FILE configuration, and it verifies the number of packets recorded in each file. The test has no specific triggers. This test is triggered by any changes made to the network or system configurations that would cause packets to be dropped.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nFlow monitor name cache format record location verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop ip disabled",
                "Procedure": "The test performs two main operations. First, it disables IP at the source interface, causing incoming packets to be collected in a RxTrapMyMacAndIpDisabled trap instead of being forwarded normally. Second, it checks whether SPAN is able to monitor forward dropped packets. No special configurations are needed for this test, as all required settings have already been taken care of.\n\nThis test is triggered by disabling IP at the source interface.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nerspan is able to monitor forward drop verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop traffic class",
                "Procedure": "The test_drop_traffic_class test performs a series of operations, including configuring a traffic class through a monitor session. The GRE tunnel interface is also configured with a classmap and a policy map to complete the necessary settings.\n\nThis test is triggered by the performance of these specific network configurations within a given setup.",
                "Pass/Fail Criteria": "Span status verification is performed.\nShow policy map interface verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nerspan is able to monitor forward drop verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop erspan mpls",
                "Procedure": "The test, titled \"test_drop_erspan_mpls\", performs a series of operations including configuring MPLS LDP and collecting packets related to MPLS in traps. It also checks if the span is able to monitor forward dropped packets. The necessary configurations are already set up, so none need to be done prior to running this test. To verify its success, the test checks that ERSpan can indeed monitor forward drops.\n\nThis test is triggered by a specific absence of triggers in any previous steps.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrap: \"['test_drop_mpls_unknown_label', 'rxtrapmplsunknownlabel']\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "All stf",
                "Procedure": "The test_all_stf test performs a series of operations, including dropping packets that are collected in various traps, such as rxtrapipv4versionerror and rxtrapauthsaportfail. It also checks if a file is created for forward dropped packets. The configurations include SPAN TO FILE, while the verifications check the number of packets in the file created.\n\nThis test has no specific triggers; it is simply performed periodically to run its operations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrap: \"['test_drop_Ipv4VersionError', 'rxtrapipv4versionerror', '5']\" and \"['test_drop_incorrectMAC', 'rxtrapauthsaportfail (l3 wrong mac)', '4']\" and \"['test_drop_Ipv4_ChecksumError', 'rxtrapipv4checksumerror', '4']\" and \"['test_drop_ttl0', 'rxtrapipv4ttl0', '4']\" and \"['test_drop_Ipv6VersionError', 'rxtrapipv6versionerror', '7']\"",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop acl",
                "Procedure": "The test \"test_drop_acl\" performs several operations, including configuring access control lists (ACLs) on a source interface and checking if files are created for forwarded dropped packets. The test is configured with SPAN to File functionality, which allows it to monitor network traffic and create files for analysis. Verification of the test includes checking the number of packets in the created file. This test is triggered by none specific triggers.",
                "Pass/Fail Criteria": "Drop packet no route verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Spantofile tm drop",
                "Procedure": "The test, known as test_Spantofile_tm_drop, performs a series of operations that simulate the dropping of packets due to spantofile policy and verify whether the spantofile is able to monitor these dropped packets. No special configurations are required for this test, as all necessary setup has already been done. To confirm its functionality, the test verifies that the span-to-file can indeed monitor forward drop events.\n\nThis test is triggered by a lack of specific triggers.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Spantofile tm drop removeadd session",
                "Procedure": "The test performs operations that include dropping a packet due to spantofile and verifying that spantofile can monitor forward dropped packets. Configurations are not required as they were done in the setup phase. Verifications involve checking if span to file is able to monitor forward drop successfully. This test is triggered by none specific triggers.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nPcapng file verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Spantofile tm drop shut noshut interface",
                "Procedure": "The \"test_spantofile_drop_shut_noshut\" performs several operations, including dropping a packet due to spantofile and verifying that the spantofile can monitor forward dropped packets. The required configurations have been set up separately, so there are none listed here. To verify the functionality of the span to file monitoring, it is checked if it is able to monitor forward drops.\n\nThis test is triggered by: None",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Spantofile tm hw trigger",
                "Procedure": "The test \"test_spantofile_drop_reload\" performs several operations, including dropping a packet due to the spantofile and checking if the spantofile can monitor forwarded dropped packets. There are no specific configurations required for this test, as all necessary settings were done in the setup process. To verify its functionality, the test checks that the span to file is able to forward drop packets to the spantofile.\n\nThis test is triggered by none, indicating that it has no specific triggers to initiate it.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nPcapng file verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Spantofile drop packet process restart",
                "Procedure": "The test, known as test_spantofile_prcess_restart, performs several operations to check the functionality of a network packet monitor. It simulates a dropped packet due to a spantofile issue and verifies that the spantofile is able to forward dropped packets for monitoring purposes. No specific configurations are required for this test beyond those set up previously. The verification process involves confirming that the span to file configuration correctly sends drop information to the spantofile.\n\nThis test is triggered by any situation in which a packet is intentionally dropped due to spantofile issues.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"span_mgr\" and \"span_ea\" and \"spp\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nPcapng file verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tm drop policy",
                "Procedure": "The test_drop_policy_tm test performs the operations of dropping a packet due to QoS policy and checking if ERSPAN can monitor forwarded dropped packets. The test configuration requires no additional settings, as all necessary configurations were completed in setup. To verify that ERSPAN is functioning correctly, the test checks if it can monitor forward drops.\n\nThis test is triggered by a situation where there are no specific triggers or conditions required to initiate its execution.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tm drop policy shut noshut interf",
                "Procedure": "The test performs operations that include dropping a packet due to QoS policy and checking if erspan can monitor forward dropped packets. The configurations are not listed, as all necessary settings were done in the setup. To verify the functionality, it's checked whether the tunnel is able to monitor forward drops.\n\nThis test is triggered when there are no specific triggers.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tm drop policy remove add tunnel",
                "Procedure": "The test for removing and re-adding the drop policy performs several operations, including dropping a packet due to QoS policy and verifying that eRSPAN is able to monitor forwarded dropped packets. No specific configurations are required beyond what was set up previously. The verification process includes checking if the tunnel can monitor forward drops. This test is triggered by no specific triggers.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tm drop policy shut noshut tunnel",
                "Procedure": "The test performs the following operations: it drops a packet due to QoS policy, checks if ERSPAN can monitor forwarded dropped packets, and verifies that the tunnel can monitor forward drops. Configurations are set up in the setup process, with no additional configurations required. The test does not have any specific triggers.\n\nThis test is triggered by the normal operation of dropping packets according to the QoS policy.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tm hw trigger",
                "Procedure": "The test performs a series of operations, including dropping a packet due to a QoS policy and checking if erspan can monitor the forwarded dropped packets. The configurations required for this test have already been set up in advance, so there are none listed here. To verify that the test has been successful, we check if the tunnel is able to monitor forward drops. This test is triggered by the absence of any specific triggers.\n\nThis test has no specific triggers.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan tm drop policy add remove session",
                "Procedure": "The test performs the following operations: it drops a packet due to a QoS policy, checks if ERSPAN can monitor forwarded dropped packets, and verifies that ERSPAN can log forward drops. Configurations are not applicable as all required setup is done beforehand. Verifications include ensuring that ERSPAN can monitor forward drop via logging to file. This test is triggered by the removal of a readd session.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan drop packet process restart",
                "Procedure": "The test performs operations that include dropping a packet due to QoS policy and checking if ERSPAN is able to monitor the forwarded dropped packets. No configuration is required for this test, as all necessary settings were completed in setup. To verify that the test was successful, it must be confirmed that ERSPAN can monitor forward drop by verifying its ability to write the information to a file. This test is triggered by none of the specific triggers listed.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"span_mgr\" and \"span_ea\" and \"spp\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet no route always on",
                "Procedure": "The test performs a series of operations, including configuring a span monitor session and verifying its functionality. To facilitate the test, static routes are added for device r2 on router r3, the default route is removed so that packets will be dropped at the interface, traffic is sent to verify the span's ability to collect dropped packets, and fibdrop traps are triggered when a packet drops due to lack of routing information. After verifying that traffic is being mirrored to a file, the test rolls back the previous configuration, truncates the file, and unconfigures the span session.\n\nThis test is triggered by adding static routes for device r2 on router r3, removing the default route so packets drop at the interface, sending traffic to verify span functionality, triggering fibdrop traps when a packet drops due to lack of routing information.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop glean adjancency always on",
                "Procedure": "The test performs a series of operations, including dropping a packet due to an inability to rewrite the Layer 2 MAC address for IPv4 GLEAN collection. It also checks whether a Span can be used to file monitor forward dropped packets. This test is triggered by the test_drop_glean_adjacency_always_on trigger.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nspan to file is able to monitor forward drop verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop acl always on",
                "Procedure": "The test, known as test_drop_acl_always_on, performs several operations. It configures an access control list on a source interface and checks if a file is created or forward dropped packets. The configuration used for this test involves SPAN to file, while the verification step focuses on the number of packets in the file created. This test has no specific triggers.",
                "Pass/Fail Criteria": "Drop packet no route always on verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop acl punt always on",
                "Procedure": "The test performs several operations, including dropping a packet due to it not matching an ACL group and checking that the packet can be monitored by writing to a file. Configurations are minimal, as all necessary setup was completed prior to running the test. Verification involves confirming that packets dropped for no match are correctly captured in the monitoring file.\n\nThis test is triggered by the absence of any specific triggers; it has none.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop ttl1 always on",
                "Procedure": "The test performs the following operations: it drops a packet due to a time to live of 1, checks that a Span to File can be used to monitor forward dropped packets, and verifies that this monitoring setup works as expected.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet remove readd monitor session always on",
                "Procedure": "This test performs several operations, including removing and readding monitor session configuration, calling a forward drop function, and creating a file with packet data. The configurations include SPAN to File, while verifications involve checking the number of packets in the created file.\n\nTrigger: This test is triggered by none specific triggers.",
                "Pass/Fail Criteria": "Drop all traps verification is performed.\nDrop ttl1 always on verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet process restart always on",
                "Procedure": "The test for dropping packets and restarting the process performs several operations, including a process restart, checking if a file has been created with dropped packets, and verifying that the correct number of packets are recorded in the file. The test can be configured to use SPAN TO FILE settings and will trigger a process_restart.\n\nThis test is triggered by when a process_restart occurs.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess: \"span_mgr\" and \"span_ea\" and \"spp\"",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet hw trigger always on",
                "Procedure": "The test performs several operations, including configuring the system before triggering the test and reloading the router. It also calls a forward drop function to drop packets. The configurations include setting up SPAN to write to a file, and the verifications involve checking the number of packets in the created file.\n\nThis test is triggered by \"router_reload\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Drop packet no route always on verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Always on with periodic write",
                "Procedure": "The test performs a series of operations, including configuring a span monitor session with periodic write and verification, adding static routes for the r2 device on r3, removing the default route, sending traffic and verifying span functionality, dropping packets due to lack of routing, rolling back the last config, and verifying that traffic is mirrored to a file. It also truncates the file and unconfigures the span session. The test has no specific triggers.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Remove readd always on with periodic write",
                "Procedure": "The test performs a series of operations, including removing and readding the always-on configuration with periodic write, verifying a span monitor session, adding static routes for an R2 device on R3, removing a default route to cause packets to drop at the interface, sending traffic and verifying span functionality, rolling back the last 1 config, and verifying that traffic is being mirrored to a file. The test then truncates the file and unconfigures the span session. Configurations are not required as part of this test, as they were done in setup, and verifications include ensuring that span-to-file monitoring can track forward drops. This test is triggered by the removal or re-adding of the always-on configuration with periodic write.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mirror first always on",
                "Procedure": "This test performs a series of operations on a network, including configuring a span monitor session with \"mirror first\" enabled and verifying its behavior. It adds static routes for a device named r2 on another device named r3, removes the default route to cause packets to be dropped at the interface, sends traffic and verifies that it is being mirrored by the span, checks for errors in the FIB drop trap, reverts the configuration back to its previous state, and then verifies that the mirrored packets are of a specific length. The test also checks if traffic is being properly mirrored to a file, truncates the file, and unconfigures the span session.",
                "Pass/Fail Criteria": "Mirror first pcapng verification is performed.\nPcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Default session always on",
                "Procedure": "The default session is always on, so the test performs several operations to verify this. It configures a span monitor session with capture disabled set to false, verifies the default session, checks if a span monitor session named \"default monitor session\" exists, and unconfigures the span session.\n\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mirror interval always on",
                "Procedure": "The test_mirror_interval_always_on test performs a series of operations, including configuring a span monitor session with mirror first and verifying it, adding static routes for the r2 device on r3, removing the default route so packets will drop at the interface, sending traffic and verifying the span, dropping packets due to no route in fibdrop trap, rolling back the last 1 config, and verifying that only packet count/interval are mirrored to file. The test involves verifying if the packet count is packet_count/mirror_interval and if the span to file can monitor forward drops. This test performs these operations without any specific triggers.\n\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Periodic capture capacity reached",
                "Procedure": "The test \"test_periodic_capture_capacity_reached\" performs a series of operations, including configuring a span monitor session with local capture capacity and verifying it, adding static routes for the r2 device on r3, removing the default route to drop packets at the interface, clearing loggings, sending traffic, and verifying span. It also checks if show logging has a pattern related to span, drops packets due to lack of route in fibdrop trap, rolls back the last configuration, verifies if traffic is mirrored to file, truncates the file, unconfigures the span session, and repeats the steps without local capture capacity. The test has no specific triggers. This test is triggered by capturing reaching its periodic capacity.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nShow logging verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span manual write drop packet no route",
                "Procedure": "The test performs a series of operations on the network devices, including configuring a span monitor session and verifying its functionality, adding static routes for r2 device on r3, removing the default route so that packets will drop at the interface, sending traffic through the network, and checking if the packet is successfully mirrored to a file. To accomplish this, the test must first add static routes for the r2 device on r3. This test is triggered by a specific set of network conditions or events, but no such triggers have been specified.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nwrite_directory, filename: \"('/harddisk:', 'manual_pcap_write')\" and \"('/harddisk:', None)\" and \"(None, 'manual_pcap_write')\" and \"(None, None)\"",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span manual write drop packet no route without always on",
                "Procedure": "The test performs a series of operations, including configuring a span monitor session without always on and verifying its functionality. It also involves adding static routes for the r2 device on r3, removing the default route so that packets will drop at the interface, sending traffic, and verifying the span's ability to collect dropped packets. The test then rolls back the last configuration change, manually writes a pcap file to a hard disk, verifies if traffic is being mirrored to the file, truncates the file, and unconfigures the span session. \n\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Drop packet no route without periodic write always on",
                "Procedure": "The test performs a series of operations, including configuring a span monitor session without periodic write and verifying it, adding static routes for the r2 device on r3, removing the default route so that packets will drop at the interface, sending traffic, and verifying that span drops packets due to no route in fibdrop trap. The test also includes rolling back the last 1 config, manually writing a pcap file and moving it to hard disk, and verifying if traffic is mirrored to the file. The file is then truncated and the span session unconfigured. No specific triggers are associated with this test.\n\nThis test is triggered by any failure of the span-to-file function to monitor forward drops.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span manual start stop drop packet no route always on",
                "Procedure": "The test performs a series of operations on a network device, including configuring and verifying a span monitor session that sends traffic to a file, adding static routes for a device on another device, removing the default route so that packets are dropped, starting and stopping packet collection manually, and verifying that traffic is mirrored to the file. The test also includes rolling back configuration changes, truncating the file, and unconfiguring the span session.\n\nThis test is triggered by manual start/stop of monitor session packet collection in a scenario where there's no route for the packets to be collected.",
                "Pass/Fail Criteria": "Pcapng file verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "erspan_scale_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Erspan status verification",
                "Procedure": "To verify the ERSPAN monitor session status, we need to configure various settings such as an IP address, a static route, a GRE tunnel, proxy ARP, and the monitor session itself, including the ERSPAN CLI. The configurations involved are ERSPAN and GRE Tunnel, while the verification step involves checking the status of the monitor session. This test is triggered by none.",
                "Pass/Fail Criteria": "Monitor session status verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan scaled monitor session",
                "Procedure": "ERSPAN mirroring on the main interface is verified in this test-case, which involves configuring various settings and then verifying the ERSPAN mirroring with scale on the main interface. These configurations include an IP address, a static route, a GRE tunnel, proxy ARP, a monitor session, and ERSPAN CLI. The testcase ID for these tests is ERSPAN Scale:01 and ERSPAN Scale:02. This test is triggered by none.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan scaled routes",
                "Procedure": "To verify ERSPAN mirroring, the test-case checks a monitor session with scaled routes by configuring an IP address, static route, GRE tunnel, proxy ARP, and monitor session, as well as ERSPAN CLI configurations.\n\nThis test is triggered when scaling ERSPAN to three instances (ERSPAN Scale:03).",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan rate limit scale",
                "Procedure": "The purpose of this test case is to verify the functionality of ERSPAN mirroring with different rate limits. It involves configuring several network settings, including IP addresses, static routes, GRE tunnels, proxy ARP, monitor sessions, ERSPAN CLI, and QoS class maps and policy maps. The configurations include Erspan, Gre Tunnel, and QOS, while the verifications focus on ERSPAN mirroring with a QoS configuration in place. This test case is triggered by any of several specific rate limit values: 01 through 05.",
                "Pass/Fail Criteria": "Show policy map interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Max session sf",
                "Procedure": "The configuration process involves configuring the IP address, sub-interfaces, static route, GRE tunnel, proxy ARP, and ERSPAN CLI settings. The configurations include ERSPAN and GRE Tunnel settings. To verify ERSPAN mirroring with 16 sessions, monitor session status and check for ERSPAN mirroring on max sessions are performed. This test is triggered by LC Reload.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nNoshut verification is performed.\nSpan status verification is performed.\nErspan tunnel arp status verification is performed.\nMonitor session status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Four or eight session sf",
                "Procedure": "The test case verifies ERSPAN mirroring with a maximum of four or eight sessions, specifically for small form-factor (SF) configurations. The test involves configuring the necessary settings, including IP addresses, sub-interfaces, static routes, GRE tunnels, proxy ARP, and monitor sessions, as well as enabling ERSPAN CLI. The required configurations include Erspan and GRE Tunnel setups, with verifications focusing on the status of the monitor session and ERSPAN mirroring for maximum sessions.\n\nThis test is triggered by the need to scale ERSPAN to its maximum capacity.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan vrf",
                "Procedure": "The following paragraph verifies ERSPAN non default VRF mirroring with 4 or 8 sessions for Security Firewall (SF). The test-case checks if ERSPAN mirroring works correctly when the maximum number of sessions is reached.\n\nThis test is triggered by configuring a network device to have a Virtual Routing and Forwarding instance, setting up a Generic Routing Encapsulation tunnel, establishing a monitor session, and enabling ERSPAN on the command line interface.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status verification is performed.\nSpan status verification is performed.\nMonitor session status internal verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Four or eight session mirror first",
                "Procedure": "The test verifies ERSPAN partial packet mirroring with a maximum of 4 or 8 sessions on SF. It involves configuring IP address, sub-interfaces, static routes, GRE tunnels, proxy ARP, monitor sessions, and the ERSPAN CLI. The configurations include ERSPAN and GRE Tunnel settings. Verifications include checking the status of the monitor session and confirming that ERSPAN mirroring is enabled for the maximum number of sessions.\n\nThis test is triggered by verifying the scale of an ERSPAN configuration, specifically tests -ERSPAN Scale:06, -ERSPAN Scale:07, or -ERSPAN Scale:08.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan vrf dnx",
                "Procedure": "The test verifies ERSPAN non-default VRF mirroring with four sessions on a DNx device. It configures the VRF and GRE tunnel, as well as the monitor session and ERSPAN CLI. The verification involves checking the status of the monitor session and ensuring that ERSPAN mirroring is functioning for the maximum number of sessions allowed.\n\nThis test is triggered by non-default ERSPAN configurations being applied to a DNx device with multiple VRFs enabled.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTftp read pcap verification is performed.\nMonitor session status verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "span_local_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Session status source l3 dest l2 up",
                "Procedure": "The test, designated as SPAN:CLI:001, verifies the status of a monitor session where both the source and destination interfaces are operational on L2 and L3 levels. The test configurations include setting up physical or bundle main/sub interfaces at both layers, as well as configuring Span CLI. To verify the success of this configuration, the test checks for the correct status of the monitor session and the state of the source and destination interfaces.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify span ip registeration cli",
                "Procedure": "The test-case, test_verify_span_ip_registeration_cli, verifies the span ip registration cli functionality. The configuration involves setting up L2/L3 physical/bundle main/sub interfaces and configuring the Span CLI. The test checks for configurations related to SPAN and verifications that include span ip registration cli. \n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Span ip registration verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Session status dest intf down",
                "Procedure": "When the destination interface is down, this test case verifies the monitor session status. The test configures Layer 2 and 3 physical or bundle main and sub interfaces, as well as sets up a Span CLI configuration with SPAN configurations in place. To verify the test results, the monitor session status is checked. This test is triggered by no specific events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Session status source and dest intf down",
                "Procedure": "The test verifies the monitor session status when both the source and destination interfaces are down, simulating a network failure scenario where communication between the two is interrupted. The test environment consists of an L2 or L3 physical or bundle main or sub interface, as well as a Span CLI configuration with SPAN settings applied. During execution, the system verifies the monitor session status through various checks. This test is triggered by the absence of any external triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Session status source intf down",
                "Procedure": "A test case verifies the monitor session status with a source interface down. To accomplish this, it configures Layer 2 or 3 physical or bundle main and sub interfaces, as well as sets up a span CLI configuration for SPAN. The configurations include SPAN settings. The verifications involve checking the monitor session status. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cscvs97675",
                "Procedure": "The test verifies that ASIC error counts are accurate before and after enabling the monitor session in the interface. The test configures the ASIC error CLI, then enables the monitor session using the interface CLI, and finally reconfigures the ASIC error CLI again. Configurations include setting up the ASIC error monitoring and details of the monitor session. Verification checks that when the monitor-session is enabled on an NCS-55A1-24H device, both generic and configuration ASIC errors are counted correctly.\n\nThis test is triggered by a defect ID of CSCvs97675.",
                "Pass/Fail Criteria": "Asic errors verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask",
                "Procedure": "Traffic with spans and source and destination as Layer 3 physical interfaces for IPv4 packets in the receive direction with an Access Control List configured on the interface without the \"acl\" keyword is verified. The configuration involves setting the Layer 3 physical main interface as both the source and destination, configuring the Layer 3 interface as a mirror destination, enabling the Span CLI, configuring OSPF, and setting up IPv4 ACLs with DSCP and bitmask configurations. Configurations include Span, OSPF, and ACL settings are used. The verification checks traffic with monitor sessions on physical Layer 3 interfaces.\n\nThis test is triggered by none.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ndscp: \"SpanLocalApBase.zap.get_testcase_configuration()['TestSpan_acl_dscp_bitmask']['test_span_with_acl_dscp_bitmask']['dscp_all_val']\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l3 phy main l2 mirror rx v4 with acl dscp bitmask",
                "Procedure": "Traffic is verified with a span source set as the Layer 3 physical interface and destination as the Layer 2 main interface for IPv4 traffic, received in the rx direction without an ACL keyword on the interface. The test case verifies traffic with span and source as the Layer 3 physical interface and Layer 2 physical interface as the mirror interface. Configurations include setting up the Layer 3 physical main as both source and destination, setting up Layer 2 as a mirror destination, configuring the SPAN CLI, OSPF, and IPv4 ACLs with DSCP and bitmask settings. Verification checks involve monitoring traffic on the physical Layer 2 interface with an active monitor session.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l3 bun main l2 mirror rx v4 with acl dscp bitmask",
                "Procedure": "L3 bundle interfaces are configured as source, while L3 phy main interface is set as destination. Additionally, the L2 interface is used for mirroring the destination. The SPAN CLI is configured to monitor traffic on a physical L2 interface. OSPF and IPv4 ACLs with DSCP and bitmask configurations are also in place. Traffic is verified with a monitor session on the physical L2 interface.\n\nThis test is triggered by no specific events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 bun main l3 main mirror rx v4 with acl dscp bitmask",
                "Procedure": "The test verifies traffic with a span source as a bundle interface and mirror as an L3 physical interface, for IPv4 traffic in the RX direction with an ACL on the interface without an acl keyword. It configures L3 bundles as main L3 phy main destinations, sets up OSPF and IPv4 ACLs with DSCP and bitmask configurations.\n\nThis test is triggered by the absence of any conditions or events that would necessitate its execution.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l3 bun main l3 main mirror rx v4 with acl dscp bitmask rem add bun members",
                "Procedure": "Traffic with a source interface as an L3 bundle and a mirror interface as a physical L3 interface for IPv4 traffic in the receive direction is verified. The configuration includes configuring an L3 bundle as the source interface, a physical L3 interface as the destination interface, an L3 main interface as the mirror destination interface, setting up SPAN, OSPF, and an IPv4 ACL with DSCP and bitmask remapping.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask add ace",
                "Procedure": "Traffic is verified with a span configuration where the source and destination are Layer 3 physical interfaces for IPv4 traffic in the receive direction, with an access control list enabled on the interface without explicitly specifying the ACL keyword. The setup includes configuring the Layer 3 physical main interface as both source and destination, creating a mirror interface, setting up OSPF, and defining an IPv4 ACL that applies to DSCP and bitmask values. Verification involves checking for traffic monitored by a session on the physical Layer 3 interfaces. This test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask modify ace",
                "Procedure": "The test case verifies IPv4 traffic sent in the receive direction through a Layer 3 physical interface, where an Access Control List (ACL) is configured to modify the DSCP and bitmask. The configurations include setting up SPAN, OSPF, and the ACL with DSCP and bitmask modifications. To verify the test case, traffic is monitored on the physical Layer 3 interface while a monitor session is active.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask del ace",
                "Procedure": "Traffic is verified with a Span (Switched Port Analyzer) configuration where the source and destination are Layer 3 physical interfaces for IPv4 traffic received in the rx direction, with an ACL (Access Control List) applied to the interface but not explicitly referenced as such. The test-case checks that this configuration allows traffic to pass through when a monitor session is established on the physical L3 interface. It involves configuring a physical main interface as source, destination, and mirror interfaces, setting up OSPF, applying an IPv4 ACL with DSCP (Differentiated Services Code Point) and bitmask settings, and using SPAN, OSPF, and ACL configurations to verify traffic flow. This test is triggered by the absence of any specific conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask del acl",
                "Procedure": "Traffic is verified between a Layer 3 physical interface and its mirrored interfaces in an IPv4 network. The setup includes configuring the main interface as both source and destination, creating a mirror session using the SPAN CLI, enabling OSPF routing, and configuring an ACL with DSCP and bitmask settings. The test also verifies that traffic can be monitored on the physical Layer 3 interface when a monitor session is created.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span security source dest l3 phy main rx v4 with same acl dscp bitmask",
                "Procedure": "Traffic with spanning and security configurations verifies the flow of IPv4 packets from a Layer 3 physical interface to another interface with the same access control list (ACL) in place. The setup includes configuring the main Layer 3 physical interface as both the source and destination, along with mirroring interfaces and OSPF routing. Additionally, an ACL is configured to include DSCP and bitmask rules. To verify this setup, traffic monitoring on a physical Layer 3 interface is checked, but no specific triggers are involved.\n\nThis test is triggered by the absence of any conditions or specific events that need to occur for the test to run.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span security source dest l3 phy main rx v4 with diff acl dscp bitmask",
                "Procedure": "Traffic from Layer 3 physical interfaces for IPv4 traffic in the receive direction is verified with source and destination set to l3 phy main, and security features enabled with different ACLs. The configuration includes setting up l3 phy main as both source and destination interfaces, mirror interfaces, OSPF, and an IPv4 ACL with DSCP and bitmask settings. This test verifies that traffic with a monitor session on the physical L3 interface is allowed through.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span security source dest l3 phy main rx v4 with diff acl dscp bitmask add rem",
                "Procedure": "Traffic is verified with a span that monitors the source and destination as L3 physical interfaces for IPv4 traffic in the receive direction when an ACL is applied to the interface, but without the \"acl\" keyword. The test case also verifies traffic with the addition and deletion of security ACLs along with span ACLs. To set up the test, Layer 3 physical main interfaces are configured as source, destination, and mirror interfaces, and the Span CLI is configured. Additionally, OSPF and IPv4 ACLs with DSCP and bitmask settings are configured. The configurations include SPAN, OSPF, and ACL settings. Verifications involve monitoring traffic on a physical L3 interface with a monitor session in place.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask add rem nexthop",
                "Procedure": "The test case verifies IPv4 traffic with a span configuration that uses the l3 physical interface as both source and destination, without specifying an ACL keyword on the interface. Configurations include setting up the l3 phy main interface as the source, destination, and mirror interfaces, configuring OSPF, and implementing an IPv4 ACL with DSCP and bitmask settings. Verifications involve checking traffic with a monitor session enabled on the physical l3 interface.\n\nThis test is triggered by no specific events or conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask diff dst ip",
                "Procedure": "Traffic verification is performed for IPv4 packets traversing an L3 physical interface in the RX direction, where an Access Control List (ACL) is configured without explicitly specifying the ACL keyword. The setup includes configuring L2/L3 main/sub interfaces and their bundles, spanning CLI commands, OSPF protocol, and an IPv4 ACL with DSCP and bitmask settings. Key configurations involve setting up SPAN, OSPF, and ACLs, while verification focuses on monitoring sessions for physical L3 traffic.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v6 with acl dscp bitmask",
                "Procedure": "Traffic is verified with a span and source and destination set as the Layer 3 physical interface for IPv6 traffic and receive direction with an access control list enabled on the interface without specifying the ACL keyword.\n\nThis test is triggered by none.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ndscp: \"SpanLocalApBase.zap.get_testcase_configuration()['TestSpan_acl_dscp_bitmask']['test_span_with_acl_dscp_bitmask']['dscp_all_val']\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l3 phy main l2 mirror rx v6 with acl dscp bitmask",
                "Procedure": "The test verifies v6 traffic with span and source as a Layer 3 physical interface connected to the L2 main interface, which serves as the mirror interface for receive direction traffic. It involves configuring the Layer 3 physical main interface as both the source and destination, and the L2 main interface as the mirror interface. Additionally, the test sets up the Span CLI configuration, enables OSPF routing, and configures IPv6 ACLs with DSCP and bitmask specifications. The test configurations include SPAN, OSPF, and ACL settings. Verification involves checking for traffic on a physical Layer 2 interface with a monitor session configured.\n\nThis test is triggered by: None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main tx rx v6 with acl dscp bitmask add ace",
                "Procedure": "The test-case verifies traffic with span and source and destination as L3 physical interface for IPv6 traffic in the RX direction, with an Access Control List (ACL) applied to the interface without using the ACL keyword. The test involves configuring several elements: Layer 3 PHY main interfaces as sources and destinations, mirror interfaces, a SPAN CLI, OSPF, and an IPv6 ACL that includes DSCP and bitmask settings. To verify the setup, traffic is monitored on the physical L3 interfaces with a monitor session enabled.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v6 with acl dscp bitmask del acl",
                "Procedure": "Traffic verification is performed with a source and destination of the L3 physical interface for IPv6 traffic in the RX direction, with an Access Control List (ACL) configured on the interface without the ACL keyword. The test-case verifies traffic with span and source and destination as L3 physical interface by deleting the ACL. Configurations include setting up the L3 phy main as source, destination, and mirror interfaces, configuring the SPAN CLI, OSPF, and an IPv6 ACL with DSCP and bitmask settings.\n\nThis test is triggered by a lack of any specific triggering condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span security source dest l3 phy main rx v6 with same acl dscp bitmask",
                "Procedure": "The test case for test_span_security_source_dest_l3_phy_main_rx_v6_with_same_acl_dscp_bitmask involves verifying IPv6 traffic that uses the security ACL and has its source and destination set as L3 physical interfaces in the receive direction. The configuration includes setting up SPAN, OSPF, an IPv6 ACL with DSCP and bitmask, and configuring L2/L3 physical/bundle main/sub interfaces. To verify this setup, traffic is monitored on a physical L3 interface with a monitor session.\n\nThis test is triggered by: None",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span security source dest l3 phy main rx v6 with diff acl dscp bitmask",
                "Procedure": "The test verifies IPv6 traffic in the RX direction for a span and security configuration with different access control lists (ACLs) applied to a Layer 3 physical interface. The configuration includes setting up the interface as source, destination, and mirror interfaces, configuring SPAN and OSPF, and creating an IPv6 ACL with DSCP and bitmask settings. The verification involves monitoring traffic on the physical Layer 3 interface while a monitor session is enabled.\n\nThis test is triggered by the absence of any specific event or condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 bun main pwspan mirror rx v4 with acl dscp bitmask",
                "Procedure": "Configuring Layer 2 and Layer 3 interfaces on the main and sub interfaces as well as configuring SPAN, OSPF, and IPv4 ACLs are required for this verification process. Traffic with monitor sessions on physical Layer 3 interfaces should be verified to confirm that configurations meet expected standards. This test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask lc rp reload",
                "Procedure": "The test verifies traffic with span where the source and destination are Level 3 physical interfaces for IPv4 traffic in receive direction with an access control list enabled on the interface without using the ACL keyword. It configures Layer 2/Level 3 physical/bundle main/sub interfaces, sets up a Spanning Protocol CLI, enables OSPF routing, and configures IPv4 ACLs. The test includes configurations of SPAN, OSPF, and ACL settings and verifications that monitor sessions are active on Level 3 physical interfaces with local cache reload and route processor reload enabled.\n\nThis test is triggered by the absence of any other triggers.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\" and \"rp_reload\"",
                "Pass/Fail Criteria": "Dscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nSpan status verification is performed.\nOspf verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask cntrl pac",
                "Procedure": "Traffic verification is performed for the specified scenario where source and destination are Layer 3 physical interfaces for IPv4 traffic received in the rx direction, with an Access Control List (ACL) configured on the interface without the ACL keyword.\n\nThis test is triggered by the absence of any conditions requiring its execution.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask multicast",
                "Procedure": "Traffic is verified with a Span and source and destination as an L3 physical interface for IPv4 traffic in the RX direction, with an access control list (ACL) applied to an interface that does not have the ACL keyword specified. The configuration includes Layer 2/Layer 3 physical/bundle main/sub interfaces, the Span CLI, OSPF, and IPv4 ACLs. Configurations of SPAN, OSPF, and ACL are used for verification purposes, including traffic with a monitor session on a physical L3 interface.\n\nThis test is triggered by a lack of configurations.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nDscp verify verification is performed.\nTftp read pcap dscp bitmask verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main tx rx v4 v6",
                "Procedure": "The test case verifies traffic with a span and source and destination as L3 physical interfaces for both IPv4 and IPv6 traffic in the RX and TX direction. The test-case configuration involves configuring L2/L3 physical/bundle main/sub interfaces, setting up a span CLI, and configuring OSPF. The verification process includes checking traffic with a monitor session on a physical L3 interface. This test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main tx rx v4 v6 with acl",
                "Procedure": "Traffic verification is conducted for span configurations where the source and destination are set to L3 physical interfaces for both IPv4 and IPv6 traffic, as well as for rx and tx directions with ACL enabled on an interface without the 'acl' keyword. The configuration includes setting up L2/L3 physical/bundle main/sub interfaces, configuring the span CLI, OSPF, and IPv4 and IPv6 ACLs. This test verifies that traffic is correctly monitored when a session is set up on a physical L3 interface.\n\nThis test is triggered by no conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span l3 source bundle main dest phy main tx rx v4 v6",
                "Procedure": "The test case verifies traffic for span and source interfaces where the destination is a Layer 3 bundle interface. The configuration involves setting up Layer 2/Layer 3 physical/bundle main/sub interfaces, configuring Span CLIs, and OSPF configurations. The test focuses on verifying traffic with a monitor session and a Layer 3 bundle as the source. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nTraffic verification is performed.\nBundle brief verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span l3 source bundle main dest phy main tx rx v4 v6 cscvt15585",
                "Procedure": "The packet count on the bundle main interface and the bundle sub-interface should be almost identical, with a tolerance of 2%. To verify this, traffic is sent through an L3 bundle interface that is also being monitored using SPAN, while OSPF routing is configured. Statistics are then checked on both interfaces to ensure they match within the specified tolerance.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nInterface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span l2 source dest phy main",
                "Procedure": "When verifying spanned traffic, the source and destination are set as Layer 2 physical interfaces. This test-case involves configuring Layer 2/Layer 3 physical/bundle main/sub interfaces, setting up a Spanning session using the CLI, and configuring an L2VPN xconnect. The configurations include SPAN and L2VPN xconnect. To verify that traffic is working correctly, we monitor the session on the physical Layer 2 interface. This test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span l2 dest bundle main",
                "Procedure": "The test case verifies traffic with a source as L2 bundle main and destination as L2 physical main. It configures L2/L3 physical/bundle main/sub interfaces, Span CLI, and L2VPN xconnect configurations, including SPAN and L2VPN xconnect settings. Traffic is verified by monitoring sessions on physical L2 interfaces. The test case is identified as CLI-02 or CLI-07.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 bun dest l2 main rx v4 v6",
                "Procedure": "The test verifies IPv4 and IPv6 traffic by configuring the network to span traffic from an L3 main bundle as a destination for an L2 main interface. It sets up configurations including OSPF and SPAN, then checks that traffic is being monitored correctly on the physical L3 main bundle. \n\nThis test is triggered by the absence of any triggers, as indicated by \"None\".",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 main dest l2 main rx v4 v6",
                "Procedure": "The test case verifies traffic with a source of layer 3 main and a destination of layer 2 main for both IPv4 and IPv6 traffic. It involves configuring the layer 2/layer 3 physical or bundle main/sub interfaces, as well as setting up a SPAN CLI configuration. Verification steps include checking for traffic on the monitor session with physical layer 3 interfaces, but no specific triggers are involved in this test case.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l2 main dest l2 main rx",
                "Procedure": "To verify span traffic, we need to configure the main L2 and L3 interfaces as well as set up a SPAN configuration using the CLI. The verification step involves checking for traffic with a monitor session on the physical L2 interface. The required configurations include setting up the L2/L3 interfaces and enabling the SPAN. The test case is identified by the ID CLI-01, and it does not rely on any external trigger.\n\nThis test is triggered by no external events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l2 bun dest l2 main rx",
                "Procedure": "To verify span traffic, configure L2/L3 physical/bundle main/sub interfaces and the Span CLI for IPv4 and IPv6 traffic. The source should be an L2 bundle and the destination an L3 physical interface. In this case, traffic with a monitor session on the L2 bundle is verified.\n\nThis test is triggered by nothing.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span process restart l3 traffic",
                "Procedure": "Traffic is verified and session status monitored after various process restarts. Configurations include setting up l2/l3 physical/bundle main/sub interfaces and enabling Span CLI functionality. The tests to be performed are verifying traffic after a process has been restarted, which can occur due to issues with processes such as \"span_ea\",\"span_ma\",\"bundle_mgr\".",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span process restart l2 traffic",
                "Procedure": "To verify traffic and monitor session status after various process restarts, the configuration involves setting up both l2 and l3 physical and bundle main and sub interfaces, as well as configuring span CLI. The SPAN configurations are then verified by checking traffic after a process restart triggers like \"span_ea\", \"span_ma\", or \"bundle_mgr\". \n\nThis test is triggered by process restart like \"span_ea\", \"span_ma\", or \"bundle_mgr\".",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span process crash l3 traffic",
                "Procedure": "To verify traffic after various process crashes, the system is configured with L2 and L3 physical or bundle main and sub interfaces, as well as span CLI configurations. The SPAN configuration includes verifying that traffic continues to flow after a process crash caused by events such as \"span_ea\", \"span_ma\", or \"bundle_mgr\". \n\nThis test is triggered by process crashes like \"span_ea\",\"span_ma\",\"bundle_mgr\".",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span process crash l2 traffic",
                "Procedure": "The test verifies traffic after various process crashes on Layer 2 and Layer 3 physical and bundle main and sub interfaces. To do this, it configures the Span CLI for traffic monitoring and checks the configurations to ensure that Span is properly set up. During the test, any of several types of process crashes - including those caused by \"span_ea\", \"span_ma\", or \"bundle_mgr\" - can trigger further testing.\n\nThis test is triggered by process crash like \"span_ea\",\"span_ma\",\"bundle_mgr\".",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Flap source destination interface",
                "Procedure": "The test case for the test_flap_source_destination_interface verifies the monitor session status after a flap in the destination interface. To set up this test, the l2/l3 physical/bundle main/sub interfaces are configured, as well as a span CLI configuration. The configurations and verifications involve setting up a SPAN (Switched Port Analyzer) environment to check the monitor session status. This test is triggered by an interface flap.",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mon session src bd members l2 dest l2",
                "Procedure": "A test-case verifies the monitor session status with source as bridge domain members, which involves configuring a bridge domain and using the span CLI to configure SPAN configurations and verify that the monitor session status is correct.\n\nThis test is triggered by the need to verify the functionality of bridge domain members in a network configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nL2vpn bridge domain summary verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span vpls bd only ac",
                "Procedure": "When verifying the monitor session status with a source as an ac member of bd without a password destination l2, this test-case confirms that the configuration is accurate. It does this by configuring bridge domain and span CLI settings, then checking the monitor session status to ensure everything is functioning properly. The configurations used in this verification include SPAN settings, while the verifications focus on monitoring session status. This test verifies features related to IDs FeatureInt-09 and FeatureInt-10.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nL2vpn bridge domain summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span vpls bd only ac with sub intf",
                "Procedure": "A feature test case verifies the monitor session status with a source as an AC (Access) port on a PHY sub-member of a bridge domain without a PW destination L2. The configuration involves setting up a bridge domain and configuring Span CLI, while the verification step checks the monitor session status. This test is triggered by none.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nL2vpn bridge domain summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mon session bd members xconnect vpws",
                "Procedure": "The test case, \"test_mon_session_bd_members_xconnect_vpws\", verifies the monitor session status with a source of bridge domain members after setting up an L2VPN XConnect VPWS. To do this, it configures a bridge domain and enables Span CLI, then sets up Cfm and L2VPN XConnect configurations. The test case checks that the monitor session status is correct by verifying that the span has been configured correctly.\n\nThis test-case verifies monitor session status with source as l2 interface which is a bridge-domain members and then remove and make part of l2vpn xconnect vpws.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nCfm peer meps verification is performed.\nL2vpn bridge domain summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mon session dest l2 l3 bundle",
                "Procedure": "This test verifies the monitor session status with a destination as an L2/L3 bundle, and with source as either a physical interface or a bundle. It configures bridge domain and Span CLI, enables Cfm, and sets up L2VPN xconnect configurations. The verification checks the monitor session status, while no triggers are necessary for this test.\n\nThis test is triggered by \"None\".",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Qos rate limit l3 src dest l2",
                "Procedure": "This device verifies the status of a monitor session with Quality of Service (QoS) enabled through the following configurations: it configures a bridge domain, enables Span (SPAN), and sets up a class map and policy map using the span CLI command. The verification step involves checking the monitor session status. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nShow policy map interface verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Qos rate limit l2 src dest l2",
                "Procedure": "The test case verifies the monitor session status with Quality of Service (qos) settings, and it involves configuring a bridge domain, setting up a span CLI, and defining class map and policy map configurations for SPAN. The verifications include checking the monitor session status. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nShow policy map interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span netflow",
                "Procedure": "The test case \"test_span_netflow\" verifies the monitor session status with a netflow configuration in place. It involves configuring both netflow and SPAN via the span CLI, as well as checking the configurations for these features. The verification process includes monitoring the session status. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nFlow monitor name cache format record location verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span rollback",
                "Procedure": "To verify the monitor session status after a config rollback, this test-case checks the session status with netflow config. It involves configuring the span CLI and verifying that the configurations for SPAN and Netflow are in place. The test verifies the monitor session status as part of its checks. This test is triggered by None.",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with erspan",
                "Procedure": "The configuration of a tunnel, static route, and ERSPAN are set up to verify the span with ERSPAN. The test involves checking that these configurations work correctly.\n\nThis test is triggered by no specific event.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with mpls traffic",
                "Procedure": "The test case, named \"Verify Span With MPLS Traffic,\" is designed to verify the functionality of spanning with multiprotocol label switching (MPLS) traffic. It involves configuring explicit-null and verifies that a span with MPLS traffic is working as expected. The configurations include enabling explicit-null, and the verifications involve checking the span's functionality with MPLS traffic. This test case has no prerequisites or dependencies.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nBundle brief verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with src dest swap",
                "Procedure": "The test case, CFGCH-19, verifies a span with swapped source and destination interfaces. The configuration involves setting up a Span, with the specific configurations being for SPAN settings. To verify that the setup is correct, the span status is checked. This test is triggered by none of the specified triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with gre traffic",
                "Procedure": "The test case, CFGCH-19, verifies the functionality of a Span with GRE traffic over a GRE tunnel. It checks that the Span works as expected when the source and destination interfaces are swapped. To perform this test, the following steps should be taken: Configure a Span using SPAN configurations, then verify its status. This test is triggered by None.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with gre traffic ipinip",
                "Procedure": "The test case for verifying Span with GRE traffic over a GRE tunnel using IP in IP verifies the Span configuration when the source and destination interfaces are swapped. The verification includes checking the span status, which requires that no configurations or triggers are set.\n\nThis test is triggered by network changes on the same subnet as the source interface.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span acl ipv4 ipv6",
                "Procedure": "To verify the monitor session status with access control lists (ACLs), this test-case configures both ACL and SPAN CLI configurations. It then checks if the monitor session status has been correctly configured by verifying that it matches the expected settings.\n\nThis test is triggered by the need to confirm that ACLs are functioning properly during network configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Hybrid span acl ipv4 ipv6",
                "Procedure": "The test case verifies the monitor session status with ACL and compress level 3 in a network environment. Configurations include setting up an ACL with compress level 3 and configuring the Span CLI. To verify that everything is working as expected, the system checks the monitor session status and ensures traffic is flowing correctly. This setup requires specific configurations: SPAN and ACL with compress level 3. The test involves a series of triggers to ensure its effectiveness, including removing and re-adding configurations, shutting down and restarting the device, and committing or rolling back changes.\n\nThis test is triggered by the actions of remove-re-add, shut-noshut, and commit-rollback.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span udf",
                "Procedure": "The test case, called \"Verify Span with UDF,\" verifies the span function in conjunction with a User Defined Function (UDF). It involves configuring the UDF to deny and permit access, as well as setting up span using the Command Line Interface (CLI). The configurations used for this test include both SPAN and UDF. During the verification phase, the status of the monitor session is checked. This test is triggered by None.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale total four session direction both static route l2vpn xconnect",
                "Procedure": "The test case configures and verifies a total of four monitor sessions, using static routes for L3 interfaces and L2VPN XConnect for L2 connections. It involves configuring User-Defined Filters (UDFs) with both deny and permit settings and the Span CLI configuration. The setup includes SPAN configurations, and the verification checks involve monitoring session status. This test case is represented by the IDs FeatureInt-05 and FeatureInt-06. This test is triggered by None.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale total four session direction rx static route l2vpn xconnect",
                "Procedure": "The test case configures and verifies a total of four monitor sessions. It uses static routes for level 3 interfaces and L2VPN XConnect for level 2 interfaces. The test case also configures User Defined Fields with deny and permit settings, as well as the SPAN CLI. To verify the configurations, the test checks the status of each monitor session.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nTraffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale total eight session direction rx static route l2vpn xconnect 9k",
                "Procedure": "This paragraph describes a test case that configures and verifies a total of eight monitor sessions on an appliance known as the 9k. The test sets up static routes for layer three interfaces and l2vpn xconnects for layer two. It also configures user-defined filters with both deny and permit settings, and enables span CLI configurations. The verifications include checking the status of each monitor session. This test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale total four session direction rx static route l2vpn xconnect sf",
                "Procedure": "The test case configures and verifies a total of four monitor sessions, using static routes for L3 interfaces and L2VPN xconnect for L2 connections. It involves configuring User Defined Filters (UDFs) with deny and permit settings, as well as enabling the Span CLI. The configurations include setting up SPAN and verifications entail checking the status of the monitor sessions. This test case is configured under ID FeatureInt-05 and also supports the configuration in FeatureInt-06, which is also a part of this scenario. \nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span sub intf src phy l2 v4 tx rx",
                "Procedure": "A test-case verifies the monitor session status with a source as physical l2 sub-interface, which involves configuring a bridge domain and a span CLI, committing the changes, and then verifying the monitor session status. The configurations required are for SPAN, and no triggers or pre-requisites apply. \n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nTraffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span sub intf src bun l2 v4 tx rx",
                "Procedure": "To verify the monitor session status with a source as bundle l2 sub-interface, this test-case configures a bridge domain and span CLI, then commits the replacement configurations. The SPAN configurations are verified by checking the monitor session status. \n\nThis test is triggered by having no specific trigger.",
                "Pass/Fail Criteria": "L2vpn xconnect verification is performed.\nBundle brief verification is performed.\nTraffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span sub intf src phy l3 v4 tx rx",
                "Procedure": "The test case verifies the status of a monitor session with the source set to phy l3 sub-interface. To do this, it configures a bridge domain and a span CLI, then commits the replacement configurations. The verification steps include checking the monitor session status. This test is triggered by none.",
                "Pass/Fail Criteria": "Bgp sessions verification is performed.\nTraffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span sub intf src bun l3 v4 tx rx",
                "Procedure": "To verify the monitor session status with a source as a bundle L3 sub-interface, configure a bridge domain and then use the span CLI to set up monitoring. The changes should be committed before verifying that the monitor session status is correct.\n\nThis test is triggered by the configuration of a network device.",
                "Pass/Fail Criteria": "Bgp sessions verification is performed.\nBundle brief verification is performed.\nTraffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span sub intf src dest flap",
                "Procedure": "The test case, named CFGCH-09, verifies the status of a monitor session after interfaces have flapped (gone down and then come back up). To perform this test, the following steps are taken: a bridge domain is configured, SPAN CLI is enabled, and all configurations are committed. The verification step involves checking the status of the monitor session.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Bundle brief verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale total six session direction rx static route l2vpn xconnect",
                "Procedure": "The test case configures and verifies a total of six monitor sessions with specific settings for direction and span. It uses static routes for L3 interfaces and L2VPN xconnects for L2 connections. The test-case configuration includes setting up SPAN CLI configurations, while verifications check the status of monitor sessions. This test is triggered by the requirement to verify six monitor sessions in a specific direction using rx as an example.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mon sess status internal sf",
                "Procedure": "The test case for verifying the monitor session status internal command for SF with IPv4 and IPv6 traffic on a physical interface involves configuring the Span CLI and performing verifications using the monitor session status internal command.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Monitor session status internal verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with erspan span to file",
                "Procedure": "The test case verifies the configuration of a span with an erspan to a file. It involves configuring a tunnel, static route, and erspan settings, which includes verifying that a span is working correctly with an erspan. The configurations involve setting up both a tunnel and ERSPAN. The verifications focus on ensuring that the span with erspan function as expected. This test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src bvi with bd without pw",
                "Procedure": "To verify a monitor session with the source as a bridge virtual interface (BVI) that is part of a bridge domain without a pseudowire (PW), the following steps are followed. A SPAN configuration is created using the CLI, and then the status of the monitor session and the traffic are verified. This test case verifies monitor sessions where the source is a BVI within a bridge domain without PW, and it uses testcase ID CLI-03, Func-L3-01. \nThis test is triggered by having no triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nL2vpn bridge domain summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpa reload with bundle configured",
                "Procedure": "The test_mpa_reload_with_bundle_configured verifies that an MPA card can be reloaded on a router, brings up the necessary bundles, and allows for normal traffic flow. This test is triggered by the configuration of OSPF/IPv6/IPv4 traffic.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic Stats : Checks TGEN Traffic by comparing the values of RX/TX packet counts on the transmitted and received ports verification is performed.\nBundle Basic Checks verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mpa shut noshut with bundle configured",
                "Procedure": "The test for verifying the MPA card flap with a bundle configured involves shutting down the OSPF, IPv6, and IPv4 traffic on the router. It then brings up the bundle and verifies that all traffic is functioning correctly.\n\nThis test is triggered by an MPA card flap event when a bundle is configured.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic Stats : Checks TGEN Traffic by comparing the values of RX/TX packet counts on the transmitted and received ports verification is performed.\nBundle Basic Checks verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Trigger span",
                "Procedure": "The test-case verifies the monitor session status with various triggers by configuring a span CLI and checking its functionality under different conditions. Configurations for this test include SPAN settings, while verifications focus on the status of the monitor sessions. The test case is triggered by router reloads, link controller (LC) reloads, or remote port failures (rpfo).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span commit replace",
                "Procedure": "The test case, labeled CFGCH-09, verifies the monitor session status after a commit replace operation. It involves configuring bridge domains and SPAN (Switched Port Analyzer) settings using the CLI (Command Line Interface), followed by committing these changes as part of a replace operation. The configurations made include setting up SPAN. To verify that this process is successful, the test checks the monitor session status. \n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l2 phy dest l2 phy sub intf",
                "Procedure": "The test verifies traffic between a Layer 2 main interface and its corresponding subinterface for both IPv4 and IPv6 traffic. It involves configuring the main and sub interfaces, setting up a Spanning Port Analyzer (SPAN) CLI session, and configuring OSPF routing protocols. The test cases include verifying that traffic is successfully monitored on the physical L2 main interface with a monitor session in place. This test-case verifies traffic with source as l2 main interface and destination as l2 sub interface - Configures l2/l3 physical/bundle main/sub interfaces - Configures span CLI - Configurations: SPAN, OSPF  Verifications: - traffic with monitor session on physical l2 main  Triggers: This test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l2 phy dest l3 phy sub intf",
                "Procedure": "Traffic is verified between a source on the L2 main physical interface and a destination on an L3 subinterface for both IPv4 and IPv6 traffic. Configurations include setting up L2/L3 physical/bundle main/sub interfaces, configuring Span CLI, and setting up OSPF routing protocols. The test verifies that traffic flows properly with a monitor session enabled on the L2 main physical interface.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l2 bun dest l2 phy sub intf",
                "Procedure": "The test case verifies traffic between an L2 main bundle and a subinterface, with configurations including SPAN, OSPF, and physical/bundle main/sub interfaces. It checks IPv4 and IPv6 traffic with a monitor session on the physical L2 main bundle.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l2 bun dest l3 phy sub intf",
                "Procedure": "The test Src L2 Bun Dest L3 Phy Sub Intf verifies span traffic with a source of an L2 main bundle and a destination of an L3 sub interface for both IPv4 and IPv6 traffic configurations. It checks the performance of this setup, which includes configuring L2/L3 physical/bundle main/sub interfaces, setting up a SPAN (Switched Port Analyzer) CLI, and configuring OSPF routing protocol. The test then verifies that traffic is properly monitored on the physical L2 main bundle with a monitor session in place. This test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 bun dest l2 phy sub intf",
                "Procedure": "Configuring Layer 2 and Layer 3 interfaces, as well as the Span (Switched Port Analyzer) CLI, with OSPF routing also configured, this test verifies that traffic flows correctly when the source is a main bundle on Layer 3 and the destination is a subinterface at Layer 2 for both IPv4 and IPv6 protocols. The test includes configurations for the span and OSPF, as well as verifications of traffic flow monitored via sessions on the main bundle's Layer 3 interfaces.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 bun dest l3 phy sub intf",
                "Procedure": "The test case verifies IPv4 and IPv6 traffic between a source on the L3 main bundle and a destination on an L3 physical subinterface. It involves configuring L2/L3 physical/bundle main/sub interfaces, setting up a Span CLI session, and enabling OSPF routing. To confirm that the configuration is working as expected, the test checks for traffic flowing through a monitor session on the L3 main bundle. This test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 phy dest l2 phy sub intf",
                "Procedure": "To verify span traffic for IPv4 and IPv6 protocols, configure Layer 2/3 physical or bundle main/sub interfaces, enable the Span CLIs, and configure OSPF routing protocol. This setup involves configuring SPAN (Switched Port Analyzer) and OSPF (Open Shortest Path First), as well as verifying that traffic is monitored on the main Layer 3 interface with a session enabled. The test cases are identified by CLI-03 and Func-L3-03, but no triggers have been specified for this test.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 phy dest l3 phy sub intf",
                "Procedure": "To verify span traffic, the source is set to the Layer 3 main physical interface and the destination to a Layer 3 phy sub-interface for both IPv4 and IPv6 traffic. The configuration involves setting up the L2/L3 physical/bundle main/sub interfaces, configuring the SPAN CLI, and enabling OSPF routing. To verify, monitor sessions are checked on the physical Layer 3 main interface, confirming that traffic is passing through correctly with the established configurations of SPAN and OSPF in place.\n\nThis test is triggered by no specific condition or event.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Trigger dest l2 phy sub intf",
                "Procedure": "To verify a span with hw-triggers, this test-case monitors the session status with a LC reload trigger. The configuration involves setting up a Span CLI and configuring SPAN. To verify that everything is working correctly, the monitor session status and mirrored packets are checked. This test can be triggered by an LC reload.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"lc_reload\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span process restart dest l2 sub intf",
                "Procedure": "Verify traffic and monitor session status after the span_ea process restart. This case involves configuring L2/L3 physical/bundle main/sub interfaces, as well as setting up a SPAN CLI configuration. The verifications include checking the span functionality following a process restart triggered by a command like \"span_ea\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_res: \"span_ea\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span process restart dest l3 sub intf",
                "Procedure": "After verifying traffic and monitoring session status, this test-case verifies that traffic is flowing correctly after a span process has been restarted. Configurations include setting up L2/L3 physical/bundle main/sub interfaces and configuring the SPAN CLI. Verifications involve checking the state of the SPAN after the restart. This test is triggered by a process restart like \"span_ea\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_res: \"span_ea\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span moving dest l2 to l3 src mix l2 l3",
                "Procedure": "Verify traffic and monitor session status after moving a destination interface from Layer 2 to Layer 3 and then back to Layer 2. This involves verifying that SPAN works correctly even after changing interfaces. Configurations include setting up main/sub interfaces at both physical and bundle levels, as well as configuring the SPAN CLI. The test verifies that span and traffic continue uninterrupted during these interface changes. Testcase IDs HA-01, HA-03, and HA-05 are relevant to this scenario.\n\nThis test is triggered by no specific condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span 24 mon sess dest sub intf",
                "Procedure": "This test-case configures 24 monitor sessions and verifies a total of 8 monitor sessions, using static routes for L3 interfaces and L2VPN xconnects for L2. It uses the SPAN CLI to configure the span functionality, with verification steps including monitoring session status and checking that the span remains active for at least 8 milliseconds. This test is triggered by none.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span moving dest sub to main intf",
                "Procedure": "When verifying a network, we check how traffic flows between interfaces after it has been redirected from a subinterface back to the main interface and then again to the subinterface. This test case verifies that traffic can be sent from an L2 main interface to another L2 main or sub interface with a monitor session on the physical L2 main interface set up.\n\nThis test is triggered by the absence of any other tests.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src l2 phy dest sep rx tx",
                "Procedure": "Traffic with source as the L2 main interface and different destination main interfaces for receive and transmit traffics is verified in this test-case. The configurations include setting up L2/L3 physical/bundle main/sub interfaces and configuring span CLI, specifically for SPAN. The verifications also focus on SPAN.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 8 sess dest sep rx tx",
                "Procedure": "The test verifies traffic with source as L2/L3 PHY/BUNDLE interfaces and different destinations for RX and TX traffics on all PHY sub-interfaces. It involves configuring the L2/L3 physical/bundle main/sub interfaces, setting up a SPAN configuration via CLI, and verifying that SPAN is working correctly.\n\nThis test is triggered by no specific condition or event.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src dest l2 phy sub cscvx89762",
                "Procedure": "To verify the traffic flow, a span is set up to mirror all IPv4 and IPv6 traffic from the L2 main physical interface to the L2 subinterface. The traffic rate in bps is verified at both the Spirent egress and source interface egress for this tx mirroring span. This test-case verifies that traffic flows properly with the monitor session enabled on the physical L2 main interface, and configurations include SPAN, OSPF, as well as setting up the L2/L3 main/sub interfaces and configuring the CLI and OSPF. \nThis test is triggered by the absence of any configuration changes in the test environment.",
                "Pass/Fail Criteria": "Span status verification is performed.\nInterface packets rate verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src l3 phy sub dest l2 phy sub cscvx87398",
                "Procedure": "To verify span functionality, the source interface should be configured as a level three physical subinterface with egress traffic enabled. The test case verifies that traffic can flow from a level two main interface to a level two subinterface when monitored through a span session. Configurations include setting up level two and three physical and bundle interfaces, configuring the span command line interface, and enabling OSPF routing protocols. Verifications check for correct transmission of data between these interfaces with monitoring enabled on the level two main interface's physical layer.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src l3 bun dest l2 bun cscvx36984",
                "Procedure": "The test verifies IPv4 traffic between a source L3 bundle interface and a destination L2 bundle interface in both receive and transmit directions. Configurations include setting up L2/L3 physical/bundle main/sub interfaces, configuring the SPAN CLI, and setting up OSPF. To verify the test, we check that there is traffic with a monitor session on the physical L2 main interface.\n\nThis test is triggered by no specific conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 phy main sub dest l2 bun main",
                "Procedure": "To verify the functionality of a network span, configure an l2/l3 physical main and destination as an l2 bundle main interface, then check that it works as expected. \n\nThis test is triggered when no specific condition requires it to run.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l3 phy main sub dest l2 bun main",
                "Procedure": "The test verifies that a network span works as expected when the source is set to either an L2/L3 physical main interface or an L2 bundle main interface, and the destination is set to an L2 bundle main interface. The test case configures both the L2/L3 physical/bundle main/sub interfaces and enables the span CLI through the configuration. To verify that the span works correctly, a check is performed for the presence of the 'span' parameter. No triggers are associated with this test. This test is triggered by the absence of any specific trigger conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 bun main sub dest l2 bun main",
                "Procedure": "The span on the l2/l3 physical main interface is verified to work correctly when the destination is the l2 bundle main interface. The test case configures both interfaces and sets up the span CLI configuration, then checks that the span is operational. The configurations used for this test are based on SPAN settings, while verifications ensure that the span is active. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l3 bun main sub dest l2 bun main",
                "Procedure": "The test verifies that a span works fine between an L2/L3 physical main and destination as L2 bundle main interface. The test case includes configuring L2/L3 physical/bundle main/sub interfaces and the Span CLI configuration, and then verifying that the span is present.\n\nThis test is triggered by no triggers being specified.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 phy main sub dest l2 bun sub",
                "Procedure": "The test verifies that the span function works correctly when the source interface is a layer 2 or 3 physical main interface and the destination interface is a layer 2 bundle main interface. The test case configures the layer 2/l3 physical/bundle main/sub interfaces, as well as the span command line interface (CLI). It then checks that the span function is working correctly by verifying the span configuration. This test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l3 phy main sub dest l2 bun sub",
                "Procedure": "The test case verifies that a spanning tree works correctly when the source is an L2/L3 physical main interface and the destination is an L2 bundle main interface. The test configures both interfaces and sets up a span CLI configuration, then checks for proper operation. It is used to verify that the spanning tree functions as expected on ASR9k platforms.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 bun main dest l2 bun sub",
                "Procedure": "The test verifies that a span works fine when the source interface is an L2/L3 physical main and the destination interface is an L2 bundle main interface. It does this by configuring both interfaces and using the span CLI to configure the span. The test looks for a spanning of packets, but has no triggers.\n\nThis test is triggered by no specific events or conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l3 bun sub dest l2 bun sub",
                "Procedure": "The test-case verifies that the span works fine when configuring L2/L3 physical and bundle main/sub interfaces as the source, and the destination interface as the L2 bundle main interface. The configurations include setting up the L2/L3 physical/bundle main/sub interfaces and the span CLI. To verify the setup, the span should be checked to ensure it is functioning correctly. This test is triggered by having no specific conditions set.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with remove readd dest bundle member",
                "Procedure": "The test case verifies that a span works correctly when configured on an L2/L3 physical or bundle main interface, with the source being the physical main interface and the destination being the bundle main interface. The test configuration includes setting up the physical and bundle interfaces, as well as configuring the span CLI. The test verifications involve checking the span output. This test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with shut noshut dest bundle member",
                "Procedure": "The test spans a network segment with the source set as an L2/L3 physical main interface and the destination set as an L2 bundle main interface, verifying that it functions correctly. The configuration involves setting up L2/L3 physical and bundle main/sub interfaces and configuring the span CLI. This setup checks for the correct operation of the span feature.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span trigger dest bundle",
                "Procedure": "To verify that a span works correctly with source as the l2/l3 physical main interface and destination as the l2 bundle main interface, this test-case verifies that everything functions properly. It does this by configuring the l2/l3 physical/bundle main/sub interfaces and setting up a span via CLI. To ensure that these configurations are working as expected, we verify the span, which includes checking for any issues related to router reloads, line card reloads, or RPFO occurrences on our ASR9k platform.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span process restart dest bundle",
                "Procedure": "When running the test \"test_span_process_restart_dest_bundle\", it verifies that a span works as expected. The test configures the main and sub interfaces of L2/L3 physical/bundle devices, sets up a span using the CLI, and checks that the span is functioning correctly. The configurations used for this test include those related to SPAN. The triggers for this process are a restart of the processes Span_ea, Span_ma, and Span_ma_mgr.\n\nThis test is triggered by Process Restart : Span_ea, Span_ma, Span_mgr.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_res: \"span_ea\" and \"span_ma\" and \"span_mgr\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span process crash dest bundle",
                "Procedure": "The test \"test_span_process_crash_dest_bundle\" verifies that a span works properly when the source is an L2/L3 physical main interface and the destination is an L2 bundle main interface. The test configures both the L2/L3 physical/bundle main/sub interfaces and the span CLI, then checks for proper span configuration and functionality. This test case ID is HA-05 and is applicable to the ASR9k platform. It triggers on process crash events in Span_ea, Span_ma, and Span_mgr processes.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_crash: \"span_ea\" and \"span_ma\" and \"span_mgr\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span check counters dest bun",
                "Procedure": "The test, identified as FT-11 and applicable to the ASR9k platform, verifies that a span works correctly. It does this by configuring layer 2 and 3 physical or bundle main and sub interfaces, and then setting up a span CLI configuration. The test then checks that the span counters are correct.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nSpan counters verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span 8 scale with 800 src dest l2 bundle sub",
                "Procedure": "The test verifies that a span works properly when the source is an L2/L3 physical main interface and the destination is an L2 bundle main interface. To achieve this, the test configures the L2/L3 physical/bundle main/sub interfaces and sets up a span using the CLI. The configuration and verification steps for the test include setting up SPAN configurations and verifying that the span works as expected. This test-case has no triggers associated with it.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span qos rate limit on dest bun",
                "Procedure": "To verify the span function, configure an L2/L3 physical main interface and a destination as an L2 bundle main interface on the ASR9k platform. The test involves configuring both the source and destination interfaces, as well as the SPAN CLI configuration. The test verifies that the span works correctly by checking the span itself. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 bundle main destination l2 bundle main src udp 53",
                "Procedure": "The test case for FT-00 verifies that span works fine over the main bundle interface when configured with SPAN and L2VPN bridge in a DUT. The configurations include SPAN and an L2VPN bridge in the device under test, while the verifications focus on the span functionality itself. This test is triggered by none of the specific conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qsub rewrite destination l2 bundle sub src tcp 53",
                "Procedure": "The test case, identified as FT-01, involves verifying a monitor session with specific configurations and verifications on an NCS5700 platform. The session uses the L2_qinqsub_rewrite interface as the source, the l2Sub interface as the destination, and the SPAN destination is set to L2Sub.\n\nThis test is triggered by: No triggering event or condition is required for this test case.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qinqsub rewrite destination l2 bundle main src udp 53",
                "Procedure": "The monitor session is verified with the source set as the L2_qinqsub_rewrite interface, the destination set to l2Sub, and the SPAN destination configured as L2main. The test setup includes a SPAN configuration and an L2VPN bridge within the DUT. Verification of the span occurs without any triggering events. \n\nTriggered by: None",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel main destination bundle l3 main src tcp 80",
                "Procedure": "The configuration for this test includes a SPAN session with forwarding source as the Bundle_L2Main interface and forwarding destination as L2Main, which belongs to the same BVI. The Mirror destination is set to Bundle_L3Main. The DUT's configurations include SPAN and an L2VPN bridge. This setup is verified by checking that the span session is up.\n\nThis test is triggered by there being no specific conditions that trigger it.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qsub destination l2sub located another bvi https",
                "Procedure": "The configuration for this test involves a monitor session with the source as an L2 dot1qsub_rewrite interface and the destination as another BVI interface, where l2Sub is located. The SPAN destination is also set to the location of l2Sub. This setup includes configurations such as SPAN and L2VPN bridge in DUT, and verifications involve checking the span status.\n\nThis test is triggered by the absence of any specific trigger events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qinqsub destination main located another bvi 853",
                "Procedure": "The testcase FT-05 verifies a monitor session with the source as L2_dot1qinqsub_rewrite interface, destination as l2Sub located in Another BVI interface, and SPAN destination is L2main. The configuration includes SPAN and L2VPN bridge on the DUT. Verification steps include checking SPAN and traffic counters.\n\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel main destination l2sub l3 main located another bvi tcp53",
                "Procedure": "The test verifies a monitor session with forwarding source as Bundle_L2Main interface, forwarding destination as BundleL2Sub belonging to a different BVI, and Mirror destination is BundleL3Main. Configurations include SPAN and L2VPN bridge in the DUT. Verifications involve checking Span and traffic counters.\n\nThis test is triggered by there being no specific triggers associated with it.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qsub mirror destination main forwarding dest l3sub udp53",
                "Procedure": "The test verifies a monitor session with forwarding_source set to Bundle_L2_dot1qsub_rewrite interface, forwarding_destination set to L3Sub belonging to default_vrf, and the Mirror destination is BundleL2Main. Configurations include an SPAN and an L2VPN bridge in the DUT, while verifications involve checking SPAN and traffic counters. This test has no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dotqinqsub mirror destination l3main forwarding dest l3main http",
                "Procedure": "The test verifies the monitor session with forwarding_source set as Bundle_L2_dot1qsub_rewrite interface, forwarding_destination as L3Sub belonging to default_vrf, and Mirror destination as BundleL3Main on a device with configurations including SPAN and an L2VPN bridge in DUT mode. The verifications include checking SPAN and traffic counters. This test is triggered by none specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qmain mirror destination main forwarding dest l3main ipv4",
                "Procedure": "The test case for verifying a monitor session involves setting up forwarding_source as Bundle_L2_dot1qsub_rewrite interface, forwarding_destination as L3Main belonging to the default_vrf, and configuring Mirror destination as BundleL2Sub. The configurations involve enabling SPAN and an L2VPN bridge in the DUT, while verifications include checking SPAN and traffic counters. This test is triggered by the absence of specific triggers for a particular platform, which is the NCS5700.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel main destination l2sub mirror dest l3 main located another bvi ipv6 udpdns traffic",
                "Procedure": "The test involves verifying a monitor session with forwarding_source as the Bundle_L2Main interface, forwarding_destination as the BundleL2Sub belonging to a different BVI, and Mirror destination as the BundleL3Main. Configurations include SPAN and L2VPN bridges in the DUT. Verifications involve checking SPAN and traffic counters. This test has no specific triggers.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qsub destination l2sub located another bvi ipv6 tls tcp traffic",
                "Procedure": "This paragraph is the rewritten text:\n\nThe test verifies a monitor session with forwarding source as Bundle_L2_dot1qsub_rewrite interface and forwarding destination as Bundle_l2Sub, which belongs to a different BVI. The mirror destination is also BundleL2Sub. The configurations include an SPAN and L2VPN bridge in the DUT. Verifications are done using SPAN and traffic counters.\n\nRewritten trigger sentence:\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qmain mirror destination main forwarding dest l3main ipv6 tls",
                "Procedure": "The test verifies the monitor session configuration with forwarding_source set to Bundle_L2_dot1qsub_rewrite interface, forwarding_destination set to L3Main belonging to default_vrf, and Mirror destination as BundleL2Sub. Configurations include a SPAN, L2VPN bridge in DUT, while verifications involve SPAN and traffic counters. The test case ID is FT-15, and the platform used is NCS5700. This test is triggered by no specific events or conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dotqinqsub mirror destination l3main forwarding dest l3main 80 ipv6",
                "Procedure": "The test verifies the monitor session with forwarding source as Bundle_L2_dot1qsub_rewrite interface, forwarding destination as L3Sub belonging to default_vrf, and Mirror destination as BundleL3Main. Configurations include a Service Provider Attachment Circuit (SPAN), an L2VPN bridge in the Device Under Test (DUT), while verifications involve checking SPAN and traffic counters. The test case ID is FT-14 and it's applicable on NCS5700 platform. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qsub mirror destination main forwarding dest l3sub v6 http",
                "Procedure": "The test monitors a session with forwarding source set to Bundle_L2_dot1qsub_rewrite interface, forwarding destination set as v6 L3Sub belonging to default_vrf, and the mirror destination is set to BundleL2Main. The configurations involve SPAN and an L2VPN bridge in the DUT. The verifications include monitoring SPAN and traffic counters. This test is triggered by no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel dot1qinqsub destination main located another bvi v6 tcp53",
                "Procedure": "The monitor session is set up to forward traffic from a Bundle_L2_qinqsub_rewrite interface as the source, and traffic going to a BundleL2Main belonging to a different BVI is forwarded as the destination, with Mirror destinations also being sent to BundleL2Main-A. The DUT (Device Under Test) has configurations including SPAN (Switched Port Analyzer) and an L2VPN bridge, and verifications include checking SPAN settings and traffic counters. This test case ID is FT-11 and it's run on the NCS5700 platform.\n\nThis test is triggered by there being no specific triggers involved.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 dot1adsub rewrite destination l2 bundle sub src tcp 53",
                "Procedure": "The test for the monitor session verifies that it works when the source is set to an L2 Q-in-Q sub-interface, the destination is set to an l2Sub interface, and the SPAN destination is also on L2Sub. The test configuration includes a Service Provider Network (SPAN) device with an L2VPN bridge in the Device Under Test (DUT). This test case, FI-03, can be run on NCS5700 platforms.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span verify rx tx combined",
                "Procedure": "The test for verifying both receive and transmit traffic with span and L2VPN bridging combined on the device under test must be run on an NCS5700 platform, using SPAN and L2VPN bridge configurations. It checks that span functionality works as expected in this specific scenario.\n\nThis test is triggered by no specific conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 dot1qsub rewrite remove and add destination l2 bundle sub src tcp 53",
                "Procedure": "The test verifies a monitor session with source as L2_qinqsub_rewrite interface, which removes and adds the rewrite destination as l2Sub, and sets SPAN destination to L2Sub. The configurations include SPAN and L2VPN bridge in the DUT, while verifications involve checking for span. The test case is FI-02 and it can be run on NCS5700 platforms. This test is triggered by no external event or condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span l2 l2 and l2 l3 and l2 l3 l3 l2",
                "Procedure": "The test for verifying a monitor session with test_span_l2_l2_and_l2_l3_and_l2_l3_l3_l2 involves configurations of an SPAN and a L2VPN bridge within the DUT, and verifications are made using the '-span' command.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l3 l3 2 acl",
                "Procedure": "The test verifies a monitor session with source as an L2 Dot1q subrewrite interface, destination as l2Sub located in another BVI interface, and the SPAN destination is at the L2Sub location. Configurations include SPAN and L2VPN bridging in the DUT. The verifications are that span works correctly. This test is triggered by no specific event.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span perform iteration hw cli",
                "Procedure": "The test \"test_span_Perform_Iteration_HW_cli\" performs an iteration on the hardware command-line interface (HW cli) for configurations such as SPAN and L2VPN bridges in the device under test (DUT). The verifications include checking the span settings, but no triggers are specified. This test has a testcase ID of FT-21 and is supported on NCS5700 platforms. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel with erspan as mirror destination",
                "Procedure": "The test verifies a monitor session with source as an L2/Dot1q sub-rewrite interface, destination as another BVI interface located in the l2Sub module, and SPAN destination configured for ERSPAN. Configurations include a DUT with a SPAN-enabled bridge in an L2VPN setup. The verification process checks the span functionality, but no specific triggers are defined to initiate this test on the NCS5700 platform.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel with pwspan as mirror destination",
                "Procedure": "The configuration for this test involves verifying a monitor session where the source is an L2_dot1qsub_rewrite interface, the destination is an l2Sub located in another BVI interface, and the SPAN destination is PWSPAN. The configurations include SPAN and L2VPN bridge in DUT, while the verifications are to check for spanning. This test is triggered by having no triggers at all.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span l2 l2 nondns traffic",
                "Procedure": "The test combines L2-L2, L2-L3, and L3-L2 traffic flows on the same path, with SPAN (Switched Port Analyzer) and L2VPN bridge configurations used in the DUT (Device Under Test). Verifications are performed using a 'span' command. The test runs on the NCS5700 platform.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source l2 l4 portlevel with egress qos",
                "Procedure": "The testcase FT-40 verifies that a span works fine over the main bundle interface on an NCS5700 platform, which has been configured for SPAN and L2VPN bridge in DUT. The configurations include a spanning port level with egress QoS. No specific triggers are required to run this test.\n\nThis test is triggered by no specific condition or event.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale 6session source l2sub mirror l2sub samebvi",
                "Procedure": "To verify the maximum scale of 6 sessions on an NCS5700 platform when using Layer 2 subinterfaces for ingress and egress, as well as for mirroring destinations, certain configurations must be in place. These include Spanning Port (SPAN), interface, and L2VPN configurations. The verification process involves checking the status of a monitor session. This test is triggered by the need to verify that an NCS5700 platform supports the maximum scale of 6 sessions under specific Layer 2 subinterface conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale 6session source l2sub mirror l2sub diff bvi",
                "Procedure": "When verifying the MAx scale of six sessions on an NCS5700 platform with L2 sub interface as ingress and forwarding egress on another BVI, Mirror destination should be in L2 Sub interface. Configurations include SPAN, interface, and l2vpn settings. To verify this scenario, check the monitor session status. The test case ID is Scale-02, which involves testing on an NCS5700 platform.\n\nThis test is triggered by no specific conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale 6session source l2sub mirror l2sub l2 l2 and l2 l3",
                "Procedure": "When performing a router reload on an NCS5700 platform configured for HA-01, check if SPAN sessions resume with the correct six-session configurations, which include SPAN, interface, and l2vpn settings. Monitor the session status to verify the outcome. This test is triggered by a router reload.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale 6session source l2sub mirror l2sub mix save bvi diff bvi linerate",
                "Procedure": "The test verifies the scale of three sessions when ingress traffic enters through a Layer 2 sub-interface, and forwarding egress traffic leaves from the same BVI or another BVI, with the mirror destination set to a different L2 Sub interface. Configurations include SPAN, interfaces, and L2 VPNs. Verifications involve monitoring session status. Testcase ID is Scale-03 and it runs on the NCS5700 platform. This test is triggered by none of the specified triggers having any effect.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale 6session source l2sub mirror l2sub mix save bvi diff bvi linerate cfm",
                "Procedure": "The verification of the scale of three sessions involves two scenarios: one where ingress is an L2 subinterface and forwarding egress is another L2 Sub on the same BVI, and the other where ingress is also an L2 subinterface but forwarding egress is an L2 Sub on a different BVI. The destination for the mirror is set to an L2 Sub interface, with configurations including SPAN, interfaces, and l2vpn. Verifications include monitoring session status. The testcase ID is Scale-03 and it's run on the NCS5700 platform. This test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nCfm peer meps verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Scale 6session source l2sub mirror l2sub mix bundle add remove",
                "Procedure": "The test for HA-03 verifies the scale of three sessions with L2 sub interface as ingress and forwarding egress on the same BVI, as well as when it's on another BVI. Mirror destination in L2 Sub_interface configurations include SPAN, interface, and l2vpn. Verifications involve monitoring session status. \n\nTriggered by: No specific conditions are required to initiate this test.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2main fordestbunl2main mirrordestbunl2main udp53",
                "Procedure": "This test case verifies that a span works correctly over the main bundle interface in an L2VPN bridge configuration on the DUT. The configurations include SPAN and L2VPN bridge, while the verifications involve checking the span. The test does not have any triggers. It has been assigned the ID FT-00 and is applicable to NCS5700 platforms.\n\nThis test is triggered by no specific event or action.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2dot1qpop fordestbunl2sub mirrordestbunl2sub tcp53",
                "Procedure": "The NCS5700 platform is tested with a monitor session set up between L2_qinqsub_rewrite interface as the source, l2Sub as the destination, and L2Sub as the SPAN destination within an L2VPN bridge in the DUT. Configurations include enabling SPAN and creating an L2VPN bridge, while verifications check for successful spanning. Testcase ID is FT-01.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2qinqpop2 fordestbunl2qinq mirrordestbunl2main udp53",
                "Procedure": "The test verifies a monitor session with source as L2_qinqsub_rewrite interface, destination as l2Sub, and the SPAN destination as L2main on a platform such as NCS5700 configured for SPAN and L2VPN bridge in DUT.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2main fordestbunl2main mirrordestbunl3main tcp80",
                "Procedure": "The verification of a monitor session involves forwarding the source traffic to Bundle_L2Main interface and the destination traffic to L2Main, which belongs to the same BVI. The mirror destination is set to Bundle_L3Main. Configurations for this test include SPAN and an L2VPN bridge in the DUT. Verifications are performed on the span. This test is triggered by a trigger that does not apply.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v4l2 srcbunl2subpop fordestbunl2subpop mirrordestbunl2sub https tcp443",
                "Procedure": "The configuration for this test involves a monitor session where the source is an L2 dot1q sub-rewrite interface and the destination is l2Sub located in another BVI interface, with the SPAN destination also at the L2Sub location. The DUT uses both SPAN and L2VPN bridge configurations. To verify the setup, the span operation is checked. This test is triggered by a specific platform configuration on an NCS5700 device.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v4l2 srcbunl2qinqpop fordestbunl2main mirrordestbunl2main 853",
                "Procedure": "The verification monitor session uses the source interface L2_dot1qinqsub_rewrite, with a destination located in Another BVI interface labeled l2Sub, and the SPAN destination is set to L2main. The DUT's configurations include a bridge for L2VPN and also supports SPAN. During testing, both SPAN and traffic counters are monitored.\n\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v4l2 srcbunl2main fordestbunl2subpop mirrordestbunl3main tcp53",
                "Procedure": "The testcase, titled FT-06 and running on the NCS5700 platform, involves a verification of monitor session configuration with forwarding_source set as Bundle_L2Main interface, forwarding_destination set as BundleL2Sub belonging to a different bridge VLAN interface, and Mirror destination as BundleL3Main. The configurations include SPAN and an L2VPN bridge within the DUT. This test is triggered by the absence of specific triggers.\n\n( Trigger sentence )",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v4 srcbunl2subpop fordestbunl3sub mirrordestbunl2main udp53",
                "Procedure": "The test case involves verifying a monitor session with forwarding_source as Bundle_L2_dot1qsub_rewrite interface, forwarding_destination as L3Sub belonging to the default_vrf, and Mirror destination is BundleL2Main. Configurations include SPAN and an L2VPN bridge in the DUT, while verifications involve checking SPAN and traffic counters. The test case has no specific triggers.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v4 srcbunl2qinqpop fordestbunl3sub mirrordestbunl3main tcp http",
                "Procedure": "The monitoring session verifies the forwarding of traffic from a bundle interface with dot1q sub-rewrite enabled, to an L3 sub-interface belonging to the default VRF, and mirrors the destination to a bundle main interface. The configurations include SPAN and an L2VPN bridge in the DUT. Verifications are done using SPAN and traffic counters.\n\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v4 srcbunl2main fordestbunl3main mirrordestbunl2sub tcp http443",
                "Procedure": "The test monitors a session with forwarding source as Bundle_L2_dot1qsub_rewrite interface, forwarding destination as L3Main belonging to default_vrf, and Mirror destination is BundleL2Sub. Configurations include SPAN and L2VPN bridge in the DUT. Verifications involve checking for SPAN and traffic counters. The test case has an ID of FT-09 and is intended for use on a NCS5700 platform. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v6l2 srcbunl2main fordestbunl2subpop mirrordestbunl3main udp dns",
                "Procedure": "The NCS5700 platform is used for this test, which includes configurations such as SPAN and an L2VPN bridge in the DUT. The verification checks include SPAN and traffic counters. No specific triggers are associated with this test.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v6l2 srcbunl2subpop fordestbunl2subpop mirrordestbunl2sub tls tcp853",
                "Procedure": "The test verifies a monitor session with forwarding source as Bundle_L2_dot1qsub_rewrite interface, forwarding destination as a bundle belonging to a different BVI, and mirror destination is BundleL2Sub. The DUT's configurations include an L2VPN bridge, while the verifications involve SPAN and traffic counters. This test has no specific triggers.\n\nThis test is triggered by: None",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v6 srcbunl2main fordestbunl3sub mirrordestbunl2sub tcp tls 853",
                "Procedure": "The monitor session for this test uses forwarding_source as the Bundle_L2_dot1qsub_rewrite interface, forwarding_destination as L3Main belonging to the default_vrf, and Mirror destination is set to BundleL2Sub. The device under test (DUT) is configured with a SPAN, an L2VPN bridge, while verifications include SPAN traffic counters.\n\nThis test is triggered by the absence of specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v6 srcbunl2qinqpop fordestbunl3main mirrordestbunl3main tcp https 443",
                "Procedure": "The test verifies a monitor session with forwarding_source as Bundle_L2_dot1qsub_rewrite interface, forwarding_destination as L3Sub belonging to default_vrf, and Mirror destination is BundleL3Main. Configurations include SPAN and an L2VPN bridge in the DUT. Verifications include SPAN and traffic counters. The test case ID is FT-14, and it runs on a NCS5700 platform. This test has no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v6 srcbunl2subpop fordestbunl3main mirrordestbunl2main tcp http 80",
                "Procedure": "The test verifies a monitor session with forwarding_source as Bundle_L2_dot1qsub_rewrite interface, forwarding_destination as v6 L3Sub belonging to default_vrf, and Mirror destination is BundleL2Main. Configurations include SPAN, L2VPN bridge in DUT. Verifications involve SPAN, Traffic counters. This test has no specific triggers.\n\nTrigger: This test is triggered by the absence of any trigger conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v6l2 srcbunl2qinqpop fordestbunl2main mirrordestbunl2main tcp 53",
                "Procedure": "The test case FT-11 for the NCS5700 platform involves verifying a monitor session with forwarding_source as Bundle_L2_qinqsub_rewrite interface, forwarding_destination as Bundle_l2Main belonging to different BVI, and Mirror destination as BundleL2Main-A. The configurations include SPAN and an L2VPN bridge in the DUT. Verifications will be done using SPAN and traffic counters.\n\nThis test has no specific triggers.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl21adpop fordestbunl21ad mirrordestbunl21ad tcp 53",
                "Procedure": "The test case, designated as FI-03 and targeted at the NCS5700 platform, involves verifying a monitor session with specific configuration settings. The source of the session should be set to L2_qinqsub_rewrite interface, while the destination should be l2Sub, and the SPAN destination is configured as L2Sub. In order to test these settings, configurations such as SPAN and an L2VPN bridge in DUT need to be implemented.\n\nThis test is triggered by no specific condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2srcbunl2dot1qpop fordestbunl2sub mirrordestbunl2sub tcp53 tx filter rx filter 2 interfaces",
                "Procedure": "The test case \"test_L2L2srcBunL2Dot1qPop_forDestBunL2Sub_mirrorDestBunL2Sub_TCP53_Tx_Filter_Rx_Filter_2_Interfaces\" verifies the combined Rx and Tx configurations on a DUT with SPAN and L2VPN bridge setups. The verifications include checking for span functionality, while no triggers are required to initiate the test. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v4l2 srcbunl2main fordestbunl2subpop mirrordestbunl3main tcp53 2 acl",
                "Procedure": "The configuration involves setting up a monitor session with the source as an L2 dot1q sub-rewrite interface and the destination as another BVI interface, with the SPAN destination also set to that location. A bridge in the DUT's L2VPN is configured for spanning. The test verifies a specific span configuration. It can be run on the NCS5700 platform. This test is triggered by none.",
                "Pass/Fail Criteria": "L2v4l2 srcbunl2main fordestbunl2subpop mirrordestbunl3main tcp53 verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2subpop fordestbunl2subpop mirrordestbunl2sub tcp 53 tx modifyrewrite",
                "Procedure": "The verification of the monitor session involves using a source interface that is L2_qinqsub_rewrite, and modifying it to remove and add a rewrite destination as l2Sub, while also confirming that the SPAN destination is indeed L2Sub. The relevant configurations include a Span port and an L2VPN bridge within the DUT. No triggers are specified for this test case, which is designated as FI-02, and is applicable only to NCS5700 platforms.\n\nThis test is triggered by: None",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 l2v l2v4l2srcbunl2dot1qpop fordestbunl2sub mirrordestbunl2sub tcp53 tcp53 tcp53",
                "Procedure": "On the NCS5700 platform, a monitor session with test_span_l2_l2_and_l2_l3_and_l2_l3_l3_l2 is verified. The configurations used include SPAN and an L2VPN bridge in the DUT. The verifications performed are span. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 l2v4 srcbunl2main fordestbunl2main mirrordestbunl3main tcp80 any any hwcli iter",
                "Procedure": "The configuration of a network device involves performing an iteration on the hardware command-line interface (HW CLI) with specific settings, including SPAN and L2VPN bridge configurations in the Device Under Test (DUT). Verifications include checking for proper span functionality. Platforms to be tested include the NCS5700. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2dot1pop fordestbunl2dot1pop mirrordesttunnelerspan tcp443",
                "Procedure": "The test_L2L2_srcBunL2Dot1Pop_forDestBunL2Dot1Pop_mirrorDestTunnelErspan_TCP443 test verifies a monitor session with the source as L2_dot1qsub_rewrite interface and the destination as l2Sub, located in Another BVI interface. The SPAN destination is ERSPAN configured on an NCS5700 platform that has both SPAN and L2VPN bridge configurations. Verification includes checking the span configuration, while no triggers are present for this test case, which is identified as FT-16. This test is triggered by: none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2dot1pop fordestbunl2dot1pop mirrordestpwspan tcp443",
                "Procedure": "The test case involves verifying a monitor session with the source as an L2_dot1qsub_rewrite interface and the destination as l2Sub located in Another BVI interface, also including SPAN destination is PWSPAN. The configurations used include SPAN and L2VPN bridge in DUT, while verifications are performed using '-span' commands. This test case has a Testcase ID of FT-17 and can be run on NCS5700 platforms. This test is triggered by no specific conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2main fordestbunl2main mirrordestbunl2main controltraffic",
                "Procedure": "The test combines the flow of L2-L2, L2-L3 and L2-L3-L3-L2 traffic, ensuring that they are handled correctly by the device under test (DUT). It requires configurations involving SPAN (Switched Port Analyzer) and L2VPN bridging on the DUT. The test verifies that the SPAN function is working as expected. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2sub fordestbunl2main mirrordestbunl2main dns tcp qos",
                "Procedure": "This testcase verifies egress qos with span over main bundle interface on an NCS5700 platform running in ETM mode, with a specific setup that includes SPAN and L2VPN bridging in the DUT. The configuration for this test should only be applied on devices with SE cards, and it's essential to have bridge in DUT enabled. To verify the results, check if span is functioning correctly. This test can run on NCS5700 platforms.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2main fordestbunl2main mirrordestbunl2main udp53 removereaddmem",
                "Procedure": "The test case verifies that the span works correctly over the main bundle interface in a configuration with SPAN and an L2VPN bridge in the Device Under Test (DUT). The configuration includes an NCS5700 platform, and the verification involves checking for the presence of a span. This test is triggered by removing and readding a bundle member.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTftp read pcap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2v4 srcbunl2subpop fordestbunl3sub mirrordestbunl2main udp53 triggers",
                "Procedure": "The test case verifies that spanning works correctly over the main bundle interface, using a configuration of SPAN and an L2VPN bridge in the device under test. It involves checking span functionality, with specific configurations including an L2VPN bridge in the DUT, and verifying span operations. This is performed on platforms such as the NCS5700. The testcase ID is HA - 01. This test is triggered by a router reload or a line card reload.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\"",
                "Pass/Fail Criteria": "L2v4 srcbunl2subpop fordestbunl3sub mirrordestbunl2main udp53 verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2main fordestbunl2main mirrordestbunl2main udp53 line rate",
                "Procedure": "The test case verifies that span works fine over the main bundle interface on a device under test configured with L2VPN and an L2 bridge. The configuration involves SPAN, while verifications include only checking for span. The test case ID is FT-00 and it can run on NCS5700 platforms. This test is triggered by the fact that there are no specific triggers involved in this scenario.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main dest local span deny",
                "Procedure": "An Ipv4 ACL with port group and network group is attached to the Physical Main in Egress, using etm with Compress level 3. The testcase verifies an object group with Port type configured on ACE, accepting traffic when packets hit a specified port number and mirroring to a mirror destination. Configurations include setting up a monitor session, configuring an ACL with a capture keyword, attaching the ACL to the monitor session in Egress direction, sending traffic, and verifying packet counts.\n\nThis test is triggered by the absence of any specific triggering condition.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main dest pwspan",
                "Procedure": "An IPv4 access control list (ACL) with port and network groups is attached to the Physical Main in the Egress direction with Ethernet traffic mirroring (ETM) and compression level 3 enabled. The test verifies object group configuration with a port type configured on an access control entry, allowing traffic through when packets match the specified port number and mirroring the traffic to its destination. To achieve this, configurations include setting up a monitor session, configuring the ACL with capture capabilities, attaching it to the monitor session in the Egress direction, sending test traffic, and verifying hardware hit counts on interfaces along with packet counts at the mirror destination.\n\nThis test is triggered by an empty trigger condition.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v6 tx src phy main dest local span",
                "Procedure": "Ipv6 ACLs with port groups and network groups are attached to the Physical Main in Egress with etm, compress level set to 3. The testcase verifies object group configuration for port types on ACEs, allowing traffic to be accepted when packets match a specified port number and mirroring traffic to a destination.\n\nThis test is triggered by the configuration of an ACL with a capture keyword attached to a monitor session in the Egress direction.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy sub dest local span",
                "Procedure": "An Ipv4 ACL with port group and network group is attached to a Physical Sub in Egress, enabled for compression level 3 and ETM. The object group includes ports of type ACE. When packets match the specified port number, they are accepted and mirrored to their destination. To configure this scenario, monitor sessions are created, an ACL is defined with a capture keyword, and attached to the session on the Egress direction. Traffic is then sent and verified by checking hardware hit counts on the interface and packet counts on the mirror destination.\n\nThis test is triggered by the configuration of ACE port types in an object group.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src bun main dest pwspan",
                "Procedure": "An IPv4 ACL with a port group and network group is attached to Bundle Main in the egress direction with ETM (Embedded TDR) enabled and compression level 3. The testcase verifies an object group of Port type on an ACE, accepting traffic when packets match the specified port number and mirroring it to a mirror destination. To configure this scenario, a monitor session is set up using the 'config monitor session' command, followed by configuring the ACL with the 'capture keyword', attaching the ACL to the monitor session in the egress direction, sending traffic, and verifying packet counts on both the interface and mirror destination. The test verifies that hardware hit counts are correct on the interface and packet counts are accurate on the mirror destination.\n\nThis test is triggered by the need to validate the functionality of an IPv4 ACL with a port group and network group attached to Bundle Main in the egress direction.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v6 tx src bun main dest pwspan",
                "Procedure": "An IPv6 ACL with a port group and network group is attached to Bundle Main in the egress direction, using ETM (Enhanced Traffic Mirroring) at Compress level 3. The test verifies an object group with a Port type configured on an ACE that accepts traffic when packets match a specified port number and mirrors them to a mirror destination. Configurations include setting up a monitor session, configuring an ACL with a capture keyword, attaching the ACL to the monitor session in the egress direction, sending traffic, and verifying the packet. Verification is done by checking hardware hit counts on an interface and packet counts on the mirror destination.\n\nThis test is triggered by: The execution of certain network traffic configurations.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src bun sub dest local span",
                "Procedure": "An IPv4 ACL with a port group and network group attached to a Bundle Sub in the egress direction, utilizing Enhanced Transmission Mirroring (ETM) with compression level 3, is verified to be functioning as expected. The configuration includes an object group of type Port and an access control entry that accepts traffic when packets match the specified port number, while mirroring traffic to a mirror destination. To test this scenario, the configuration involves setting up a monitor session, attaching an ACL with capture capabilities to the monitor session in the egress direction, sending traffic, and verifying hardware hit counts on the interface and packet counts on the mirror destination.\n\nThis test is triggered by the user clicking a \"run test\" button or initiating the test through a testing framework.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v6 tx src phy sub dest local span",
                "Procedure": "Ipv4 ACLs with port groups and network groups are attached to a Physical Sub in the egress path, utilizing ETM (Enhanced Traffic Mirroring) with compression level 3. The configuration involves creating an object group of ports and configuring ACEs (Access Control Entries) that mirror traffic to a specified destination when packets match the configured port number. To test this setup, the steps include setting up monitor sessions, attaching ACLs to those sessions in the egress direction, sending traffic through the network, and verifying both hardware hit counts on interfaces and packet counts at the mirror destination.\n\nThis test is triggered by the presence of Ipv4 ACLs with port groups and network groups attached to a Physical Sub in the egress path.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v6 tx src bun sub dest local span",
                "Procedure": "Ipv6 ACLs with port groups and network groups are attached to Bundle Sub in the egress direction with etm compression level 3. The testcase verifies object group configuration with port type on ACE, accepting traffic when packets match specified port numbers and mirroring it to a mirror destination. Configurations include configuring monitor sessions, setting up ACLs with capture keywords, attaching these ACLs to monitor sessions in the egress direction, sending traffic, and verifying packet data. Verifications involve checking hardware hit counts on interfaces and packet counts on mirror destinations.\n\nThis test is triggered by testing Ipv6 ACL configurations.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main dest pwspan traffic not matching",
                "Procedure": "An IPv4 ACL is configured in an Egress physical main sub with a port group and network group, along with a compression level of 3 using the etm feature. The configuration also includes a monitor session with a capture keyword on the ACL and attachment to the monitor session for egress traffic. When this traffic does not match the ACEs on a device configured with an object group containing Port types, a packet is sent and its path is verified in both hardware hit count on the interface and packet count on the mirror destination. This test is triggered by a mismatch between ACL configurations and incoming traffic patterns.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v6 tx src phy main dest local span traffic not matching",
                "Procedure": "Traffic not matching a hybrid IPv6 ACL with both port and network groups attached to the Physical Main in Egress, with Enhanced Transmission Mirroring (ETM) enabled at Compress level 3. The testcase verifies object groups of Port type configured on an Access Control Entry (ACE), by sending traffic that does not match the ACE's criteria. Configurations include setting up a monitor session, configuring an ACL with the capture keyword, attaching the ACL to the monitor session in Egress direction, and sending traffic. Verifications involve checking the hardware hit count on the interface and packet count at the mirror destination. This test is triggered by the need to test that the system correctly handles mismatched traffic for a hybrid IPv6 ACL configuration.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main dest pwspan without capture",
                "Procedure": "An IPv4 ACL with a port group and network group is attached to the Physical Main in egress with ETM (Enhanced Traffic Mirroring) enabled, along with compress level 3. The test verifies an object group with a Port type configured on ACE, accepting traffic when packets hit the specified port number and mirroring to the mirror destination. Configurations include setting up a monitor session, configuring ACL without capture keyword, attaching ACL to monitor session in egress direction, sending traffic, and verifying packets. Verifications involve checking hardware hit count on interface and packet count on mirror destination. This test is triggered by an IPv4 ACL with port group and network group attached to Physical Main in Egress with ETM enabled, along with other specific configurations.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v6 tx src phy sub dest pwspan without capture",
                "Procedure": "An IPv6 ACL with port group and network group attachment is configured in the Physical Sub in the egress path with etm at compression level 3. The object group with Port type configuration is set on an ACE, allowing traffic to be accepted when packets match a specified port number and mirrored to a mirror destination. Configurations include monitoring sessions, ACLs without capture keywords, attaching ACLs to monitor sessions in the egress direction, sending traffic, and verifying packet information.\n\nThis test is triggered by no specific event or condition being present.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src bun main dest pwspan without capture",
                "Procedure": "An IPv4 Access Control List (ACL) with port group and network group is attached to Bundle Main in the egress direction, using EtM with compression level 3 enabled. The ACL includes object groups with port types configured on the Access Control Entries (ACEs), which accept traffic when packets match specific port numbers and mirror the traffic to a destination. Configurations include setting up a monitor session, configuring an ACL with a capture keyword, attaching the ACL to the monitor session in the egress direction, sending traffic, and verifying packet counts.\n\nThis test is triggered by an empty configuration or a test environment not meeting prerequisites.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v6 tx src bun sub dest pwspan without capture",
                "Procedure": "An IPv6 Access Control List (ACL) with a port group and network group is attached to a Bundle Sub in the egress direction, using Ethernet Traffic Manager (ETM) and compress level 3. The ACL verifies object groups with a Port type configuration on an Access Control Entry (ACE), allowing traffic when packets hit equal specified port numbers and mirroring to a mirror destination. Configurations include monitoring sessions, configuring ACLs with capture keywords, attaching ACLs to monitor sessions in the egress direction, sending traffic, and verifying packets. Verifications include checking hardware hit counts on interfaces and packet counts on mirror destinations. This test is triggered by an IPv6 ACL with a port group and network group attached to a Bundle Sub in the egress direction using ETM and compress level 3.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src bun main dest pwspan rem add acl",
                "Procedure": "An IPv4 access control list (ACL) with port groups and network groups is attached to the main bundle in egress direction using Enhanced Transmission Management (ETM) with compression level 3. The test verifies an object group with a port type configured on an access control entry (ACE), accepting traffic when packets match the specified port number, and mirroring it to a mirror destination.\n\nThis test is triggered by the configuration of monitor sessions, ACLs with capture keywords, attaching ACLs to monitor sessions in egress direction, sending traffic, and verifying packet counts.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main dest pwspan rem add diff acl",
                "Procedure": "An IPv4 ACL with a port group and network group is attached to the Physical Main in Egress mode, using ETM with compression level 3. The testcase verifies an object group with a Port type configuration on ACE, accepting traffic when packets match a specified port number and mirroring it to a mirror destination. Configurations include setting up a monitor session, configuring an ACL with a capture keyword, attaching the ACL to the monitor session in Egress direction, removing and re-adding the ACL, sending traffic, and verifying packet configurations. Verifications involve checking hardware hit counts on an interface and packet counts on a mirror destination.\n\nThis test is triggered by the need to verify the functionality of an object group with a Port type configuration on ACE under specific network conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src bun main dest pwspan rem add members",
                "Procedure": "An Ipv4 ACL with port group and network group is attached to Bundle Main in the Egress direction with ETM (Enhanced Traffic Mirroring) at Compress level 3. The test verifies an object group configured on an ACE, accepting traffic when packets match a specified port number and mirroring it to a destination.\n\nThis test is triggered by a configuration where no monitor session is attached to Bundle Main in the Egress direction with ETM.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src bun main dest pwspan add new members",
                "Procedure": "An IPv4 ACL with a port group and network group attached to Bundle Main in the egress path, configured for compression level 3, using Enhanced Transparency Mode (ETM). The object group with port type is set on an ACE, which accepts traffic if it hits ports equal to specified numbers and mirrors the packets to their destinations. The test configurations include monitoring sessions, ACLs with capture keywords, attaching ACLs to monitor sessions in the egress direction, sending traffic, and verifying packet counts.\n\nThis test is triggered by the execution of a test case involving an IPv4 ACL with port groups attached to a bundle in the egress path.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src multiple phy main dest pwspan diff acl",
                "Procedure": "An IPv4 ACL is configured with port groups and network groups attached to a physical switch in the egress path, along with an etm (Enhanced Traffic Monitoring) feature enabled at compression level 3. The test verifies object group configurations on access control entries (ACEs) that filter traffic based on specified port numbers and mirror it to a destination. To accomplish this, the following steps are taken: a monitoring session is configured, an ACL is created with capture keywords, attached to the monitor session in the egress direction, and then used to send traffic. The test verifies hardware hit counts on interfaces and packet counts at the mirrored destination.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nTraffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src multiple bun sub dest pwspan diff acl",
                "Procedure": "An Ipv4 ACL with port group and network group attachment to a Bundle Sub in the egress path, using Enhanced Transmission Mirroring (ETM) with compression level 3. The testcase verifies object groups configured on an ACE for Port type, allowing traffic acceptance when packets match the specified port number and mirroring to a mirror destination. Configurations include setting up a monitor session, configuring ACLs with capture keywords, attaching the ACL to the monitor session in the egress direction, sending traffic, and verifying packets.\n\nThis test is triggered by: The packet's source IP address matches the destination IP address of the bundle sub interface.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 src phy main diff rx tx",
                "Procedure": "Ipv4 ACLs with port groups and network groups are attached to the Physical Main in egress with etm and compress level 3 enabled. The test verifies object groups with port types configured on ACEs, accepting traffic when packets match specified port numbers and mirroring to a mirror destination. Configurations include setting up monitor sessions, configuring ACLs with capture keywords, attaching ACLs to monitor sessions in the egress direction, sending traffic, and verifying packet counts. Verifications involve checking hardware hit counts on interfaces and packet counts on mirror destinations. This test is triggered by none.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main pwspan erspan",
                "Procedure": "A Hybrid acl-etm-v4-tx-src-phy-main-pwspan Ipv4 ACL with port group and network group is attached to the Physical Main in Egress with etm and Compress level 3 configured. The testcase verifies an Object group with Port type configured on an ACE, where traffic is accepted when packets match a specified port number and mirrored to a mirror destination. Configurations include setting up monitor sessions, configuring ACLs with capture keywords, attaching them to the monitor session in Egress direction, sending traffic, and verifying packets. Verifications involve checking hardware hit counts on interfaces and packet counts at mirror destinations. This test is triggered by \"Traffic flows through the specified port number\".",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main erspan pwspan",
                "Procedure": "An Ipv4 ACL with port group and network group is attached to a Physical Sub in the Egress with etm and Compress level 3. The testcase verifies an object group with Port type configured on ACE, accepting traffic when packets hit the specified port number and mirroring to a mirror destination. Configurations include configuring monitor session, ACL with capture keyword, attaching ACL to monitor session in the Egress direction, sending traffic, and verifying packet. Verifications involve checking hardware hit count on an interface and packet count on the mirror destination. This test is triggered by the user selecting an option that requires verification of the specified configuration and behavior.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main pwspan rem rollback ms",
                "Procedure": "This test verifies the functionality of an Ipv4 ACL with a port group and network group attached to a Physical Main in egress, utilizing etm and compression level 3. It checks that object groups with port types configured on ACEs accept traffic when packets match specified port numbers and mirror the traffic to a designated destination. The configurations include creating a monitor session, configuring an ACL with capture keyword, attaching the ACL to the monitor session on the egress direction, sending traffic, verifying packet data, and then removing and rolling back the monitor session. The verification process involves checking hardware hit counts on interfaces and packet counts on mirror destinations.\n\nThis test is triggered by an empty trigger condition (None).",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main dest local span rem add etm",
                "Procedure": "Ipv4 ACLs are configured with port groups and network groups attached to a Physical Main device in the egress direction, using Ethernet Traffic Mirroring (ETM) at Compress level 3. The test verifies that object groups with Port type configurations on Access Control Entries (ACEs) accept traffic when packets match the specified port number, mirroring it to a designated destination. The configuration involves setting up a monitor session, attaching an ACL to the monitor session in the egress direction, sending traffic through capture, and verifying packet counts on both the interface and mirror destination. After removing ETM, the hardware hit count on the interface is also verified. This test is triggered by an external event or condition that requires it to be executed.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main local span rspan",
                "Procedure": "The test consists of verifying an object group with port type configured on an ACE, which accepts traffic when packets match the specified port number and mirrors it to a mirror destination. The configuration involves setting up a monitor session, creating an ACL with capture keyword, attaching the ACL to the monitor session in egress direction, sending traffic, verifying packet details, and changing the mirror destination from local span to rspan. To verify the test's success, hardware hit counts on the interface and packet counts on the mirror destination are checked.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main rspan local span",
                "Procedure": "The testcase tests an Ipv4 ACL with port group and network group attached to a Physical Main in Egress with ETM, using Compress level 3. It verifies object groups with Port type configured on ACEs, accepting traffic when packets hit the specified port number and mirroring to a mirror destination. The configuration includes a monitor session, an ACL with capture keyword, attaching the ACL to the monitor session in Egress direction, sending traffic, verifying packets, and changing the mirror destination from RSPAN to local SPAN. Verification involves checking hardware hit count on interface and packet count on mirror destination.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 v6 src phy main tx rx erspan",
                "Procedure": "A test case for a hybrid ACL with ETM (Encapsulated To Match) verifies object group configuration on an ACE (Access Control Entry). The test configures port groups, network groups, and attaches them to the physical main interface in both egress and ingress directions with ETM and compression level 3. It captures traffic using the \"capture\" keyword in the ACL, mirrors it to a destination using ERSPAN, and verifies that packets are correctly accepted when matching specified ports and mirrored. Hardware hit counts on interfaces and packet counts on mirror destinations are verified.\n\nThis test is triggered by the need to ensure correct operation of object group configuration with port types on an ACE.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 v6 src bun main rx tx pwspan",
                "Procedure": "An Ipv4 ACL with port group and network group is attached to the Physical Main in both Egress and Ingress directions, utilizing etm and compression level 3. The configuration involves creating a monitor session, configuring an ACL with a capture keyword, attaching the ACL to the monitor session on both ingress and egress paths, sending traffic, verifying packet counts, and mirroring to a destination using pwspan. Hardware hit counts are verified on the interface and packet counts on the mirror destination. This test is triggered by the need to verify object group settings with Port type configured on ACEs for traffic matching specific port numbers and mirroring of packets to their specified destinations.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 v6 src phy sub rx tx pwspan",
                "Procedure": "A test for Ipv4 ACL with port group and network group attachment to a Physical Sub in both Egress and Ingress directions, using Ethernet Tag Matching (etm) compression level 3. The test verifies object groups with Port type configuration on Access Control Entries (ACEs), allowing traffic acceptance when packets match specified port numbers and mirroring the traffic to a mirror destination over pwspan.\n\nThis test is triggered by an unspecified condition.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 v6 src bun sub rx tx pwspan",
                "Procedure": "An Ipv4 ACL with port group and network group is attached to a Bundle sub in both Egress and Ingress directions using etm with Compress level 3. The testcase verifies an object group configured for Port type on the ACE, accepting traffic that hits specified port numbers and mirroring packets to a destination. Configurations include setting up a monitor session, configuring ACLs with capture keywords, attaching these to the monitor session in both Egress and Ingress directions, sending traffic, and verifying packets. Verifications involve checking hardware hit counts on interfaces and packet counts at the mirror destinations.\n\nThis test is triggered by a None trigger.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main pwspan process restart",
                "Procedure": "An IPv4 ACL with a port group and network group is attached to the Physical Main in egress with etm and compress level 3 enabled. The configuration includes configuring an object group with a port type ACE, accepting traffic when packets hit the specified port number, and mirroring traffic to a destination. To test this setup, a config monitor session is created, along with an ACL using the capture keyword, which is then attached to the monitor session in egress direction. Traffic is sent, and the verification process involves checking the hardware hit count on an interface and packet count on the mirror destination. This test is triggered by none of the specified conditions.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main pwspan process restart not supported",
                "Procedure": "An IPv4 ACL with port group and network group attachment to a Physical Main in egress, using etm with Compress level 3, is tested for object group configuration with Port type ACE. The traffic acceptance verifies when packets match the specified port number, mirroring to the mirror destination. Configurations include setting up a monitor session, configuring an ACL with a capture keyword, and attaching it to the monitor session in egress direction. Traffic is then sent and packet verification occurs by checking hardware hit count on the interface and packet count on the mirror destination.\n\nThis test is triggered by attachments of IPv4 ACLs with port groups to Physical Main devices.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main pwspan triggers",
                "Procedure": "Ipv4 ACLs are tested with port groups and network groups attached to a Physical Main in the egress path, using etm compression at level 3. The testcase verifies object group configurations for Port types on ACEs, accepting traffic that matches specified port numbers and mirroring it to the mirror destination. Configurations include setting up monitor sessions, configuring ACLs with capture keywords, attaching them to monitor sessions on the egress path, sending traffic, and verifying packets. Verifications involve checking hardware hit counts on interfaces and packet counts at the mirror destinations.\n\nThis test is triggered by the absence of any specific conditions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Span hybrid acl etm v4 tx src phy main dest pwspan verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src bun main pwspan stress",
                "Procedure": "An Ipv4 ACL with a port group and network group is attached to Bundle Main in Egress mode, using etm with Compress level 3. The testcase verifies an object group with Port type configured on ACE, accepting traffic when packets match the specified port number and mirroring it to a mirror destination. Configurations include setting up a monitor session, configuring an ACL with the capture keyword, attaching the ACL to the monitor session in Egress direction, sending traffic, verifying packet reception, removing and re-adding the ACL. Verifications involve checking hardware hit count on the interface and packet count on the mirror destination. This test is triggered by configuration changes made to the monitor session or attached ACL.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"pw_flaps\" and \"add_rem_bun_int\" and \"add_rem_bun_mem\" and \"add_rem_ms\" and \"add_rem_acl_keyword\"",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src phy main add rem tunnel ip",
                "Procedure": "The testcase tests Ipv6 ACLs with port groups and network groups attached to the Physical Main in Egress with ETM (Enhanced Traffic Mirroring) at a Compress level of 3. It verifies object group configurations with port types on ACEs, accepting traffic that hits specified ports and mirroring packets to their destinations. To configure this scenario, ACLs are created with capture keywords, attached to monitor sessions in the Egress direction, and packet traffic is sent for verification. Verifications include checking hardware hit counts on interfaces and packet counts on mirror destination endpoints.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src bun main dest pwspan ping",
                "Procedure": "An IPv4 ACL with a port group and network group is attached to a Physical Bundle in Egress with ETM, and compression level 3 is enabled. The test verifies an object group with a Port type configuration on ACE by accepting traffic when packets hit the specified port number. The configurations include a Port Object group with equal to 1024 port number and Network group, as well as an IPv4 ACL with ACE containing object groups with Compress level 3. The ACL is then attached to a Physical interface in Egress direction and traffic is sent. The test verifies that packets with an equal to port number of 1024 hit the ACE.\n\nThis test is triggered by a configuration with no specific trigger specified.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span hybrid acl etm v4 tx src multiple phy sub pwspan scale",
                "Procedure": "A hybrid ACL with IP version 4, port group, and network group attached to a physical subinterface in the egress direction with enhanced transparent mode (ETM) compression level 3 is tested. The object group with port type configured on an access control entry (ACE) accepts traffic when packets match the specified port number and mirrors it to a destination. To test this, configure a monitor session, set up ACLs with capture keywords, attach them to the monitor session in the egress direction, send traffic, and verify packet counts. The configurations include setting up ACLs with capture keywords and attaching them to the monitor session, while verifications involve checking hardware hit counts on interfaces and packet counts at mirror destinations. This test is triggered by a specific event or action that is currently not specified.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nTraffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "span_local_scale_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Span scale 24 sess dest sep rx tx",
                "Procedure": "To verify traffic with a 24-scale span, configure Layer 2 and Layer 3 physical and bundle main interfaces, as well as their corresponding subinterfaces for receive and transmit traffic. Configure the source interface to be a main interface, the destination receiver interface to be a subinterface, and the destination transmitter interface to also be a subinterface.\n\nThis test is triggered by none of the listed conditions.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 12 rxtx 6 rx 6 tx",
                "Procedure": "The test verifies 12 sessions with both receive and transmit mirroring, and 6 each with only receive or only transmit mirroring enabled. It checks traffic using Layer 2, Layer 3 physical, bundle main interfaces as sources, and different destination Layer 2 subinterfaces for the receive and transmit traffics. The test involves configuring Layer 2/3 physical/bundle main/sub interfaces and the Span CLI configuration.\n\nThis test is triggered by specific network conditions or events that are not specified (None).",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 24 session legacy",
                "Procedure": "To verify the 24 scale span, traffic is sent to common receiver and transmitter destinations using source interfaces with layers 2 and 3 physical or bundle main interfaces and different layer 2 sub interfaces for receive and transmit traffics. The test involves configuring layer 2 and 3 physical and bundle main and sub interfaces as well as the Span CLI. The configurations and verifications are based on Span, while there are no triggers for this testcase.\n\nThis test is triggered by the absence of any external events or conditions that could initiate it.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale trigger 24 sess dest sep rx tx cscvx91273 cscvx89026",
                "Procedure": "Traffic verification involves configuring Layer 2 and Layer 3 interfaces, including bundle main and sub-interfaces, as well as source and destination for receive and transmit traffics. The Span CLI is also configured to monitor this traffic. SPAN verifications confirm that the Span configuration is correct. This test is triggered by none.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span proc res scale 24 sess dest sep rx tx",
                "Procedure": "This test verifies traffic with source as layer 2 or 3 physical or bundle main interfaces and different destination layer 2 subinterfaces for receive and transmit traffics. Configurations include setting up layer 2/3 physical/bundle main/sub interfaces, while also configuring the span CLI. Verifications involve checking the SPAN configuration. This test is triggered by selecting a test case with no specific trigger action.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_res: \"span_ea\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span 24 scale unconfig config sep rx tx",
                "Procedure": "The test-case verifies traffic with source as layer 2, layer 3 physical or bundle main interfaces and different destination layer 2 subinterfaces for receive and transmit traffics. It configures the layer 2/layer 3 physical/bundle main/sub interfaces and the span CLI. The configurations include the SPAN setup, while verifications also focus on the SPAN functionality.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 24 sess dest sep rx tx to legacy",
                "Procedure": "The traffic verification for this test-case involves verifying 24 scale span with different conversions of rx/tx destinations to rx or tx only and then to legacy. It verifies traffic with source as l2 / l3 physical / bundle main interfaces and different destination l2 sub interfaces for rx and tx traffics, including configuring l2/l3 physical/bundle main/sub interfaces and the Span CLI. The configurations and verifications are based on Span requirements.\n\nThis test is triggered by the absence of any specific conditions.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 24 sess sep rx tx to rx only",
                "Procedure": "To verify the 24 scale span, traffic is sent from different source interfaces (including L2 and L3 physical and bundle main interfaces) to various destination subinterfaces for both receive and transmit traffic.\n\nThis test is triggered by changes in system configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 24 sess legacy to sep rx tx",
                "Procedure": "The test verifies traffic with source as L2, L3, physical, bundle main interfaces and different destination L2 sub interfaces for RX and TX traffics. It configures L2/L3 physical/bundle main/sub interfaces and Span CLI settings. The verification involves checking the Span settings. This test is triggered by the absence of any configurations that would prevent it from running.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 24 sess legacy to rx only",
                "Procedure": "The test verifies traffic with source as L2 or L3 on physical, bundle, or subinterfaces and different destinations for Rx and Tx traffics. It involves configuring L2/L3 interfaces, main/sub interfaces, and the SPAN CLI, then verifying the results of this configuration. The source is typically an L2 or L3 interface, while the destination varies between subinterfaces for Rx and Tx traffics. This test is triggered by a specific condition, but none are specified at present.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 25th session fail cscvx71644",
                "Procedure": "Traffic with source as l2 / l3 physical / bundle main interfaces and different destination l2 sub interfaces for rx and tx traffics is verified in this test-case. It configures l2/l3 physical/bundle main/sub interfaces, and span CLI configurations are set up accordingly. The verifications include checking the span functionality on all configured interfaces, with no triggers specified.\n\nThis test is triggered by -None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 24 sess sep rx tx with eoam cscvx92709",
                "Procedure": "The test verifies traffic with a source interface and different destination interfaces for receive and transmit traffics. It checks the configuration of layer 2, layer 3 physical and bundle main and sub-interfaces, as well as Span CLI. The test case involves configuring these interfaces and verifying the Span settings.\n\nThis test is triggered by verification of CSCvx92709 on test_span_scale_24_sess_sep_rx_tx_with_eoam.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nOam discovery interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 24 sess sep rx tx with eoam reverse cscvx92709",
                "Procedure": "The test case verifies traffic with a source of L2/L3 physical or bundle main interfaces and different destination L2 subinterfaces for RX and TX traffics. It configures the L2/L3 physical or bundle main/sub interfaces and sets up the span CLI configuration. The verification process checks the SPAN settings, while the trigger is currently set to none.\n\nThis test is triggered by the absence of any specified triggers.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nOam discovery interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 12 sess dest sep rx tx",
                "Procedure": "This test verifies traffic with source as L2 or L3, on either a physical interface or a bundle main interface, and different destination L2 sub interfaces for both receive and transmit traffics. Configurations include setting up the L2/L3 physical/bundle main/sub interfaces and configuring the Span CLI, which is used to monitor network traffic. The test then verifies that the Span configuration is correct by checking the Span settings. This test is triggered by a specific event or condition: None.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 6 rxtx 3 rx 3 tx",
                "Procedure": "The test consists of verifying 12 sessions with both receive and transmit mirroring, as well as six sessions each for receive-only and transmit-only mirroring. It also verifies traffic with source interfaces being Layer 2/3 physical or bundle main interfaces and different destination subinterfaces for the receive and transmit traffics. This is done through configurations of Layer 2/Layer 3 physical/bundle main/sub interfaces and span CLI, followed by verifications of SPAN settings.\n\nThis test is triggered by mirroring on both the receive and transmit sides.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 12 sess legacy",
                "Procedure": "This text-case verifies traffic with source as L2 / L3 physical / bundle main interfaces and different destination L2 subinterfaces for RX and TX traffics, where the source is configured on L2/L3 physical/bundle main interfaces and the destination is a variety of L2 subinterfaces. Configurations include setting up L2/L3 physical/bundle main/sub interfaces and configuring SPAN CLI. The verifications to be performed involve checking SPAN operation. \n\nThis test is triggered by the lack of any source or destination conditions that would prevent its execution.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span proc res scale 12 sess dest sep rx tx",
                "Procedure": "The test verifies traffic with source as layer 2, layer 3 physical or bundle main interfaces and different destination layer 2 sub-interfaces for receive and transmit traffics. It configures the layer 2/layer 3 physical/bundle main/sub interfaces and span CLI configurations before verifying that the span is set up correctly.\n\nThis test is triggered by the absence of any other tests in the same session.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_res: \"span_ea\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src main sub same port config unconfig",
                "Procedure": "Traffic with source as L2 or L3 physical or bundle main interfaces and different destination L2 subinterfaces for RX and TX traffics is verified. Configurations include attaching the main and sub parts of a main interface to two separate sessions, as well as setting up L2/L3 physical/bundle main/sub interfaces and Span CLI configurations. The test verifies that these settings work properly. This test is triggered by enabling the Span feature in the system configuration.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan scale 12 sess",
                "Procedure": "The test case verifies traffic with source as layer 2/layer 3 physical/main and bundle interfaces, and different destination layer 2 sub-interfaces for receive and transmit traffics. Configurations include setting up the layer 2/layer 3 physical/bundle main/sub interfaces and configuring the Span CLI. Verifications focus on checking the Span settings.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mix 6 span 6 erspan sess",
                "Procedure": "This paragraph describes a network test case that verifies traffic flow using a specific configuration of Layer 2 and Layer 3 interfaces, including physical and bundle main/sub interfaces, with the source located on an L2/L3 physical/bundle main interface and different destination L2 sub-interfaces for receive and transmit traffics. The test case involves configuring these interfaces and enabling the Span CLI. \n\nThis test is triggered by traffic between two endpoints on a network.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src sub udf",
                "Procedure": "Traffic verification with source as L2 or L3 physical, bundle main interfaces and different destination L2 sub interfaces for RX and TX traffics involves configuring L2/L3 physical/bundle main/sub interfaces and SPAN CLI. Configurations include setting up SPAN. Verifications check that the SPAN is set correctly. This test is triggered by configuring a new network interface or changing an existing one's settings, presumably prompting the need to verify traffic routing.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span with multiple encap dot1q dot1ad",
                "Procedure": "Traffic verification for Layer 2 and Layer 3 interfaces, including bundle main and sub-interfaces, as well as Layer 2 sub-interfaces for receive and transmit traffic, is confirmed when Span (Switched Port Analyzer) configurations are applied to source interface with both dot1q and dot1ad protocols. This test-case verifies traffic with source as l2 / l3 physical / bundle main interfaces and different destination l2 sub interfaces for rx and tx traffics. Configurations include setting up Layer 2/Layer 3 physical/bundle main/sub interfaces, configuring the Span CLI, and SPAN settings. The verification checks the actual span configuration.\n\nThis test is triggered by the absence of any specific trigger conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale with rewrites on src intf",
                "Procedure": "The test verifies traffic with a source as either Layer 2, Layer 3, physical, or bundle main interfaces and different destination Layer 2 subinterfaces for receive and transmit traffics. It involves configuring Layer 2/3 physical/bundle main/sub interfaces, setting up the Span CLI configuration, and verifying that the Span is correctly configured.\n\nThis test is triggered by no specific condition being applied.",
                "Pass/Fail Criteria": "Span scale 12 sess dest sep rx tx verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span two sep session src main sub",
                "Procedure": "The traffic verification test checks the 12-scale span for different receiver and transmitter destinations. It verifies that traffic flows through L2/L3 physical/bundle main interfaces and various destination L2 sub-interfaces for both receive and transmit traffics. The test assumes that source main and sub interfaces of the same main interface are attached to two separate sessions. Configurations involve setting up L2/L3 physical/bundle main/sub interfaces and Span CLI, while verifications check that the Span function is operational.\n\nThis test is triggered by the absence of any triggers specified in its configuration.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span trigger scale 12 sess dest sep rx tx",
                "Procedure": "This traffic verification test verifies the operation of an L2/L3 physical or bundle main interface as a source for both Rx and Tx traffic, with different destination L2 sub-interfaces. It configures L2/L3 physical/bundle main/sub interfaces and sets up Span CLI configurations to monitor traffic. The test then checks that Span is working correctly by verifying the monitored traffic. The test scenario is triggered by Router Reload, LC Reload, or RPFO events.\n\nThis test is triggered by Router Reload, LC Reload, RPFO.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Span scale 12 sess dest sep rx tx verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw 24 sess dest sep rx tx",
                "Procedure": "The test verifies traffic with source as either layer 2 or 3 physical, bundle, or main interfaces and different destination layer 2 subinterfaces for receive and transmit traffics. It configures the layer 2 and 3 physical and bundle main and subinterfaces as well as the Span CLI configuration, and then uses this to verify that the Span is working correctly. This test is triggered by a system administrator choosing to run it in the testing environment.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src l2 sub dest sep rx tx main",
                "Procedure": "This test-case verifies traffic with source as L2 sub-interfaces and different destination L2 main interfaces for RX and TX traffics, involving configurations of physical or bundle interfaces at the L2 or L3 layer, setting up a Span CLI configuration, and checking the operation of the span feature.\n\nThis test is triggered by network events related to spanning tree protocol (STP) configuration changes.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src l3 sub dest sep rx tx main",
                "Procedure": "The test verifies traffic with a source as L2 sub-interfaces and different destination L2 main interfaces for receive and transmit traffic. It configures both L2 and L3 physical or bundle main and sub interfaces, and sets up the SPAN CLI configuration. The verification process checks the configured SPAN settings. This test is triggered by the absence of any other trigger conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span rx src l2 sub dest l2 main",
                "Procedure": "The test verifies traffic with source as L2 sub-interfaces and different destination L2 main interfaces for receive and transmit traffics. The configuration includes setting up L2/L3 physical/bundle main/sub interfaces, and configuring the SPAN CLI. The verification checks that the SPAN is working correctly.\n\nThis test is triggered by a manual intervention, with no automated trigger required.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span rx src l3 sub dest l3 main",
                "Procedure": "The test verifies traffic between a source with Layer 2 subinterfaces and different destination Layer 2 main interfaces for both receive and transmit traffic. It involves configuring Layer 2 and 3 physical and bundle main and sub interfaces, as well as the Span CLI. The test consists of verifying Span configurations and traffic.\n\nThis test is triggered by no specific condition.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span src l2 main and sub dest main",
                "Procedure": "The test case verifies traffic with source as L2 sub-interfaces and different destination L2 main interfaces for both receive and transmit traffics, while configuring the physical or bundle main and sub-interfaces, and setting up a SPAN configuration through the CLI. Configurations include enabling L2/L3 main and sub-interfaces, and configuring the SPAN feature using the command-line interface. The test's verifications involve checking that the SPAN is properly configured and functioning as expected. \n\nThis test is triggered by a specific set of circumstances in which no conditions are met.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pwspan src l3 sub dest pw",
                "Procedure": "L2/L3 traffic with source as sub interface and different destination as main interface is verified in this test-case, which checks the configuration of physical and bundle main and sub interfaces, as well as Span CLI configurations. The SPAN verification involves verifying the Span functionality itself.\n\nThis test is triggered by the absence of any specific conditions or events.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2l2 srcbunl2main fordestbunl2main mirrordestbunl2main udp53 24 scale",
                "Procedure": "Traffic with source as L2/L3 physical/bundle main interfaces and different destination L2 subinterfaces for RX and TX traffics is verified in this test-case. The test-case configures L2/L3 physical/bundle main/sub interfaces and sets up the span CLI to verify that the Span configurations are working correctly. \n\nThis test is triggered by a lack of any trigger condition, implying it should run by default.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span source dest l3 phy main rx v4 with acl dscp bitmask 7 mirror session",
                "Procedure": "Traffic with a source and destination of Layer 3 physical interfaces for IPv4 packets in the receive direction with an Access Control List (ACL) enabled on the interface without specifying the ACL keyword, as well as seven mirror sessions, is verified in this test case. The configuration includes the Layer 3 physical main interface set up as both the source and destination, as well as the mirror interfaces, along with a Span Command-Line Interface (CLI), OSPF routing protocol, and IPv4 ACL with DSCP and bitmask configurations. The verifications include traffic on a physical Layer 3 monitor session. This test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "span_mix_scale_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Config lspan sessions",
                "Procedure": "Local span sessions can be configured to monitor network traffic on specific interfaces, and this test-case demonstrates how to do so. It sets up local span sessions with configurations including l2/l3 physical/bundle main/sub interfaces and the span CLI configuration. The test covers both SPAN setups and verifications, but it does not include any actual verification steps. This test is triggered by a lack of available resources or network connectivity issues.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Config span to file sessions",
                "Procedure": "Configuring span to file sessions involves configuring the network so that both L2/L3 physical and bundle main/sub interfaces are set up for spanning, as well as configuring the Span CLI. The configurations are centered around SPAN, while the verifications focus on ensuring no issues arise from this setup.\n\nThis test is triggered by no specific condition.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Span scale with max lspan max erspan max stf",
                "Procedure": "A monitoring system checks the status of full-scale and traffic mirroring on a network by verifying the total number of maximum span sessions, which includes configuring layer two and three physical and bundle main and sub interfaces, as well as enabling the Span CLI configuration. The verification process involves checking the monitor session status and ensuring that traffic mirroring is functioning properly. This test is triggered by none.",
                "Pass/Fail Criteria": "Monitor session internal verification is performed.\nTraffic verification is performed.\nErspan status grev6 verification is performed.\nErspan status grev4 verification is performed.\nLocal span status verification is performed.\nSpan to file status verification is performed.\nMonitor session status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale move stf to lspan",
                "Procedure": "This test-case verifies the monitor session status after moving a span to a file session, which then moves to a local span. Configurations include setting up l2 and l3 physical or bundle main and sub interfaces, as well as configuring the span using the CLI. The verifications check that the monitor session status is correct, as well as the state of the source and destination interface. \n\nThis test is triggered by no specific event.",
                "Pass/Fail Criteria": "Monitor session internal verification is performed.\nTraffic verification is performed.\nSpan scale with max lspan max erspan max stf verification is performed.\nErspan status grev6 verification is performed.\nErspan status grev4 verification is performed.\nLocal span status verification is performed.\nLspan3 lspan4 status verification is performed.\nConfig span to file sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale move lspan to stf",
                "Procedure": "When configuring a monitor session to track an lspan session that has been moved from one span to another, the status of the monitor session can be verified along with the states of both the source and destination interfaces involved in the process.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Monitor session internal verification is performed.\nTraffic verification is performed.\nSpan scale with max lspan max erspan max stf verification is performed.\nErspan status grev6 verification is performed.\nErspan status grev4 verification is performed.\nSpan to file status verification is performed.\nConfig lspan sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale move stf erspanv6",
                "Procedure": "This test-case verifies the monitor session status after moving one stf session to erspan grev6. It involves configuring l2/l3 physical/bundle main/sub interfaces and span CLI configurations, with verifications including monitor session status and source and destination interface state. \n\nTrigger: This test is triggered by none.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan scale with max lspan max erspan max stf verification is performed.\nErspan status grev6 verification is performed.\nErspan status grev4 verification is performed.\nLocal span status verification is performed.\nSpan to file status verification is performed.\nNew erspan grev6 verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale move erspanv6 lspan1 erspanv4 stf1",
                "Procedure": "A test-case verifies the monitor session status after moving one erspanv6 to lspan1 and another to stf1. The process involves configuring the main and sub interfaces of both physical and bundle layers, as well as setting up span through the CLI. Configurations include setting SPAN, while verifications involve checking the monitor session status, source, and destination interface state.",
                "Pass/Fail Criteria": "Span status verification is performed.\nErspan status grev6 verification is performed.\nErspan status grev4 verification is performed.\nTraffic verification is performed.\nSpan scale with max lspan max erspan max stf verification is performed.\nLocal span status verification is performed.\nSpan to file status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale 5th erspan 5th lspan stf negative",
                "Procedure": "Configuring extra sessions should not be allowed, so this test-case verifies that they are disabled. It does this by setting up an L2 or L3 physical or bundle main or sub interface and configuring the span CLI, with configurations related to SPAN. The verification includes checking the status of monitor sessions as well as the state of source and destination interfaces.",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            },
            {
                "Test Case Name": "Span scale process restart",
                "Procedure": "When a process restarts, this test-case verifies the monitor session to ensure it's functioning correctly after the restart. To set up the test, it configures the main and sub interfaces for both L2 and L3 physical and bundle connections, and also configures the SPAN feature through the CLI. The verification steps include checking the status of the monitor session and the state of the source and destination interfaces.",
                "Pass/Fail Criteria": "Span scale with max lspan max erspan max stf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale process crash",
                "Procedure": "To verify the monitor session status after a process crash, configure l2/l3 physical/bundle main/sub interfaces, as well as span CLI configurations. The configurations include setting up SPAN and verifying that the monitor session status is correct, along with checking the state of the source and destination interface. This test-case does not trigger any specific events or conditions during its execution.",
                "Pass/Fail Criteria": "Span scale with max lspan max erspan max stf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale with netflow",
                "Procedure": "To verify the monitor session with netflow, configure l2/l3 physical/bundle main/sub interfaces and set up span CLI configurations using SPAN. The verifications include checking the status of the monitor session, as well as the state of the source and destination interfaces. This test is triggered by None.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale with qos",
                "Procedure": "The test case verifies the monitor session status with Quality of Service (QoS) configured on L2/L3 physical/bundle main/sub interfaces, as well as the Span CLI configuration. The test configurations include setting up a Switched Port Analyzer (SPAN), and the verifications check that the monitor session is working correctly, including verifying the state of the source and destination interfaces. This test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "Show policy map interface verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale tos ttl",
                "Procedure": "The test-case verifies the monitor session status by configuring l2/l3 physical/bundle main/sub interfaces, as well as the span CLI. The configurations include setting up a SPAN, and the verifications check that the monitor session status is correct, along with the source and destination interface state. This test is triggered by none.",
                "Pass/Fail Criteria": "Span scale with max lspan max erspan max stf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span interface trigger",
                "Procedure": "To verify the monitor session status after moving a stf session to erspan grev6, one must configure l2/l3 physical/bundle main/sub interfaces and span CLI settings. Configurations for Span are made in this process, and verifications include monitoring session status, as well as source and destination interface state. The test case ID is SPAN:CLI:001, which has no triggers associated with it.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span scale with max lspan max erspan max stf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span scale with acl",
                "Procedure": "The test case verifies the status of a monitor session with Access Control List (ACL) configuration. It involves configuring L2/L3 physical or bundle main/sub interfaces and setting up Span CLI configurations, including source and destination interface states. The verification process checks the monitor session status and the state of the source and destination interfaces.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span commit replace",
                "Procedure": "The test-case verifies the monitor session status after performing a commit replace operation. It involves configuring l2/l3 physical/bundle main/sub interfaces, setting up span CLI configurations, and checking for the following verifications: monitor session status, source and destination interface state. The test is identified by the ID SPAN:CLI:001.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "Span scale with max lspan max erspan max stf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan eight session",
                "Procedure": "To verify monitor session status with eight Ethernet Remote Switched Port Analyzer (ERSPAN) sessions, the test-case configures Layer 2 and Layer 3 physical and bundle main and sub-interfaces, as well as enables Spanning Tree Protocol through the command-line interface. The configurations include Setting up a SPAN environment. Verifications include checking the monitor session status and confirming that source and destination interfaces are in the correct state.",
                "Pass/Fail Criteria": "Monitor session internal verification is performed.\nTraffic verification is performed.\nErspan status grev6 verification is performed.\nErspan grev6 new verification is performed.\nErspan status grev4 verification is performed.\nErspan grev4 new verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span trigger",
                "Procedure": "A test case verifies the status of a monitor session after triggering it, which involves configuring l2/l3 physical/bundle main/sub interfaces and setting up span CLI configurations. The verification checks include monitoring the session status, as well as ensuring the source and destination interface states are correct. This test is triggered by None.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload\" and \"rpfo\"",
                "Pass/Fail Criteria": "Span scale with max lspan max erspan max stf verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "span_pw_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Src l3 bun main dest pw rx v4 v6",
                "Procedure": "The test case verifies that traffic with its source as the L3 main bundle and destination as a PW can be successfully monitored. To achieve this, it configures the L3 bundle main interface, sets up a Span session on the interface using the Span CLI, and enables OSPF routing protocols. The test uses configurations involving PW SPAN, OSPF, and MPLS to monitor traffic with a monitor session enabled on the L3 main bundle. This test is triggered by none of the specified tests.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src phy main dest pw rx v4 v6",
                "Procedure": "Traffic with a source of the main interface and a destination of PW for both IPv4 and IPv6 incoming traffic is verified in this test-case. It involves configuring the L3 physical main interface, setting up the SPAN CLI, and enabling OSPF. The configurations include SPAN and OSPF settings. Verification checks that traffic is being monitored on the physical main interface with a monitor session enabled. This test-case is identified by Testcase IDs SPAN_PW_FF_002, SPAN_PW_FF_010, and SPAN_PW_FF_029.\n\nThis test is triggered by no specific events or conditions.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 bun main dest pw tx v4 v6",
                "Procedure": "Traffic verification is performed for IPv4 and IPv6 egress traffic with a source of L3 main bundle and a destination of PW. The configuration includes setting up the L3 main interface, enabling Span, configuring OSPF, and entering SPAN CLI commands. The verification process involves checking traffic on the physical L3 main bundle when a monitor session is activated. This test-case has an ID of SPAN_PW_FF_005, SPAN_PW_FF_010, or SPAN_PW_FF_029. \n\nThis test is triggered by no specific event.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src phy main dest pw tx v4 v6",
                "Procedure": "The test-case verifies IPv4 and IPv6 egress traffic with the source as Layer 3 physical and the destination as a Pseudowire (PW). It involves configuring a main interface, setting up SPAN and OSPF, and then monitoring traffic on the physical bundle while a session is active. The configurations include SPAN and OSPF settings, and verifications are based on successful traffic flow through the monitor session with the main interface. This test is triggered by configuration changes that require no specific actions or inputs.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 bun sub dest pw rx v4 v6",
                "Procedure": "The test verifies traffic with source as an L3 bundle subinterface and destination as a PW for both IPv4 and IPv6 ingress traffic. To achieve this, the following configurations are set up: an L3 bundle subinterface is configured, a Span CLI configuration is put in place, and OSPF is configured. The verification process includes checking traffic with a monitor session on the physical L3 bundle subinterface.\n\nThis test is triggered by none.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src phy sub dest pw rx v4 v6",
                "Procedure": "Traffic verification for both IPv4 and IPv6 ingress flows requires configuring the physical sub interface as the source and the destination as a pseudowire (PW). The test case involves setting up a physical sub interface, configuring the Span CLI, and configuring OSPF routing. Configurations include enabling SPAN and OSPF protocols. Verification is done by checking traffic with a monitor session on the physical L3 sub interface. Testcases SPAN_PW_FF_006, SPAN_PW_FF_010, and SPAN_PW_FF_029 are affected by this setup. This test is triggered when no specific condition is met.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l3 bun sub dest pw tx v4 v6",
                "Procedure": "To verify span traffic for IPv4 and IPv6 egress traffic, the source interface must be an L3 main bundle subinterface and the destination must be a PW. The configurations required include configuring the L3 bundle subinterface, enabling SPAN using the CLI, and setting up OSPF routing. To ensure that this test case is triggered correctly, there are no specific requirements or prerequisites to meet.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src phy sub dest pw tx v4 v6",
                "Procedure": "To verify span traffic for both IPv4 and IPv6 egress traffic with source as L3 physical sub and destination as PW, the configurations include setting up an L3 physical sub interface, configuring a monitor session using the Span CLI, and configuring OSPF routing. The verifications involve checking that traffic is being monitored on the physical L3 subinterface with a monitor session in place. This test-case ID matches SPAN_PW_FF_008, SPAN_PW_FF_010, or SPAN_PW_FF_029.\n\nThis test is triggered by: No triggering conditions apply.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src phy main dest pw different streams rx",
                "Procedure": "Ingress traffic mirroring over pseudowire (PW) sending TCP, UDP, ICMP, MULTICAST, FTP, ARP, MPLS and IPv4 Fragmented traffic is verified in this testcase. The configuration involves SPAN and OSPF, while the verification process ensures that different streams of traffic are properly mirrored to the PW. \n\nThis test is triggered by the absence of any specific triggering conditions.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src phy main dest pw different streams tx",
                "Procedure": "Egress traffic mirroring over a pseudowire (PW) sends TCP, UDP, ICMP, MULTICAST, FTP, ARP, MPLS, and IPv4 Fragmented traffic for verification. The configuration involves SPAN and OSPF protocols. Verification checks include ensuring that traffic is properly mirrored to the PW with different streams.\n\nThis test is triggered by the absence of any specific conditions.",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nL2vpn xconnect verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pw span qos",
                "Procedure": "To test Quality of Service (QOS) and Spanning Port (SPAN) over Point-to-Point Protocol (PW), attempt to configure QOS and verify its behavior with SPAN over PW. For incoming packets, the Quality of Service settings are applied before mirroring occurs. Conversely, for outgoing packets, the mirroring takes place after the Quality of Service settings have been applied. The test procedures involve configuring both SPAN and QOS, then verifying that the configuration is correctly implemented.\n\nThis test is triggered by the need to configure and verify the interaction between QOS and SPAN over PW.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nShow policy map interface verification is performed.\nL2vpn xconnect verification is performed.\nFor ingress, packets are mirrored before QOS.  For egress,packets are mirrored after QOS verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pw span acl v4 v6 rx",
                "Procedure": "The test verifies the behavior of Span over PW with an Access Control List (ACL) configured on the main interface in the ingress direction. To accomplish this, it configures a Layer 3 bundle on the main interface, sets up Span via CLI, and enables OSPF. The necessary configurations include PW Span, OSPF, and ACL. During verification, packets are mirrored before they encounter the ACL for ingress traffic, and Span continues to mirror all traffic, including regular traffic that is dropped by the ACL. This test is triggered by no specific events.",
                "Pass/Fail Criteria": "Interface state verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw fi 001",
                "Procedure": "When a VPWS PW redundancy situation arises with SPAN over PW, this test case is triggered by a scenario in which the primary and backup pseudowires are configured. In such an event, if there's an issue with the primary pseudowire or the adjacency on the remote provider edge router, the other router should promptly activate the backup pseudowire. The test procedure involves configuring a layer 2 bundle sub-interface for SPAN.\n\nThis test is triggered by a scenario in which the primary and backup pseudowires are configured and one of them encounters an issue with the primary pseudowire or the adjacency on the remote provider edge router.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nL2vpn xconnect verification is performed.\nSPAN over PW - with VPWS PW Redundancy verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw fi 001 9k",
                "Procedure": "The test verifies that a Spanning Tree Protocol (SPAN) instance can be configured over a protected working path (PW), specifically in a scenario where there are multiple paths available due to VPWS PW redundancy. The setup involves configuring both primary and backup PWs, with the expectation that if an issue arises with the primary PW or the access control (AC) on the remote provider edge (PE) device, the secondary router should quickly activate the backup PW. To achieve this, the test configures a layer 2 bundle subinterface for SPAN.\n\nThis test is triggered by a failure of the AC on the remote PE.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nL2vpn xconnect verification is performed.\nSPAN over PW - with VPWS PW Redundancy verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw fi 002",
                "Procedure": "SPAN is verified over a point-to-point link with Netflow v9 enabled. To configure the test, enable both SPAN and Netflow on the network device, then verify that SPAN is functioning correctly. This test is triggered by verifying that Netflow v9 is configured to work in conjunction with SPAN.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nL2vpn xconnect verification is performed.\nFlow monitor name cache format record location verification is performed.\nSPAN over PW - with Netflow v9 configured verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw fi 003",
                "Procedure": "The configuration includes both SPAN and IPFIX. To verify the functionality of SPAN over Power over Ethernet (PoE) with IPFIX enabled, follow these test procedures: configure SPAN and IPFIX, then verify that SPAN is functioning as expected. This test is triggered by the configuration of a network with SPAN and IPFIX settings in place.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nL2vpn xconnect verification is performed.\nFlow monitor name cache format record location verification is performed.\nVerifing SPAN over PW with IPFIX configured verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw fi 004",
                "Procedure": "To verify that SPAN works over a packet wire (PW) network, we move the source port to different span sessions and check if everything functions as expected. This test is triggered by verifying that the configuration includes a GRE tunnel and supports SPAN functionality.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nSPAN monitor session verification is performed.\nTraffic Mirroring verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw fi 005",
                "Procedure": "The system's password span is verified when it has a Common Feature Module (CFM) configured. The test procedure involves checking that the CFM and layer 2 subinterfaces are properly set up. This test is triggered by the presence of cfm configured on the system.\n\n(Trigger sentence, as requested)\n\nNote: I made some minor adjustments to word order and phrase structure for clarity and readability.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nL2vpn xconnect verification is performed.\nCfm peer meps verification is performed.\nwith cfm configured on the system verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw fi 005 9k",
                "Procedure": "The system's password strength is verified in conjunction with Configurable Firewall Modules (CFM) being enabled. The test procedure involves configuring a network environment with CFM and Layer 2 subinterfaces, then attempting to verify the password strength while CFM is active. This test is triggered by enabling CFMD and L2 subinterfaces on the system.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nL2vpn xconnect verification is performed.\nCfm peer meps verification is performed.\nwith cfm configured on the system verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw ha 001",
                "Procedure": "The test procedure involves switching over to remote probe (RP) switchcover and verifying the Span port over a physical wire. This test is triggered by the need to validate that Remote Probe (RP) Functionality with Span Over Physical Wire (PW). The procedures include testing for RPFO, or Remote Probe Fiber Optic, functionality as well as SPAN verification, which requires specific configuration settings in place.",
                "Pass/Fail Criteria": "Span status verification is performed.\nRP swithcover and verify SPAN over PW verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw ha 007",
                "Procedure": "To test Span over point-to-point protocol (Pw) with a remote peer, the following steps should be taken. First, reload the peer router and then verify that the Span configuration is functioning as expected.\n\nThis test is triggered by a reload of the peer router.",
                "Pass/Fail Criteria": "Interface state verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nSPAN Traffic after remote peer reload verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw gre traffic",
                "Procedure": "To verify that Span works correctly when there's traffic going through a GRE tunnel, first set up the GRE tunnel and Span configurations.\n\nThis test is triggered by the presence of traffic crossing a GRE tunnel.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nSPAN over PW after commit replace and rollback configs verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw ha 013",
                "Procedure": "This testcase verifies SPAN by changing the core from PW to GRE tunnel and vice versa a number of times. The configuration includes PW-SPAN, as well as ERSPAN. This test is triggered by changing the core from PW to GRE tunnel and vice versa a number of times.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTraffic mirroring happening over PW verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw stress 001",
                "Procedure": "To test the configuration, you need to repeatedly shut and unshut the member link a certain number of times while verifying each time. This test is triggered by the procedures for configuring and testing a PW (Packet Switched Network) SPAN (Switched Port Analyzer), which includes shutting and unshutting bundle members and performing traffic verification. The configuration itself involves setting up a PW SPAN, OSPF (Open Shortest Path First), and MPLS (Multiprotocol Label Switching).",
                "Pass/Fail Criteria": "Ospf verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nL2vpn xconnect verification is performed.\nshut/unshut member link number of times and verify Traffic has to be mirrored to the PW properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw stress 002",
                "Procedure": "To test the system, you repeatedly add and remove a member link while verifying its status. The test involves configuring Protocol Wrappers (PW) for SPAN (Service Provider Backbone Tunneling), bundle members adding or removing, and traffic verification. This is triggered by configuration changes involving PW SPAN, OSPF (Open Shortest Path First), and MPLS (Multiprotocol Label Switching).",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nL2vpn xconnect verification is performed.\nAdd/remove member link number of times and verify Traffic has to be mirrored to the PW properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw stress 003",
                "Procedure": "To test the Physical Link feature, the user must repeatedly shut and unshut a physical link to ensure it operates correctly. This requires verifying that the traffic is being successfully sent and received during each operation. The Test Procedures for this feature are as follows: configure the PW (Provider-Wide Area Network) SPAN (Switched Port Analyzer), physically shut and unshut the link, then verify the traffic flow. This test is triggered by a configuration setting of the PW SPAN.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nshut/unshut physical link number of times and verify Traffic has to be mirrored to the PW properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw stress 004",
                "Procedure": "The test involves adding and removing a physical link multiple times to verify the packet span. The procedures include adding and removing physical links, verifying that traffic is flowing correctly each time, and configuring the system for packet spanning (SPAN).\n\nThis test is triggered by repeatedly adding and removing a physical link while monitoring the corresponding changes in packet span.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nOspf verification is performed.\nSPAN Traffic after adding/removing physical link number of time verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw scale 001",
                "Procedure": "The purpose of this test is to verify that Span over PW works correctly when using a full-scale monitor session with supported static routes and a Point-to-Point (PW) Switched Port Analyzer (SPAN). This test is triggered by the configuration of PW SPAN with static routes.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nMonitor session status verification is performed.\nL2vpn xconnect verification is performed.\nSpan status verification is performed.\nTraffic  with full scale monitor sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw scale 001 9k",
                "Procedure": "To verify Span over Point-to-Point (PW) with supported full-scale monitor sessions, the test procedure involves configuring a scaled Multi-Site (MS) setup and verifying the Span configuration. The configuration includes setting up PW Span and static routes.\n\nThis test is triggered by the need to validate the operation of Span over PW in large-scale network environments.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nL2vpn xconnect verification is performed.\nMonitor session status verification is performed.\nSpan status verification is performed.\nTraffic  with full scale monitor sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Span pw ha 006",
                "Procedure": "The test involves verifying Span (SPAN) over Port Mirroring with Port Extension (PW), including the configuration for commit, replace, and rollback. The test procedures include committing replace, then verifying Span in the configuration. This test is triggered by a commit of new configs that have replaced old ones but are set to be rolled back.",
                "Pass/Fail Criteria": "Span status verification is performed.\nL2vpn xconnect verification is performed.\nSPAN over PW after commit replace and rollback configs verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan l2 l2 phybunmain bidirmirror",
                "Procedure": "The test configures rxtx PWSPAN on L2 PhyMain and BunMain Src interfaces with bidirectional mirroring to verify PW SPAN status and mirror on L2 Main interfaces. The configuration includes PW SPAN on L2 PhyMan L2 BunMain with bidir mirroring, while the verifications check for separate RxTx PWSPAN status with L2 Main Src interfaces, a mirrored traffic stream at tgen for PWSPAN in specified direction, mirrored stream stats at the separate PWSPAN dest interface, and non-mirroring of unspecified span directions. This test is triggered by a lack of any specific trigger condition.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan l3 phybun mainsub bidirmirror v4 v6",
                "Procedure": "The test \"test_RxTxPWspan_L3_PhyBun_MainSub_BidirMirror_v4_v6\" verifies that a Physical Main and Sub and BUN Main and Sub interface with bidirectional mirroring can handle IPv4 and IPv6 traffic using separate RX and TX PW destinations on L3 interfaces. The configuration includes setting the PW SPAN source interface, while verification checks include monitoring sessions on L3 interfaces, mirrored traffic streams at the tgen for Rx and Tx Mirroring, and mirrored traffic interface stats at the Rx and Tx PW end points.\n\nThis test is triggered by None.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ninterface_type: \"BunMain\" and \"BunSub\" and \"PhyMain\" and \"PhySub\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan l3 phybun mainsub rxonly v4 v6",
                "Procedure": "This paragraph describes a test case that verifies the mirroring of IPv4 and IPv6 traffic on Layer 3 interfaces with physical main, physical sub, bundle main, or bundle sub types, where only the receive end is mirrored. The test checks for mirrored traffic streams at the tester's end, interface statistics, and ensures that traffic is not mirrored in the opposite direction. Configurations include setting a PW SPAN source interface to monitor Layer 3 interfaces. This test case is triggered by no specific conditions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ninterface_type: \"BunMain\" and \"BunSub\" and \"PhyMain\" and \"PhySub\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan l3 phybun mainsub txonly v4 v6",
                "Procedure": "The test case verifies mirroring with a Layer 3 source interface and separate destination interfaces for receiving and transmitting packets, which are used to monitor network traffic. Configurations include setting the PW SPAN source interface, while verifications involve checking for mirrored traffic streams at the tester's endpoint and verifying that the flow of traffic is only mirrored in the specified direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ninterface_type: \"BunMain\" and \"BunSub\" and \"PhyMain\" and \"PhySub\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan l2 l2 phybunsub rxonly txonly",
                "Procedure": "The test verifies SPAN over PW for L2 BUM traffic with a L2 bundle and physical subsource interface, where separate rx/tx pw span destinations are used for the Tx-only and Rx-only configurations. The verifications include checking that traffic with a monitor session on the physical L2 sub bundle is not mirrored in the unspecified direction.\n\nThis test is triggered by the absence of any specific trigger conditions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntraffic_type: \"unicast\" and \"multicast\" and \"broadcast\"",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Erspan pwspan swap on l3 phy main v4 v6",
                "Procedure": "The test verifies traffic with a source as Layer 3 PhyMain and ERSPAN, as well as Separate Rx-Tx PW SPAN configurations, involving both GRE Tunnel and ERSPAN setups. To verify this, check the status of PW SPAN and ERSPAN before and after swapping the span session on the source interface from PW SPAN to ERSPAN and vice versa. The test also involves verifying traffic with a monitor session on L3 PhyMain, mirrored traffic streams at the TGEN for ERSPAN and PW SPAN, and mirrored stream statistics at the PW SPAN Rx-Tx destination interfaces.\n\nThis test is triggered by swapping the span session on the source interface from PW SPAN to ERSPAN and vice versa.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Localspan pwspan swap on l3 bun main v4 v6",
                "Procedure": "The test verifies traffic with a source as L3 BunMain and ERSPAN, along with separate receive and transmit packets using PW SPAN. It involves swapping the span session type on the source interface between PW SPAN and LocalSPAN, then verifying the status of both configurations before and after the change, as well as the mirrored traffic streams at test generation and packet analyzer interfaces.\n\nThis test is triggered by: Swap the span session on the source interface from PW SPAN to Local SPAN, and vice versa.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan bidirpwspan swap on l3 main v4 v6",
                "Procedure": "Here is a test-case that verifies traffic with source as l3 Phy and Bundle Main interfaces using PW SPAN configurations with single and separate RxTx destinations. The configuration includes PW SPAN with a single destination and the verification checks for both types of PW SPAN status, traffic on the monitor session, and mirrored stream statistics at the destination interface. To trigger this test-case, swap the span session on the source interface from an Rx-Tx PW SPAN to a single-destination PW SPAN and vice versa.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Separate rxtx pwspan l3 global remove rollback on l3 sub",
                "Procedure": "The test case verifies the status and mirror functionality of PW SPAN after globally removing it and rolling back. It involves configuring PW SPAN on L3 Physical Sub-interface (PhySub) and Bunch-Sub interface (BunSub) source interfaces, then checking that separate RxTx PWSPAN statuses are as expected before and after triggering a global removal and rollback. Additionally, verifications include ensuring that PhySub has Tx-only PWSPAN and BunSub has Rx-only PWSPAN, mirrored traffic streams at the Traffic Generator (tgen), and correct statistics on the separated PWSPAN destination interface. This test is triggered by globally removing RxTx PWSPAN and rolling back.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan bidirpwspan swap under l2vpn",
                "Procedure": "Configure PWSPAN on L3PhyMain and L3BunMain Src interface, changing the PWSPAN dest from Separate RxTx to Single PW destination and then rolling back the change. This test verifies PW SPAN status and mirror after the change and rollback. The configurations include PW SPAN on PhyMain and BunMain source interfaces, as well as the destination type under PWSPAN. The verifications cover Separate RxTx PWSPAN status before and after the trigger, mirrored traffic streams at tgen for PWSPAN, and mirrored stream stats at the separate PWSPAN dest interface. This test is triggered by changing PWSPAN's separate RxTx PW destination to single PW destination and vice versa.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Swap rxtx pwspan direction under l2vpn",
                "Procedure": "To verify that the PW SPAN status and mirror are functioning correctly after swapping the RX and TX PW destinations for a tx-only PW SPAN on an L3 PhySub interface and a rx-only PW SPAN on an L3 BunSub interface, configure PW SPAN with tx-only on the PhySub source interface and rx-only on the BunSub source interface, swap the destinations under PW SPAN, and then rollback. The test verifies that the RX TX PW SPAN status is correct before and after triggering the swap, that the destinations are swapped as expected, and that traffic is mirrored only for specified directions.\n\nThis test is triggered by SWAP PWSPAN separate RxTx PW destinations and rollback.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan l2 l3 bvi txdnsspanfilter",
                "Procedure": "The test case configures rxtx PWSPAN on L2 PhyMain and BunMain Src interfaces with bidirectional mirroring, verifying the PW SPAN status and mirror on L2 Main interfaces. The configurations include PW SPAN on L2 PhyMan and L2 BunMain with bidirectional mirroring. Verifications involve checking the separate RxTx PWSPAN status with L2 Main Src interfaces, mirrored traffic stream at tgen for PWSPAN only in specified direction, mirrored stream stats at the separate PWSPAN dest interface, and non-mirroring of unspecified span directions.\n\nThis test is triggered by no specific event or condition being identified.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Rxtxpwspan l2 l2 rxdnsspanfilter",
                "Procedure": "The test for verifying SPAN over PW for L2 BUM traffic involves a configuration of L2 bundle and Phy sub source interface with separate rx/tx pw span destinations, including both Tx-only and Rx-only PWSPAN on L2 Sub interfaces. The verifications include sending traffic with a monitor session on the physical L2 sub bundle and ensuring that the traffic is not mirrored in the unspecified direction. This test is triggered by verifying that there are no configured triggers.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pw span qos egress",
                "Procedure": "The test for configuring egress QoS policy on a Span source interface and verifying the Span involves configurations of both SPAN and QOS, as well as verifications that include SPAN, L2VPN, and traffic with an egress QOS policy. There are no specific triggers for this test.\n\nThis test is triggered by any network event affecting the configuration or traffic on the egress interface, such as changes to the QoS policy or network topology issues.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nShow policy map interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pw span qos ingress",
                "Procedure": "The test for configuring ingress QoS policies on the source interface of a SPAN and verifying the resulting configurations involves setting up SPAN and QoS parameters, as well as L2VPN and traffic settings. The verification checks include SPAN functionality, Layer 2 VPN operations, and the presence of traffic with an applied ingress QOS policy. \n\nThis test is triggered by any change in the configuration of the device.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nShow policy map interface verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pw span acl v4 v6 separate rx",
                "Procedure": "Traffic mirroring over Provider WAN (PW) with receive (Rx) Span Access Control List (ACL) enabled on a Layer 3 interface is verified in this test. The testcase configures an ACL on the ingress direction and verifies its behavior with SPAN over PW, including configurations for PW SPAN and ACL, and verifications of SPAN, L2VPN, and traffic with ingress ACL.",
                "Pass/Fail Criteria": "Interface state verification is performed.\nSpan status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pw span acl v4 v6 separate tx",
                "Procedure": "This test case verifies the transmission of traffic mirroring over a pseudowire (PW) when the transmit Span ACL is enabled on an L3 interface, specifically on switch J2. To achieve this, it configures an access control list (ACL) in the egress direction and checks its behavior with SPAN over PW. The test configurations include setting up PW SPAN and ACLs, while the verifications involve checking SPAN, L2VPN, and traffic passing through the egress ACL.",
                "Pass/Fail Criteria": "Span status verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l2 phy dest pw separate rx tx process restart",
                "Procedure": "This test case verifies traffic with source as a Layer 2 bundle and destination as separate receive and transmit packet wire (PW) before and after the process restart for span_ea, span_ma, and span_mgr configurations on a physical interface. The test involves configuring an L2 bundle main interface and setting up a monitor session on the physical L2 main bundle with trigger process restart. To conduct this test, the system must be restarted due to changes made to the span_ea, span_ma, and span_mgr processes.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Src l2 phy dest pw separate rx tx with triggers",
                "Procedure": "The test case verifies traffic with a source as an L2 bundle and a destination as separate RX/TX PW before and after triggers are activated. It involves configuring the L2 bundle main interface and enabling span CLI for monitoring. The configurations include SPAN settings, while verifications involve checking traffic with a monitor session on physical L2 main bundles. Triggers include reloads, lc_oir, rpfo, and commit_replace_rollback.\n\nThis test is triggered by reload,lc_oir,rpfo,commit_replace_rollback.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"reload\" and \"lc_oir\" and \"rpfo\" and \"commit_replace_rollback\"",
                "Pass/Fail Criteria": "Traffic verification is performed.\nSpan status verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "vrrp_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Vrrpv4 default timers",
                "Procedure": "The VRRPV4 test is configured to use the default advertisement timer. It verifies that a VRRP session is successfully established, checks that the default timer values are set correctly, and confirms that traffic is flowing as expected.\n\nThis test is triggered by configuring VRRP on an IPv4 address family with a default timer.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 bvi cscvw80483",
                "Procedure": "The purpose of this test is to verify the operation of VRRP (Virtual Router Redundancy Protocol) version 4, specifically with identifier CSCvw80483. The configuration involves setting up VRRP on a v4 address family using default timer settings. Once configured, it's essential to verify that the VRRP session has been established and is functioning correctly, including checking that the default timer values are in place. Finally, the test ensures that traffic flows properly through this setup.\n\nThis test is triggered by configuring VRRP on a v4 address family with identifier CSCvw80483.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 with tracking enabled",
                "Procedure": "Vrrpv4 tests are run with tracking enabled. The test verifies that a vrrpv4 connection can be established using the default advertisement timer and tracking option. It does this by configuring VRRP on an IPv4 address family with the tracking option, then verifying that a VRRP session is established and checking that the configured priority value, decrement value, and tracked interface are correct.\n\nThis test is triggered by: Configuring VRRP on v4 address family with tracking option.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: After interface is shut, verify priority value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 router priority with ip",
                "Procedure": "The vrrpv4 protocol is tested with a specified router priority. The test verifies the functionality of this feature by configuring VRRP on a v4 address family using a vrouter address as the device under test (UUT) address, then checking that a VRRP session is established and that the Vrouter address matches the UUT's address.\n\nThis test is triggered by configuration: VRRP.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established and vrouter is UUT's address verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 interface flap",
                "Procedure": "The test for verifying VRRPv4 with an interface flap trigger involves configuring VRRP on a v4 address family, establishing a VRRP session, shutting down the interface to verify that the VRRP ownership switches over, and then unshutting the interface to ensure that the ownership rolls back.\n\nThis test is triggered by a change in the interface status, such as an interface flap.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: Verify vrrp ownership switcheover happens verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 multiple groups",
                "Procedure": "Multiple vrrpv4 groups can be configured to serve both the Master and Slave roles. The test verifies that multiple vrrpv4 groups are correctly set up for master and slave nodes. For this purpose, one vrrp group is configured on a v4 address family for the Master role, while another is configured for the Slave role, each with default timer values. It also checks that a VRRP session is established between them.\n\nThis test is triggered by the requirement to configure multiple Virtual Router Redundancy Protocol (VRRP) groups in IPv4 address families for both master and slave roles, including verifying the establishment of a VRRP session.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established for Master and Slave groups verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 with secondary ip",
                "Procedure": "VRRPV4 with secondary IP is tested by configuring a VRRP instance on an IPv4 address family with a secondary IP. The test verifies that the VRRP session is successfully established with the secondary IP and checks for default timer settings.\n\nThis test is triggered by configuring a VRRP instance on an IPv4 address family with a secondary IP.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 bundle interfaces in l2vpn group",
                "Procedure": "VRRPv4 tests are performed on both the BVI and bundle interfaces within an L2VPN group. The test configuration involves setting up VRRP on the IPv4 address family for the BVI interface, verifying that a VRRP session is established, checking default timer values, and confirming that traffic flows properly. This test is triggered by the Configuration: VRRP setup.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 bvi cscvx18634",
                "Procedure": "The test for IPv4 on a BVI interface within an L2VPN group involves verifying that a VRRP session is established. Before and after reloading the configuration, which includes setting up VRRP, pings are formed to check connectivity.\n\nThis test is triggered by the creation of a VRRP configuration.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nvrrp session is estalished verification is performed.\nBVI session verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 with process restart",
                "Procedure": "When testing vrrpv4 with process restarts, it's essential to ensure that the configuration is correct. This involves configuring vrrp on a v4 address family with the default timer, verifying that a vrrp session has been established, and then restarting the relevant process while verifying that vrrp still functions as expected. The test setup includes a Configuration of VRRP.\n\nThis test is triggered by the need to verify the integrity of vrrpv4 during system restarts or when the relevant process is interrupted.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: After process verify vrrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv6 default timers",
                "Procedure": "Vrrpv6 with default adv timer tests verify the establishment of a Vrrp session on an IPv6 address family with default timer settings. The configuration involves setting up VRRP, and then verifying that the session has been established and that traffic is flowing properly. This test is triggered by configuring vrrp on v6 address family with default timer.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv6 with tracking enabled",
                "Procedure": "Vrrpv6 with tracking enabled tests verify that Vrrpv6 works with a default advertisement timer. To do this, we configure VRRP on the IPv6 address family using the tracking option and verify that the VRRP session is established. We then check that the configured priority value and decrement value are correct, as well as the tracked interface.\n\nThis test is triggered by a configuration change in VRRP settings with tracking enabled.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: After interface is shut, verify priority value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv6 multiple groups",
                "Procedure": "The test verifies multiple Vrrpv6 groups, configuring both a master and slave device in the v6 address family. The configuration involves setting up one vrrp group on each device with a master role and verifying that a session is established between them. Additionally, default timer values are checked.\n\nThis test is triggered by testing two VRRP groups on IPv6 addresses, where one acts as Master and the other as Slave.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established for Master and Slave groups verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv6 router prioroty with ip",
                "Procedure": "The VRRPV6 test with router priority verifies the VRRPV6 with router priority feature by configuring VRRP on a v6 address family with a vRouter address as the UUT address. The test then checks that a VRRP session is established and confirms that the vRouter address matches the UUT's address.\n\nThis test is triggered by the configuration of VRRP settings, specifically the use of the 'router priority' feature in the V6 address family with a vRouter address as the UUT address.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established and vrouter is UUT's address verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv6 with secondary ip",
                "Procedure": "VRRPV6 is tested with a secondary IP address configured. The configuration involves setting up VRRP on the IPv6 address family and specifying a secondary IP address. The test verifies that the VRRP session is established successfully with the secondary IP address, and by default, it also checks for the timer values.\n\nThis test is triggered by configuring vrrp on v6 address family with secondary ip.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv6 interface flap",
                "Procedure": "The test for verifying VRRPV6 with an interface flap trigger involves configuring VRRP on a v6 address family, establishing a VRRP session, shutting down the interface to check that the VRRP ownership switches over. After this, the interface is brought back up and the VRRP ownership rolls back to its original state.\n\nThis test is triggered by interface flapping.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: Verify vrrp ownership switcheover happens verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle interfaces in l2vpn group",
                "Procedure": "The test checks for VRRPV6 operation on the BVI and bundle interfaces within an L2VPN group. It involves configuring VRRP on the IPv6 address family for the BVI interface, verifying that a VRRP session is established, checking default timer values, and ensuring traffic flows correctly.\n\nThis test is triggered by 'Configuration: VRRP'.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv6 with process restart",
                "Procedure": "VRRPv6 testing involves simulating a process restart to ensure the protocol continues to function properly. The test begins by configuring VRRP on a IPv6 address family with default timer settings, then verifies that a VRRP session is established between devices. Next, the relevant process is restarted and VRRP is re-verified to confirm it remains operational. This test is triggered by restarting the process responsible for maintaining the VRRP connection.\n\nTrigger sentence: This test is triggered by restarting the process responsible for maintaining the VRRP connection.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: After process verify vrrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4v6 default timers",
                "Procedure": "Vrrpv6 and Vrrpv4 are tested with a default advertization timer. The configuration involves setting up VRRP on both IPv6 and IPv4 address families, using the default timer settings. After establishing the VRRP session, it's verified that the default timer values are in effect and that traffic is flowing properly.\n\nThis test is triggered by configuring VRRP with a default advertization timer on both IPv6 and IPv4 interfaces.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4v6 with tracking enabled",
                "Procedure": "Vrrpv6 and vrrpv4 are tested with tracking enabled. The test verifies that both protocols establish a session with default advertisement timer settings, use the specified priority value, decrement value, and track the designated interface when configured for the address family with tracking option. This test is triggered by configuring VRRP on a device's IPv6 and IPv4 address families with tracking enabled as part of its configuration.",
                "Pass/Fail Criteria": "Vrrp details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: After interface is shut, verify priority value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4v6 multiple groups",
                "Procedure": "Vrrpv6 and Vrrpv4 groups serving both Master and Slave roles are tested. The test verifies multiple Vrrpv6 and Vrrpv4 groups, ensuring that one group on the v6 address family is configured for the Master role, another for the Slave role, and similarly for the v4 address family. Additionally, it checks that a VRRP session is established and default timer values are set correctly. This test is triggered by verifying configuration: VRRP.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established for Master and Slave groups verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4v6 router prioroty with ip",
                "Procedure": "VRRP tests are performed for both IPv6 and IPv4 protocols, configuring the virtual router (vrouter) address as the UUT address. The test verifies that a VRRP session is established and that the vrouter address matches the UUT's address.\n\nThis test is triggered by configuring VRRP on an IPv6 and IPv4 address family with the vrouter address set as the UUT address, in a configuration using VRRP.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established and vrouter is UUT's address verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4v6 with secondary ip",
                "Procedure": "VRRP tests for both IPv4 and IPv6 addresses are conducted when a secondary IP is configured. This involves setting up VRRP on both the v4 and v6 address families with the specified secondary IP, establishing a VRRP session, and verifying that default timer values are in place. This test is triggered by Configure VRRP on v4 & v6 address family with secondary IP.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4v6 with process restart",
                "Procedure": "VRRPV6 and VRRPV4 test with process restarts verifies the functionality of these tests. The configuration involves setting up VRRP on both v6 and v4 address families with default timers, establishing a VRRP session, and then restarting the relevant process to verify that VRRP remains active.\n\nThis test is triggered by configuring VRRP on a network device.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: After process verify vrrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4v6 with triggers",
                "Procedure": "Here is a rewritten version of the text in a single, natural-sounding paragraph. If there is a line starting with 'This test is triggered by', rewrite that line in proper English and place it at the end.\n\nTo verify the operation of VRRP, we must first configure VRRP on both IPv6 and IPv4 address families using default timer settings. Next, we need to establish a VRRP session and ensure it's working correctly. Finally, we can perform a specific trigger action and verify that VRRP responds accordingly.\n\nThis test is triggered by the occurrence of an event that initiates a VRRP packet transmission.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: After process verify vrrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpscalev4 default timers",
                "Procedure": "The configuration involves setting up a VRRP (Virtual Router Redundancy Protocol) instance using the IPv4 address family with its default timer. This test verifies that the protocol scales properly by establishing a VRRP session and confirming that the default timer values are being used.\n\nThis test is triggered by configuring scale vrrp on v4 address family with default timer.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp sessions are established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpscalev4 with tracking enabled",
                "Procedure": "Vrrpv4 scales with tracking enabled. This test verifies that vrrpv4 can scale with a default advertization timer when the tracking feature is used. The configuration includes setting up a VRRP scale on a v4 address family with the tracking option, verifying that the VRRP session is established, and confirming that the configured priority value, decrement value, and tracked interface are correct.",
                "Pass/Fail Criteria": "Vrrp details verification is performed.\nVrrp: Verify vrrp sessions are established verification is performed.\nVrrp: After interface is shut, verify priority value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpscalev4 interface flap",
                "Procedure": "The test verifies the scalability of VRRPV4 with an interface flap trigger. This test is triggered by configuring scale VRRP on a V4 address family, verifying that the VRRP session is established, shutting down the interface and checking that VRRP ownership switches over, then unshutting the interface and verifying that VRRP ownership rolls back.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp sessions are established verification is performed.\nVrrp: Verify vrrp ownership switcheover happens verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpscalev4 with process restart",
                "Procedure": "Vrrpv4 scaling is tested by restarting processes. The test verifies that vrrpv4 can scale properly after a restart of the relevant process, which involves configuring the scale on the v4 address family with the default timer, establishing a vrrp session, and then verifying that the vrrp configuration remains in place. This test is triggered by the need to verify that VRRP can recover from process restarts without disrupting connectivity.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nVrrp: After process verify vrrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpscalev6 default timers",
                "Procedure": "Vrrpv6 scales with a default advertisement timer by verifying that a VRRP session is established, and the default timer values are in place. This test is triggered by configuring VRRP scaling on a V6 address family with the default timer settings.\n\n(Note: I've rewritten the trigger sentence to sound more natural)",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp sessions are established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpscalev6 with tracking enabled",
                "Procedure": "Vrrpv6 scaling can be tested by enabling tracking. To trigger this test, it needs to be initiated when the default advertisement timer is used in conjunction with configuring vrrp scale on a v6 address family that has tracking enabled, verifying that a vrrp session is established and checking that the configured priority value, decrement value, and tracked interface are correct as per the given configuration: VRRP.",
                "Pass/Fail Criteria": "Vrrp details verification is performed.\nVrrp: Verify vrrp sessions are established verification is performed.\nVrrp: After interface is shut, verify priority value verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpscalev6 interface flap",
                "Procedure": "The test for verifying VRRPv6 scaling with an interface flap trigger involves several steps. First, it configures VRRP on a v6 address family, then verifies that the VRRP session is established. Next, it shuts down the interface and checks to see if the VRRP ownership switches over properly. Finally, it unshuts the interface and verifies that the VRRP ownership rolls back to its original state.\n\nThis test is triggered by a configuration of VRRP on a v6 address family.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp sessions are established verification is performed.\nVrrp: Verify vrrp ownership switcheover happens verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpscalev6 with process restart",
                "Procedure": "VRRPv6 scales properly with process restarts. This test verifies that when configured to use the V6 address family with a default timer, a VRRP session will be established and persist even after restarting the relevant process.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nVrrp: Verify vrrp sessions are established verification is performed.\nVrrp: After process verify vrrp state verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrpv4 config using oc",
                "Procedure": "The test for verifying vrrpv4 configuration using Openconfig checks that the protocol works as expected. The test configures VRRP on the IPv4 address family with its default timer settings, then verifies that a VRRP session has been established and that the default timer values are in place.\n\nThis test is triggered by a Configuration: VRRP setup.",
                "Pass/Fail Criteria": "Vrrp: Verify vrrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp l2 to l3 v4 v6 traffic",
                "Procedure": "Traffic between Layer 2 and Layer 3 networks triggers a VRRPoboivw test to verify correct routing functionality.\n\nThis test is triggered by the presence of L2-to-L3 traffic.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp l3 to l2 v4 v6 traffic",
                "Procedure": "VRRP devices are tested with L3-to-L2 traffic.\n\nThis test is triggered by the presence of VRRP devices handling traffic between Layer 3 and Layer 2 networks.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp change vrrp ip",
                "Procedure": "After changing the virtual IP, some tests fail due to L2-to-L3 and L3-to-L2 traffic. The test verifies that these failures occur when the virtual IP is switched and then restored to its original state.\n\nThis test is triggered by a change in the virtual IP between two different VRRP sessions, both with new and previous virtual IPs respectively.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic verification verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp icmp host to vip",
                "Procedure": "The system checks that VRRP is functioning correctly by sending a ping to the Virtual MAC address. This test verifies that VRRP is operational by triggering a ping to the VMAC.\n\nThis test is triggered by configuration of the Virtual MAC (VMAC) address.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nPing check verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp master switchover",
                "Procedure": "The configuration change involves modifying the priority setting on the backup router to temporarily make it the primary device, then reverting it back to its original status. This test is triggered by a master switchover to a backup router as part of the verification process to ensure that vrrpobviopw functions correctly during such an event.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic check verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp stress remove add vfi",
                "Procedure": "The system tests verify that vrrpobviopw is removed along with add vfi. This test is triggered when the configuration requires removing add VFI.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic check verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp stress remove add bd",
                "Procedure": "vrrpobviopw is tested by removing the add Bridge Domain. The test verifies that this action affects vrrpobviopw properly. The configuration for testing includes removing the add Bridge Domain.\n\nThis test is triggered by a specific configuration change, namely the removal of the add Bridge Domain.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic check verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp stress remove add core bundle members",
                "Procedure": "The configuration involves removing the \"add bundle members\" option to verify that a system behaves correctly in this state. This test is triggered by attempting to modify an existing VRRP (Virtual Router Redundancy Protocol) bundle with the \"remove add bundle members\" action enabled.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic check verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp ha tiggers",
                "Procedure": "The vrrpobviopw by HA triggers are tested to verify their functionality. \n\nThis test is triggered by the absence of any configuration settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"router_reload\" and \"lc_reload_ac_side\" and \"lc_reload_core_side\" and \"rpfo\"",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic check verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp process restart",
                "Procedure": "After a process restart, tests verify that vrrpopviow function correctly. The verification checks for any issues following the restart of the process.\n\nThis test is triggered by restarting the process.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc: \"ApData.processes\"",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic check verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp l2 to l2 traffic",
                "Procedure": "Tests involving VRRPOW functionality with L2-to-L2 traffic are conducted. This verification process checks the operation of VRRPOW under these conditions. The test configuration involves adding two new access controllers (ACs) to a bridge domain (BD) for learning MAC addresses.\n\nThis test is triggered by adding 2 new ACs to BD for learnning MAC.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic check verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp with vrf v4 v6 traffic",
                "Procedure": "Vrrpobviopws are tested with Virtual Routing and Forwarding (VRF). The test verifies proper functioning of vrrpobviopws with VRF, including the configuration of a global route policy, VRF setup, BGP configuration, and a master switchover to backup by changing the priority of the backup. This test is triggered by a change in the BGP config.\n\nNote: I corrected \"vrrpobviopw\" (which seems to be a typo) to \"VRRP group\", but since it's likely a placeholder for some technical term, I left it as is. If you provide more context or clarify what \"vrrpobviopws\" refers to, I can make the correction accordingly.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nVmac on master verification is performed.\nVmac on backup verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nTraffic check verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "vrrp_scale_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Vrrp scale phy subintf ipv4",
                "Procedure": "The test case \"test_vrrp_scale_phy_subintf_ipv4\" verifies that VRRP sessions are functioning correctly for physical sub-interfaces, particularly in regards to the configuration of primary and secondary addresses. The tests check that when configuring a bridge domain, all VRRP sessions are up, and that it is not possible to assign the same primary and secondary Virtual IP (VIP) addresses. This test case examines the following configurations and verifications: the state of the bridge domain, whether all VRRP sessions are active for physical sub-interfaces, and whether the primary and secondary VIP addresses can be different.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nVrrp details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp cscvw94704",
                "Procedure": "This paragraph and the trigger sentence should be rewritten as follows:\n\nThe vrrp_CSCvw94704 Verify test-case verifies the bridge-domain state and VRRP detail. Configurations include a VRRP configuration, and verifications involve checking for bridge-domain and VRRP sessions. This test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale bundle subintf ipv4",
                "Procedure": "This text-case verifies that a bridge domain is properly set and all VRRP sessions are operational on a bundle sub-interface, especially when the interface has IPv4 configured.\n\nThe test is triggered by the absence of any configurations or verifications specified in the test case.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nVrrp details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale bvi phy ipv4",
                "Procedure": "The test case verifies bridge domain and VRRP (Virtual Router Redundancy Protocol) sessions for BVI PHY IPv4 configurations, including a VRRP configuration. Verifications are performed on the bridge domain and VRRP sessions for BVI PHY v4. This test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale bvi bundle ipv4",
                "Procedure": "The test case verifies VRRP sessions for a BVI bundle with IPv4, including configurations and verifications specific to bridge domains and VRRP settings.\n\nThis test is triggered by the absence of any configuration or triggers specified in the test case details.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale phy subintf ipv6",
                "Procedure": "The test-case verifies VRRP sessions for physical subnet interface IPv6 and bridge domain configurations.\n\nThis test is triggered by the absence of any specific trigger conditions.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale bundle subintf ipv6",
                "Procedure": "This paragraph describes a test case that verifies Virtual Router Redundancy Protocol (VRRP) sessions for a bundle sub-interface on IPv6 networks. The configuration involves VRRP settings, while the verification checks for successful VRRP sessions and bridge-domain establishment. \n\nThe test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale bvi phy ipv6",
                "Procedure": "The test-case verifies a VRRP session for BVI PHY v6, specifically involving the configuration and verification of bridge domains. The configurations include setting up a VRRP configuration, while the verifications involve checking the VRRP sessions and bridge domains. This test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale bvi bundle ipv6",
                "Procedure": "This paragraph and the trigger sentence are:\n\nThe test case verifies that all VRRP sessions are up with an IPv6 address in a BVI sub-interface with bundle sub-interfaces in an L2VPN configuration. The configurations involved include vrrp settings, while verifications focus on the state of VRRP sessions and bridge-domain connections. This test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale mix phy subintf",
                "Procedure": "The test-case verifies if all the VRRP sessions are up with a mixed scale of IPv4 and IPv6 on Physical sub-Interface configurations, checking for VRRP sessions and bridge-domain verifications. Configurations include vrrp config. Triggers: None.\n\nThis test is triggered by no specific event or condition.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale mix bundle subintf",
                "Procedure": "The test case verifies that all VRRP sessions are up and running with a mixed scale of IPv4 and IPv6 on bundle sub-Interface configurations, including verification of VRRP sessions and bridge domain settings.\n\nThis test is triggered when no specific triggers are specified.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale bvi phy mix",
                "Procedure": "The test case verifies that all VRRP sessions are up with a mixed scale of IPv4 and IPv6 on the BVI sub-interface, using the following configurations: VRRP config. The verification process checks for VRRP sessions and bridge-domain. This test is triggered by no specific event.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale bvi bundle mix",
                "Procedure": "The test case verifies that all vrrp sessions are up with a mixed scale of v4 and v6 on physical sub-interfaces. The test configuration includes vrrp settings, and the verification steps include checking vrrp sessions and bridge domain configurations.\n\nThis test is triggered by None.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale authentication",
                "Procedure": "The test case verifies that VRRP sessions are down when using incorrect authentication, and then checks if they come back up after providing the correct authentication. The configurations include a VRRP setup with wrong authentication credentials and another setup with correct authentication. During the verification process, both VRRP sessions and bridge domain information are checked. This test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp switch over",
                "Procedure": "To verify that all VRRP sessions remain active after switching the master and slave roles, a test-case is run with two specific configurations in place: a VRRP configuration and shutdown of the tracking interface. Verifications are then performed on the VRRP sessions and bridge domain to ensure they are functioning as expected.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale mix master slave v4",
                "Procedure": "The test case verifies that all VRRP sessions are up for a configuration with a mix of master and slave instances on IPv4 networks, using the specified VRRP configuration. The verifications include checking the VRRP sessions and the bridge domain. \n\nThis test is triggered by: None.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale mix master slave v6",
                "Procedure": "The test case verifies that all VRRP sessions are functioning properly, including a mix of master and slave, on IPv6 networks. The configuration involves setting up VRRP settings. To verify the test, the following items should be checked: the status of all VRRP sessions and whether the bridge domain is operational. This test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale mix master slave v6 v4",
                "Procedure": "All VRRP sessions for a mixed configuration of master/slave and IPv4/IPv6 must be up. Configurations involve setting up the VRRP config. Verifications include checking that all VRRP sessions are active, and that both bridge domain and domain are functioning as expected.\n\nThis test is triggered by no specific conditions.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale process restart",
                "Procedure": "The test case verifies that a process can be restarted successfully after setting up a VRRP (Virtual Router Redundancy Protocol) configuration. To do this, the test sets up VRRP and then checks that it's working correctly by verifying VRRP sessions and the bridge domain are functioning as expected. This test is triggered by none.",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale trigger",
                "Procedure": "The test case verifies that various triggers work as expected after configuring VRRP, and it does so by checking the configuration of VRRP, verifying the presence of VRRP sessions and a bridge domain, and ensuring that no other triggers are activated. \nThis test is triggered by none.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.trigger\"",
                "Pass/Fail Criteria": "L2vpn bridge domain summary verification is performed.\nVrrp interface details verification is performed.\nShow logging verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp scale v4 v6 bvi over pw",
                "Procedure": "This test verifies VRRPOBVIOPW with a scale configuration using the VRRP protocol. \n\nTriggered by: This test is triggered when both IPv4 and IPv6 VRRP instances have Scale configured on BVI (Broadcast Virtual Interface) over Physical Wire (PW).",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nL2vpn bridge domain summary verification is performed.\nTraffic verification is performed.\nVrrp: Verify vrrp session is established verification is performed.\nL2VPN: Verify L2vpn BD and PW came up verification is performed.\nTraffic: Verify traffic is flowing properly verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp v4 v6 scale",
                "Procedure": "VRRP IPv4v6 sessions scale as needed based on available and unused links, along with High Availability triggers. The test verifies role negotiation on scaled VRRP sessions when both v4 and v6 are enabled, along with HA triggers. The process involves configuring the setup, then triggering an HA event such as a flapinterface, rpfo, change_priority, or rollback_global_config.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nintf_type: \"ApData.zap.get_testcase_configuration().get('scaling_on', ['physical_sub', 'bundle_sub'])\"\ntrigger: \"ApData.zap.get_testcase_configuration().get('triggers', ['change_priority', 'flapinterface', 'rpfo', 'rollback_global_config'])\"",
                "Pass/Fail Criteria": "Scaled vrrp sessions verification is performed.\nTraffic verification is performed.\nVRRP sessions are established in complete Active / Standby verification is performed.\nVRRP role negotiations are proper after HA trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp bvi ipv4 ipv6 scale",
                "Procedure": "The test-case verifies the configuration of bridge-domain VRRP (Virtual Router Redundancy Protocol) sessions for BVI (Bridge Virtual Interface) physical IPv4 and IPv6 connections. The configurations to be tested include those related to VRRP, while verifications focus on ensuring that the bridge-domain and VRRP sessions for BVI phy v4 are properly configured.\n\nThis test is triggered by the absence of any specified trigger conditions.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp bvi ipv4 ipv6 scale remove rollback config",
                "Procedure": "The test case verifies the functionality of bridge-domain VRRP sessions for BVI physical interfaces in both IPv4 and IPv6 configurations. It checks the configuration and verification of VRRP settings on these interfaces. The tests focus on validating the bridge-domain and VRRP sessions for BVI phy v4 interfaces, but no triggers are specified for this test case.\n\nThis test is triggered by a non-existent condition (None).",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Vrrp bvi ipv4 ipv6 scale remove intf rollback",
                "Procedure": "The test-case verifies bridge-domain VRRP sessions for BVI physical interfaces with both IPv4 and IPv6 configurations. Configurations include the setup of VRRP, while verifications focus on the presence of bridge-domain and VRRP sessions for BVI physical interfaces with IPv4 connectivity. This test is triggered by the absence of any specific configuration or event.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ncs scale phy subintf ipv4 ipv6",
                "Procedure": "The test, known as test_ncs_scale_phy_subintf_ipv4_ipv6, verifies several key aspects of a VRRP (Virtual Router Redundancy Protocol) setup on a physical subinterface. It checks that the bridge domain state is correct and that all vrrp sessions are operational for the physical subinterface in question. Additionally, it ensures that the primary and secondary VIP addresses are not identical. To confirm these conditions have been met, the test verifies the presence of a bridge domain and the status of vrrp sessions. It also checks that the primary and secondary virtual IP addresses are distinct.\n\nThis test is triggered by the system's default trigger condition.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ncs scale phy subintf ipv4 ipv6 remove rollback config",
                "Procedure": "The test, \"test_ncs_scale_phy_subintf_ipv4_ipv6_remove_rollback Verify vrrp sessions\", verifies that VRRP (Virtual Router Redundancy Protocol) sessions are up for physical sub-interfaces within a bridge domain and that primary and secondary addresses cannot be the same. Configurations include enabling VRRP, while verifications involve checking the bridge-domain state and the number of active VRRP sessions. Additionally, it is verified that the primary and secondary Virtual IP (VIP) addresses are not the same.\n\nThis test is triggered by the absence of any specific conditions or configurations.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Ncs scale phy subintf ipv4 ipv6 remove add intf",
                "Procedure": "The test-case \"test_ncs_scale_phy_subintf_ipv4_ipv6_remove_add_intf\" verifies the state of bridge-domains, checks that all VRRP sessions are up for physical sub-interfaces, and ensures that primary and secondary addresses cannot be the same. Configurations include setting up VRRP, while verifications involve checking bridge-domain states, VRRP sessions, and ensuring that the primary and secondary VIPs do not share the same address.",
                "Pass/Fail Criteria": "Vrrp interface details verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "edpl_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Edpl ext phy vlans encaps dot1q",
                "Procedure": "The configuration of edpl in an external direction on a Phy L2 Dot1q sub-interface needs to be tested, specifically the external edpl behavior. To do this, the test configures and verifies all edpl parameters in the external direction, including all relevant settings. This test is triggered by configuring an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext phy vlans encaps dot1q secdot1q",
                "Procedure": "The configuration of edpl in external direction is tested on phy L2 dot1q and second dot1q sub-interface, where it is configured and verified to ensure proper external edpl behavior, including all required parameters.\n\nThis test configures and verifies the edpl profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext phy vlans encaps default subinterface",
                "Procedure": "The configuration of edpl in an external direction on a physical Layer 2 default sub-interface is tested. This test configures and verifies the external edpl behavior, including all edpl parameters in that direction. The configuration used for this test is an EDPL profile.\n\nThis test is triggered by the need to configure and verify all EDPL parameters in the external direction.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext phy vlans encaps dot1ad dot1q subinterface",
                "Procedure": "The edpl configuration is tested in an external direction on the phy L2 interface, specifically for Dot1ad and Dot1q sub-interfaces. The test involves configuring and verifying how edpl behaves externally, which includes setting up all relevant parameters in this direction. This test is triggered by configuring an EDPL profile.\n\n(Rewritten trigger sentence)",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps dot1q",
                "Procedure": "The test checks the configuration of edge portal (edpl) in an external direction on a bundle L2 Dot1q subinterface. It configures and verifies all edpl parameters to ensure correct external edpl behavior. The configuration includes an EDPL profile.\n\nThis test is triggered by the need to verify that edpl operates correctly when configured for use in an external direction on a specific type of network interface.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps dot1q secdot1q",
                "Procedure": "The test for configuring edpl in an external direction on bundle L2 dot1ad subinterface involves testing the configuration of edpl parameters in that direction. The configuration includes setting up an EDPL profile, which is used to configure and verify all edpl parameters.\n\nThis test is triggered by the need to configure and verify external edpl behavior when configuring and verifying all edpl parameters in external direction on bund L2 Dot1ad Sub-interface.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps default",
                "Procedure": "The configuration of edpl in external direction on bund L2 default sub-interface is tested by configuring and verifying all edpl parameters in this direction.\n\nThis test is triggered by a configuration of an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps dot1ad dot1q",
                "Procedure": "The configuration for edpl in external direction on the bund L2 interface, specifically with Dot1ad and Dot1q sub-interfaces, needs to be tested. This test configures and verifies external edpl behavior by setting up all edpl parameters in that direction. The configuration involves an EDPL profile. \n\nThis test is triggered by configuring and verifying external edpl behavior - Configure and verify all edpl parameters in external direction.",
                "Pass/Fail Criteria": "Traffic start stop verify verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int phy vlan encaps dot1q",
                "Procedure": "The configuration of edpl in internal direction on a phy L2 Dot1q Sub-interface needs to be tested. The goal is to configure and verify the internal edpl behavior, which includes configuring and verifying all edpl parameters in internal direction, using an EDPL profile.\n\nThis test is triggered by testing the configuration of edpl in internal direction on a phy L2 Dot1q Sub-interface.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int phy vlan encaps dot1q secdot1q",
                "Procedure": "To test the configuration of edpl in internal direction on phy L2 Dot1q Sub-interface, you need to configure and verify all edpl parameters. This includes configuring an EDPL profile.\n\nThis test is triggered by the configuration of an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int phy vlan encaps default",
                "Procedure": "The configuration of edpl in the internal direction is tested on phy L2 default subinterface, which also configures and verifies internal edpl behavior by setting all edpl parameters in that direction. This test is triggered by a specific configuration of an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int phy vlan encaps dot1ad dot1q",
                "Procedure": "The configuration of edpl in the internal direction on the phy L2 qinq sub-interface is tested. All edpl parameters in internal direction are configured and verified, which includes configuring and verifying the edpl profile.\n\nThis test is triggered by a change to the EDPL profile.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps dot1q",
                "Procedure": "To test the configuration of edpl in an internal direction on a bund L2 Dot1q sub-interface, configure and verify all edpl parameters. This test is triggered by a scenario that configures and verifies internal edpl behavior with an EDPL profile configured.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps dot1q secdot1q",
                "Procedure": "The configuration of edpl in internal direction on bundle L2 Dot1q Sub-interface is to be tested. The test involves configuring and verifying the internal edpl behavior, which includes setting up and checking all edpl parameters in this direction. This test is triggered by the existence of an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps default",
                "Procedure": "The configuration for edpl in internal direction on bundle L2 default subinterface is tested. All edpl parameters are configured and verified internally. The configuration includes an EDPL profile.\n\nThis test is triggered by the configuration of an EDPL profile for internal direction.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps dot1ad dot1q",
                "Procedure": "The configuration of EDPL in an internal direction on Bundle L2 Q-in-Q subinterface is tested. The test configures and verifies the internal EDPL behavior by setting up all EDPL parameters. This test is triggered by configuring an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext scale 100 phy sub",
                "Procedure": "To configure and verify the external direction of edpl on a phy L2 Dot1q 100 physical sub-interface, test its configuration settings. The process involves configuring and verifying all edpl parameters in this direction. A relevant EDPL profile includes 100 physical sub-interfaces.\n\nThis test is triggered by an attempt to configure a device with specific EDPL profile details.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext scale 100 bund sub",
                "Procedure": "The edpl configuration is tested for external direction on a phy L2 Dot1q 100 bundle sub-interface. The configuration includes an EDPL profile with 100 bundle sub-interfaces, and all relevant parameters are configured and verified in the external direction.\n\nThis test is triggered by configuring an EDPL profile with 100 bundle sub-interfaces to verify external edpl behavior.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int scale 100 phy0 sub",
                "Procedure": "To test the configuration of edpl in an internal direction on a phy L2 Dot1q 100 physical Sub-interface, one must configure and verify internal edpl behavior by configuring and verifying all edpl parameters in that direction. The configuration involves setting up an EDPL profile with 100 physical Sub-interfaces.\n\nThis test is triggered by a configuration of EDPL profile with 100 physical Sub-interfaces.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int scale 100 bund sub",
                "Procedure": "The test involves configuring the edpl in an internal direction on phy L2 Dot1q 100 bundle sub-interfaces, which includes setting up the internal edpl behavior. All edpl parameters are to be configured and verified for operation in this direction.\n\nThis test is triggered by the configuration of an EDPL profile with 100 bundle Sub-interfaces.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext scale l3 100 phy sub",
                "Procedure": "The configuration for the External Dedicated Physical Link (edpl) on phy L3 Dot1q 100 physical Sub-interface is tested by verifying that it configures and enables external edpl behavior. All parameters of the edpl are configured and verified in the direction from the outside into the device. This test is triggered by a configuration with an EDPL profile that includes 100 physical L3 Sub-interfaces.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext scale l3 100 bund sub",
                "Procedure": "The configuration of edpl in the external direction on phy L3 Dot1q 100 bundle subinterface is to be tested, specifically by verifying its edpl profile with 100 bundle sub-interfaces. This test configures and verifies external edpl behavior. Configuration: EDPL profile with 100 bundle Sub-interfaces.\n\nThis test is triggered by testing the configuration of edpl in the external direction on phy L3 Dot1q 100 bundle Sub-interface.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl external scale l3 l2 100 phy and bund sub combination",
                "Procedure": "The configuration of edpl in the external direction on phy L2 Dot1q 50 physical and 50 bundle Sub-interface should be tested, including configuring and verifying external edpl behavior. All edpl parameters in the external direction need to be configured and verified, specifically using an EDPL profile for 50 physical and 50 bundle sub-interfaces.\n\nThis test is triggered by the configuration of EDPL profiles on specific L2 Dot1q interfaces with varying sub-interface configurations.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps shut unshut lc mem",
                "Procedure": "The test tests the configuration of EDPL in an external direction on bundles over LC (light curve) members, configuring and verifying all external EDPL behavior and parameters.\n\nThis test is triggered by the requirement to configure EDPL profiles.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps bundle ac",
                "Procedure": "To test the configuration of edpl in the internal direction on bund L2 Dot1q Sub-interface, you configure and verify all edpl parameters for internal direction. The configuration includes an EDPL profile.\n\nThis test is triggered by configuring an EDPL profile to test its effects in the internal direction on a bund L2 Dot1q sub-interface.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl external scale 100 phy and bund combination sub",
                "Procedure": "The configuration of edpl is tested in an external direction on phy L2 Dot1q 50 physical and 50 bundle Sub-interface, which involves configuring and verifying the behavior of edpl when functioning externally. This test configures and verifies all edpl parameters in external direction. The configuration includes an EDPL profile on 50 physical and 50 bundle sub-interfaces.\n\nThis test is triggered by a requirement to configure and verify all EDPL parameters in the external direction, specifically involving physical and bundle sub-interfaces with an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int scale 100 phy and bund combination subs",
                "Procedure": "The configuration of edpl in internal direction is tested on a setup with 50 physical L2 Dot1q interfaces bundled into 50 sub-interfaces. This test configures and verifies the internal edpl behavior, including all relevant parameters such as those configured within an EDPL profile that supports 50 bundle sub-interfaces.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale 100 int ext combination",
                "Procedure": "The configuration of edpl in internal direction on 50 phy L2 Dot1q external direction 50 phy sub-interface is tested, as well as the internal edpl behavior which is configured and verified to ensure all parameters are correct. This test configures and verifies internal edpl behavior by setting up an EDPL profile with 100 physical sub-interfaces.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nEthernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl 10 sess int session vpws",
                "Procedure": "The test involves configuring the EDPL (Ethernet Distribution Link Aggregation Protocol) settings for internal traffic direction on a network setup with 10 physical sub-interfaces.\n\nThis test is triggered by configuring an EDPL profile on a VPWS (Virtual Private Wire Service) with 10 physical sub-interfaces.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl 10 sess ext session vpws",
                "Procedure": "The configuration of edpl is tested in the external direction on a network with 10 physical sub-interfaces. This test is triggered by configuring an EDPL profile on a VPWS that has 10 physical sub-interfaces.\n\nConfiguration: EDPL profile on vpws with 10 physical Sub-interfaces",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl 10 ext sess mtu 9200",
                "Procedure": "The test configures and verifies the external EDPL behavior, setting up an EDPL profile on 10 physical sub-interfaces with a configured MTU size of 9200 bytes in the external direction.\n\nThis test is triggered by the requirement to configure and verify all EDPL parameters in the external direction.",
                "Pass/Fail Criteria": "Show ethernet infra internal ea subs verification is performed.\nEthernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl 10 ext sess mtu 9150",
                "Procedure": "The configuration of the External Direction Linking Protocol (EDPL) is tested on 10 physical sub-interfaces, where the test configures and verifies how EDPL behaves externally when it is configured to have a large maximum transmission unit (MTU) size of 9150. This test is triggered by configuring an EDPL profile with settings for 10 physical sub-interfaces.",
                "Pass/Fail Criteria": "Show ethernet infra internal ea subs verification is performed.\nEthernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl 10 int sess mtu 9200",
                "Procedure": "The configuration of edpl in the internal direction is tested on 10 phy sub-interface by configuring and verifying internal edpl behavior, including all edpl parameters in the internal direction. This test is triggered by a change to an EDPL profile on a VPWS with 10 physical sub-interfaces that sets the MTU size to 9200.",
                "Pass/Fail Criteria": "Show ethernet infra internal ea subs verification is performed.\nEthernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl 10 ext sess remove read edpl collection",
                "Procedure": "The configuration of edpl in external direction on phy L2 Dot1q 10 physical sub-interface is tested. This test configures and verifies external edpl behavior by configuring an EDPL profile with 10 physical sub-interfaces, reading the collection start traffic, and verifying the results. All edpl parameters are configured and verified in external direction. Then, the EDPL profile is unconfigured along with the 10 physical sub-interfaces, where start traffic is read again to verify that the edpl configuration has been successfully removed.\n\nThis test is triggered by configuring an EDPL profile with multiple sub-interfaces.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int sess on cfm up mep phy 10 local xc",
                "Procedure": "The configuration of edpl in the internal direction on phy L2 Dot1q 10 physical Sub-interface is tested by checking that it configures and verifies internal edpl behavior. This test is triggered by a change to the configuration, which involves setting up an EDPL profile with 10 physical Sub-interfaces on cfm, starting traffic, and verifying all edpl parameters in the internal direction.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nCfm summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext sess on cfm up mep phy 10 local xc",
                "Procedure": "To test the configuration of edpl in an external direction on phy L2 Dot1q 10 physical sub-interface, we configure and verify the external edpl behavior. We configure and verify all edpl parameters in this external direction. EDPL profiles are created with 10 physical sub-interfaces on cfm, traffic is started, and then we verify the configuration.\n\nThis test is triggered by configuring an EDPL profile with 10 physical sub-interfaces on a CCM (cfm).",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nCfm summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale 10 int ext rewrite combinations pop push translate",
                "Procedure": "The configuration of edpl in internal direction on 10 phy L2 Dot1q external direction 10 phy Sub-interface is tested by verifying the internal edpl behavior, which includes configuring and verifying all edpl parameters. This test configures an EDPL profile with 10 physical Sub-interfaces.\n\nThis test is triggered when a configuration of an EDPL profile with 10 physical sub-interfaces needs to be verified for its internal operation on L2 Dot1q in the external direction over 10 physical interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nrewrite_mode: \"pop\" and \"push\" and \"translate\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale 10 int ext combination triggers shut unshut remove rollback",
                "Procedure": "The configuration of edpl is tested for both internal and external directions, with a focus on the internal direction using 10 phy L2 Dot1q connections and 10 phy sub-interfaces for external direction. The test configures and verifies the behavior of edpl internally, and also sets and checks all relevant parameters in the same direction. EDPL profile is configured with 10 physical Sub-interfaces.\n\nThis test is triggered by configuration: EDPL profile with 10 physical Sub-interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"shut_unshut_interface\" and \"remove_interface\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nVerify verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale 10 int ext combination triggers process restart",
                "Procedure": "The configuration of edpl in internal direction is tested on 10 phy L2 Dot1q external direction 10 phy Sub-interface, which also configures and verifies the internal edpl behavior. All edpl parameters in the internal direction are configured and verified, utilizing an EDPL profile with 10 physical Sub-interfaces.\n\nThis test is triggered by the configuration of an EDPL profile with 10 physical sub-interfaces, including both internal and external direction settings on 10 phy L2 Dot1q and 10 phy sub-interface configurations.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale 10 int ext combination lc reload",
                "Procedure": "The configuration of the edpl is tested in both internal and external directions, using a setup consisting of 10 phy L2 Dot1q sub-interfaces for external direction and 10 phy sub-interfaces internally.\n\nThis test configures and verifies the internal behavior of EDPL.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale 10 int ext combination rp iters active standby switchover",
                "Procedure": "The configuration of the Enhanced Distributed Link Aggregation Protocol (EDPL) is tested for both internal and external directions on a device with 10 physical Layer 2 Dot1q sub-interfaces. All EDPL parameters are configured and verified in the internal direction, and a specific EDPL profile is applied with 10 physical sub-interfaces. This test is triggered by configuring an EDPL profile with 10 physical Sub-interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger_mode: \"active_rp\" and \"standby_rp\" and \"switchover_rp\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nL2vpn xconnect summary verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl 10 int sess lxc",
                "Procedure": "The configuration of the EdpL in an internal direction is tested across 10 physical sub-interfaces. This test is triggered by configuring and verifying the internal EdpL behavior, which involves setting up all EdpL parameters in the same direction.\n\nEdPL Profile on lxc with 10 phy Sub-interface:",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl 10 ext sess lxc",
                "Procedure": "The configuration of EDPL in the external direction is tested on 10 physical sub-interfaces. All EDPL parameters are configured and verified for their proper functioning in this setup.\n\nThis test is triggered by configuring an EDPL profile on a LXC with 10 physical sub-interfaces.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext ipv6 support",
                "Procedure": "To test the configuration of EDPL on an IPv6 physical interface, you need to configure and verify all EDPL parameters in the external direction. The configuration includes setting up an EDPL profile.\n\nThis test is triggered by configuring an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext ipv4 support",
                "Procedure": "The configuration of edpl in an external direction on a physical IPv4 interface is tested by configuring and verifying all edpl parameters. This test configures and verifies the external edpl behavior, with specific focus on ensuring that all edpl parameters are properly set up.\n\nThis test is triggered by the requirement to configure EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl multicast support",
                "Procedure": "To test the configuration of multicast traffic, configure and verify all multicast parameters and interfaces. The process involves verifying multicast behavior and ensuring that all necessary settings are in place for proper operation. This test is triggered by a specific configuration requirement.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext sess swap mac phy l2 dot1q subinterface",
                "Procedure": "The test is designed to evaluate the configuration of edpl in an external direction on a phy L2 Dot1q Sub-interface. It configures and verifies the external edpl behavior, ensuring that all edpl parameters are correctly set. The setup involves configuring an EDPL profile.\n\nThis test is triggered by configuration: EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext sess swap mac dot1q secdot1q subinterface",
                "Procedure": "The configuration of edpl in an external direction on a physical layer two (L2) dot1q interface and its corresponding subinterface is tested. The setup involves configuring and verifying the external behavior of edpl, which includes setting up all required parameters for edpl in the external direction. This test configures and verifies external edpl behavior.\n\nThis test is triggered by EDPL profile configuration.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext sess swap mac default subinterface",
                "Procedure": "The edpl configuration is tested in the external direction on the phy L2 default Sub-interface. The setup involves configuring and verifying external edpl behavior, including all relevant edpl parameters. This test configures an EDPL profile.\n\nThis test is triggered by a manual trigger for testing the configuration of edpl in external direction on phy L2 default Sub-interface.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext sess swap mac dot1ad dot1q subinterface",
                "Procedure": "The test is designed to validate the configuration of EdpL in an external direction, specifically on a physical layer (L2) that supports both Dot1ad and Dot1q sub-interfaces. It configures and verifies the behavior of EdpL in this environment, ensuring all parameters are correctly set up for external operation. This test is triggered by the configuration of an EDPL profile.\n\nRewritten trigger sentence: This test is triggered by the configuration of an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vpws vlans encaps dot1q",
                "Procedure": "To test the edpl configuration in an external direction on bundle L2 Dot1q sub-interfaces, you need to configure and verify all edpl parameters for external behavior. The process involves setting up an EDPL profile.\n\nThis test is triggered by configuring an EDPL profile that meets the requirements of external edpl behavior.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vpws vlans encaps dot1q secdot1q",
                "Procedure": "The configuration of edpl in external direction on bundle L2 Dot1ad Sub-interface should be tested with a focus on the external edpl behavior, which involves configuring and verifying all edpl parameters in that direction.\n\nThis test is triggered by the need to configure an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vpws vlans encaps default",
                "Procedure": "The configuration of edpl in external direction is tested on bundle L2's default sub-interface. The test involves configuring and verifying the external edpl behavior, including all relevant parameters.\n\nThis test is triggered by configuring an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vpws vlans encaps dot1ad dot1q",
                "Procedure": "To test the edpl configuration in external direction on bundle L2 with Dot1ad and Dot1q sub-interfaces, we need to configure and verify all edpl parameters in this direction. This includes configuring and verifying an EDPL profile.\n\nTriggered by testing the edpl configuration in the external direction of a bundle L2 with Dot1ad and Dot1q sub-interfaces.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vpls vlans encaps dot1q",
                "Procedure": "The configuration of edpl in the external direction on bundle L2 Dot1q sub-interface is tested. This test configures and verifies all edpl parameters in the external direction, including those defined within an edpl profile. It is triggered by the need to determine how the device handles edpl settings when operating in this specific configuration scenario.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vpls vlans encaps dot1q secdot1q",
                "Procedure": "To test the configuration of edpl in an external direction on a bundle L2 Dot1ad sub-interface, configure and verify all edpl parameters in that direction. The process configures and verifies external edpl behavior.\n\nThis test is triggered by configuring an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vpls vlans encaps default",
                "Procedure": "The configuration of edpl in an external direction is tested on the bund L2 default sub-interface by configuring and verifying all edpl parameters in that direction. This test is triggered by testing the configuration of edpl in external direction on bund L2 default Sub-interface.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vpls vlans encaps dot1ad dot1q",
                "Procedure": "The configuration of edpl in an external direction on the bundle L2, specifically on Dot1ad and Dot1q sub-interfaces, is tested by verifying its configuration and functionality.\n\nThis test is triggered by configuring and verifying all external edpl parameters.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vpws vlans encaps dot1q",
                "Procedure": "The BGP Virtual Private Wire Service (VPWS) configuration for the internal direction of edpl on a bundle L2 Dot1q sub-interface needs to be tested. This test configures and verifies all internal edpl behavior, including configuring and verifying all relevant parameters. The configuration involves an EDPL profile. \nThis test is triggered by the need to verify that all edpl parameters are correctly configured in the internal direction of a bundle L2 Dot1q sub-interface.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vpws vlans encaps dot1q secdot1q",
                "Procedure": "To test the BGP Virtual Private Wire Service (VPWS) configuration for edpl in the Internal direction on bundle L2 Dot1ad Sub-interface, configure and verify all edpl parameters in this direction.\n\nThis test is triggered by configuring an EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vpws vlans encaps default",
                "Procedure": "The BGP VPWS configuration of edpl is tested for internal traffic flow through the bundle interface's L2 default sub-interface. The setup involves configuring and verifying the internal edpl behavior, which includes setting up all relevant edpl parameters in the internal direction. This test configures EDPL profile.\n\nThis test is triggered by testing the BGP VPWS configuration of edpl in Internal direction on bund L2 default Sub-interface.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vpws vlans encaps dot1ad dot1q",
                "Procedure": "The BGP Virtual Private Wire Service (VPWS) configuration of edpl is tested for the Internal direction on bundles L2 Dot1ad and Dot1q sub-interfaces. This test configures and verifies the internal behavior of edpl by setting up all parameters in the Internal direction, utilizing an EDPL profile. \n\nThis test is triggered by configuring an EDPL profile with specific parameters to verify the BGP VPWS configuration in the specified direction on L2 bundles with Dot1ad and Dot1q sub-interfaces.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vpls vlans encaps dot1q",
                "Procedure": "To test the BGP VPLS configuration of edpl in an internal direction on a bundle L2 Dot1q sub-interface, the edpl is configured and verified to ensure it behaves as expected in this direction. This includes configuring and verifying all edpl parameters in the internal direction. The configuration used for this purpose involves setting up an EDPL profile.\n\nThis test is triggered by the need to configure and verify EDPL parameters in the internal direction of a bundle L2 Dot1q sub-interface.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vpls vlans encaps dot1q secdot1q",
                "Procedure": "To test the BGP VPLS configuration, test the setup on the sub-interface with dot1ad enabled in bund L2 for the internal direction of edpl on a system with an EDPL profile configured.\n\nThis test is triggered by testing the BGP VPLS configuration's ability to configure and verify all parameters related to Internal edpl behavior.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vpls vlans encaps default",
                "Procedure": "The BGP VPLS configuration for edpl on the internal interface should be tested in both directions across bundle L2 default sub-interfaces, with a focus on verifying internal edpl behavior. This includes configuring and testing all relevant edpl parameters.\n\nThis test is triggered by the need to validate EDPL profile configurations.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vpls vlans encaps dot1ad dot1q",
                "Procedure": "The BGP VPLS configuration of edpl is tested for the Internal direction on the bund L2 interface, specifically with Dot1ad and Dot1q sub-interfaces. This test configures and verifies all edpl parameters in the Internal direction, utilizing an EDPL profile to define the necessary settings. \n\nThis test is triggered by configuring EDPL profile.",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nTraffic start stop verify verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps dot1q etm",
                "Procedure": "The edpl configuration in the external direction on a bundle L2 Dot1Q sub-interface is being tested for its correctness. The test involves configuring and verifying the external behavior of edpl, including all its parameters in the external direction. A specific EDPL profile has been configured as part of this setup.\n\nThis test is triggered by the need to verify that the edpl configuration in the external direction on a bundle L2 Dot1Q sub-interface is correct.",
                "Pass/Fail Criteria": "Edpl ext bundle vlans encaps dot1q verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps dot1q secdot1q etm",
                "Procedure": "The configuration of edpl in the external direction is tested for a bundle L2 Dot1ad sub-interface, specifically on the test_Edpl_Ext_bundle_vlans_encaps_dot1q_secdot1q_ETM setup. This involves configuring and verifying all edpl parameters operating in an external direction. The EDPL profile is configured as part of this process.\n\nThis test is triggered by a configuration that includes an EDPL profile.",
                "Pass/Fail Criteria": "Edpl ext bundle vlans encaps dot1q secdot1q verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps default etm",
                "Procedure": "The configuration of edpl in external direction on bund L2 default Sub-interface is tested. The configuration includes configuring and verifying all edpl parameters in external direction, with an EDPL profile being used.\n\nThis test is triggered by the configuration of an EDPL profile.",
                "Pass/Fail Criteria": "Edpl ext bundle vlans encaps default verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl ext bundle vlans encaps dot1ad dot1q etm",
                "Procedure": "The test for configuring edpl in an external direction on a bund L2 interface with Dot1ad and Dot1q sub-interfaces involves verifying the configuration's integrity. This test configures and verifies all external edpl behavior parameters, including EDPL profile configuration.\n\nThis test is triggered by configuring an EDPL profile.",
                "Pass/Fail Criteria": "Edpl ext bundle vlans encaps dot1ad dot1q verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps dot1q etm",
                "Procedure": "The edpl in internal direction on bund L2 Dot1q Sub-interface is tested for configuration. The test configures and verifies the internal edpl behavior, including all edpl parameters. This test is triggered by the creation of an EDPL profile that is used to configure and verify the internal edpl behavior.",
                "Pass/Fail Criteria": "Edpl int bundle vlan encaps dot1q verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps dot1q secdot1q etm",
                "Procedure": "The edpl test for internal bundle configurations on Layer 2 Dot1q sub-interfaces involves configuring and verifying the behavior of edpl in internal direction. This includes setting up all relevant edpl parameters. The configuration is based on an EDPL profile.\n\nThis test is triggered by the existence of an EDPL profile.",
                "Pass/Fail Criteria": "Edpl int bundle vlan encaps dot1q secdot1q verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps default etm",
                "Procedure": "The configuration of edpl in internal direction on bundle L2 default subinterface is tested by testing the Edpl Int Bundle Vlan Encaps Default ETM. This test configures and verifies internal edpl behavior, including all edpl parameters in internal direction.\n\nThis test is triggered by a configuration that includes an EDPL profile.",
                "Pass/Fail Criteria": "Edpl int bundle vlan encaps default verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl int bundle vlan encaps dot1ad dot1q etm",
                "Procedure": "The test for the Edpl bundle with VLAN encapsulation, Dot1ad, and Dot1q ETM configuration is designed to check the internal direction of the L2 Qinq sub-interface. It configures and verifies the internal Edpl behavior by setting up all necessary parameters in this direction, specifically using an EDPL profile that includes the relevant configurations. This test is triggered when a bundle is created with VLAN encapsulation enabled for both Dot1ad and Dot1q ETM protocols on an L2 Qinq sub-interface.",
                "Pass/Fail Criteria": "Edpl int bundle vlan encaps dot1ad dot1q verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "l2oam_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Traffic flow",
                "Procedure": "To test the traffic flow for CFM Functional Triggers, this test case verifies that the traffic flow is functioning correctly for all enabled streams. To achieve this, it follows these steps: it stops any currently running traffic, verifies that the traffic streams are stopped and not flowing, enables the required traffic streams, and then starts the traffic again for the streams that were enabled. Configuration settings are not relevant to this test case.\n\nThis test is triggered by enabling the specific CFM Functional Triggers traffic flow in the system configuration.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTGEN Traffic streams are running verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm y1731 pw services",
                "Procedure": "To verify the Ethernet SLA stats with CFM peer meps status on Up MEPs for Pseudowire Services, the following steps and configuration are required. The test involves verifying the Ethernet CFM peer status, clearing Ethernet SLA Statistics, checking the Ethernet SLA profile detail, verifying Ethernet SLA statistics for all configured performance stats, and updating the testcase status to results json. The configuration includes setting up Ethernet SLA profiles before entering the test case, configuring Interfaces with Y1731 profiles, and optionally setting DMM / SLM / LMM or no profile on the interfaces.\n\nThis test is triggered by the presence of Pseudowire Services in the network configuration.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail (If Y1731 profile is mapped) verification is performed.\nEthernet SLA statistics for all configured performace stats (If Y1731 profile is mapped) verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm y1731 pm threshold pw services",
                "Procedure": "Ethernet SLA stats are verified with PM threshold and CFM peer meps status validation on Up MEPs for Pseudowire Services. The verification process includes checking the Ethernet CFM peer status, clearing Ethernet SLA Statistics, verifying Ethernet SLA profile details, and checking Ethernet SLA statistics for all configured performance metrics. Furthermore, syslog messages are generated when threshold values are breached or cleared, which is also verified in this process. In terms of configuration, Ethernet SLA profiles are created before entering the test case, as well as configuring interfaces with Y1731 profiles and setting up both stateful and stateless profiles for Mean, Max, DMM, SLM, and LBM.\n\nThis test is triggered by the configuration of Ethernet SLA profiles.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail (For the Y1731 profile mapped) verification is performed.\nEthernet SLA statistics for all configured performace stats (For the Y1731 profile mapped) verification is performed.\nSyslog messages for threshold value breach and clear verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm y1731 local services",
                "Procedure": "The test case tests the CFM Up MEP, Down MEP, and Y1731 measurements over L2 Local Services. It's designed to verify Ethernet SLA statistics in conjunction with the status of CFM peer meps for Local Services. The steps involved are verifying the Ethernet CFM peer status, clearing Ethernet SLA Statistics, verifying Ethernet SLA profile details, verifying Ethernet SLA statistics for all configured performance stats, and updating the test case status to a results JSON. To prepare for this test case, Ethernet SLA profiles are configured along with interfaces featuring Y1731 profiles; additionally, DMM, SLM, LMM, or no profile configurations are set up beforehand.\n\nThis test is triggered by the configuration of Ethernet SLA profiles and interfaces with Y1731 profiles, as well as the setup of DMM, SLM, LMM, or no profile configurations.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail (If Y1731 profile is mapped) verification is performed.\nEthernet SLA statistics for all configured performace stats (If Y1731 profile is mapped) verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Down mep cfm y1731 local services",
                "Procedure": "The test cases verify various measurements including CFM Up MEP, Down MEP, and Y1731 over L2 Local Services. This test is triggered by the configuration of Ethernet SLA profiles, interfaces with Y1731 profiles, as well as DMM, SLM, and LMM settings. The test involves verifying the Ethernet CFM peer status, clearing Ethernet SLA statistics, checking the details of the Ethernet SLA profile, and verifying the statistics for all configured performance metrics. After these steps are completed, the testcase status is updated to reflect the results in a JSON format.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail (If Y1731 profile is mapped) verification is performed.\nEthernet SLA statistics for all configured performace stats (If Y1731 profile is mapped) verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm y1731 pm threshold local services",
                "Procedure": "When testing the Y1731 performance monitoring threshold, both up and down MEP over local services are verified. The Ethernet CFM peer status is checked, then Ethernet SLA statistics are cleared to establish a baseline. Next, the profile details for each statistic are verified, followed by a check that the statistics are correctly reporting all configured performance metrics. Additionally, it's confirmed that when threshold values are breached, syslog messages are generated and logged. After clearing the SLA statistics, it's verified again that the correct messages are sent when the thresholds are cleared. Lastly, the test status is updated to reflect the results in a JSON format.\n\nThis test is triggered by the configuration of Ethernet SLA profiles, including stateful and stateless profiles for Mean and Max values of DMM, SLM, and LBM on interfaces with Y1731 profiles configured beforehand.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail (For the Y1731 profile mapped) verification is performed.\nEthernet SLA statistics for all configured performace stats (For the Y1731 profile mapped) verification is performed.\nSyslog messages for threshold value breach and clear verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Down mep cfm y1731 pm threshold local services",
                "Procedure": "The test case is designed to verify Ethernet Service Level Agreement (SLA) statistics, including performance metrics and threshold values, as well as the status of CFM peer MEPs over Local Services. To do this, several steps are taken: verifying that CFM peers are online, clearing SLA statistics, checking SLA profile details, verifying performance metrics for all configured stats, ensuring that syslog messages are generated when thresholds are breached, and repeating the process to test threshold clearance. Additionally, Ethernet SLA profiles are set up, with both stateful and stateless configurations enabled, before the test begins.\n\nThis test is triggered by configuring Ethernet SLA profiles (with stateful and stateless Mean and Max DMM/SLM/LBM metrics) on interfaces prior to running the test case.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail (For the Y1731 profile mapped) verification is performed.\nEthernet SLA statistics for all configured performace stats (For the Y1731 profile mapped) verification is performed.\nSyslog messages for threshold value breach and clear verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm dmm min delay local services",
                "Procedure": "The test checks the minimum delay for Up MEP and Down MEP over L2 Local Services using the Y1731 DMM. This test is triggered by a configuration that includes Ethernet SLA Minimum Delay profiles, which are applied to interfaces configured with Y1731 DMM Min delay profiles before the test begins. The steps involve verifying various Ethernet CFM peer status, clearing SLA statistics, and checking for statistic history details on both Up MEP and Down MEP for minimum delay configurations. Additionally, on-demand configuration is enabled with a minimum delay profile, and SLA statistic history detail is verified in this mode.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet sla statistics history detail verification is performed.\nEthernet sla statistics history detail ondemand verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail verification is performed.\nEthernet SLA statistics for all configured performace stats verification is performed.\nEthernet SLA statistic history detail verification is performed.\nEthernet SLA statistic history detail on-demand verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Down mep cfm dmm min delay local services",
                "Procedure": "The Y1731 DMM minimum delay for Up MEP and Down MEP over L2 Local Services is tested. This test case verifies the Ethernet SLA statistic history details for Local Services with Minimum delay profiles by following these steps: verifying Ethernet CFM peer status, clearing Ethernet SLA statistics, verifying Ethernet SLA profile detail, verifying Ethernet SLA statistics for all configured performance stats, and verifying Ethernet SLA statistic history detail for bin value. Then, on-demand is enabled with a Minimum delay Configuration and the Ethernet SLA statistic history detail on-demand is verified. The testcase status is also updated to results json. The test case configuration involves configuring Ethernet SLA Minimum Delay profiles and Interfaces with Y1731 DMM Min delay profiles before entering the test case.\n\nThis test is triggered by the configuration of Ethernet SLA Minimum Delay profiles and interfaces that use Y1731 DMM minimum delay settings.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet sla statistics history detail verification is performed.\nEthernet sla statistics history detail ondemand verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail verification is performed.\nEthernet SLA statistics for all configured performace stats verification is performed.\nEthernet SLA statistic history detail verification is performed.\nEthernet SLA statistic history detail on-demand verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm loopback",
                "Procedure": "The test case is designed to verify the CFM loopback ping. The steps include verifying the CFM loopback ping and updating the test case status in the results JSON. No configuration is required for this test.\n\nThis test is triggered by a need to confirm that the CFM loopback ping functionality is working as expected.",
                "Pass/Fail Criteria": "Cfm loopback linktrace verification is performed.\nCFM loopback ping is reachable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Down mep cfm loopback",
                "Procedure": "This test case is designed to verify the CFM (Connectivity Fault Management) loopback ping. The steps involve verifying that the CFM loopback ping is successful, and then updating the test case status in the results JSON. No specific configuration is required for this test.\n\nThis test is triggered by a need to verify the connectivity between network devices using the CFM protocol, specifically through a loopback ping.",
                "Pass/Fail Criteria": "Cfm loopback linktrace verification is performed.\nCFM loopback ping is reachable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm linktrace",
                "Procedure": "The CFM linktrace test case verifies that the CFM linktraceroute function is working correctly. It involves verifying the CFM link traceroute and then updating the test case status in the results JSON file. The test does not require any specific configuration.\n\nThis test is triggered by verification of the CFM link traceroute functionality.",
                "Pass/Fail Criteria": "Cfm loopback linktrace verification is performed.\nCFM link traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Down mep cfm linktrace",
                "Procedure": "This test case is designed to verify the CFM (Connectivity Fault Management) linktrace. The steps involve verifying that the CFM link traceroute works correctly, and then updating the test case status to a JSON file for tracking purposes. No configuration changes are required. This test is triggered by the need to confirm that CFM link tracing functions as expected.\n\n(Rewritten trigger sentence:)\n\nThis test is triggered by the requirement to verify CFM link trace functionality.",
                "Pass/Fail Criteria": "Cfm loopback linktrace verification is performed.\nCFM link traceroute verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm gre scenarios",
                "Procedure": "The test verifies the CFM Up MEP over VPWS over Static MPLS over GRE tunnels by configuring a GRE tunnel in L2VPN control word mode, verifying that CFM and Y1731 features function as expected, and updating the testcase status. To trigger this test, a GRE profile must be configured to enable Ethernet CFM over L2VPN.\n\nTrigger: This test is triggered by configuring a GRE profile for L2VPN with Ethernet CFM enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ngre_tunnel_mode: \"single_pass\" and \"two_pass\"\nl2vpn_cw: \"l2vpn_control_word\" and \"l2vpn_no_control_word\"",
                "Pass/Fail Criteria": "All features verification is performed.\nEthernet CFM peer meps status verification is performed.\nEthernet CFM AIS and LLF features verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm gre tunnel shut noshut",
                "Procedure": "The test case is designed to verify the operation of CFM over GRE tunnels in both shut and no-shut scenarios. The steps involved include shutting and then unshutting the GRE tunnel interfaces, verifying that the CFM and Y1731 features are functioning correctly, and updating the test case status accordingly. To configure this scenario, Ethernet CFM is set up to run over a GRE profile configured via L2VPN.\n\nThis test is triggered by configuring an Ethernet CFM service to operate over a GRE tunnel established using L2VPN.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntunnel_test: \"active_tunnel\" and \"backup_tunnel\" and \"random_active_tunnels\"",
                "Pass/Fail Criteria": "All features verification is performed.\nEthernet CFM peer meps status verification is performed.\nEthernet CFM AIS and LLF features verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm gre mpls static path transition",
                "Procedure": "To verify the CFM over GRE MPLS Static Tunnel Transition, a testcase is designed with the following steps. It first moves the mpls static paths from active tunnel to backup tunnel and then verifies the CFM and Y1731 features. Next, it moves the mpls static paths from backup tunnel to active tunnel. Once complete, the testcase status is updated in the results json file. The configuration involves setting up an Ethernet CFM over L2VPN GRE profile before proceeding with the test case.\n\nThis test is triggered by configuring an Ethernet CFM over L2VPN GRE profile.",
                "Pass/Fail Criteria": "Ethernet CFM peer meps status verification is performed.\nEthernet CFM AIS and LLF features verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm y1731 ccm timers",
                "Procedure": "The test case verifies Ethernet CFM peer status, clears Ethernet SLA statistics, and checks Ethernet SLA profile details. It also measures performance statistics for all configured performance metrics and updates the test case results in a JSON file. To perform this test, Ethernet SLA profiles must be configured before running the test, as well as interfaces with Y1731 profiles. Additionally, DMM, SLM, LMM, or no profiles can be used in conjunction with the test.\n\nThis test is triggered by configurations for Ethernet SLA profiles, interfaces with Y1731 profiles, and one of DMM, SLM, LMM, or no profiles.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail (If Y1731 profile is mapped) verification is performed.\nEthernet SLA statistics for all configured performace stats (If Y1731 profile is mapped) verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Down mep cfm y1731 ccm timers",
                "Procedure": "This test is triggered by configuring Ethernet SLA profiles, interfaces with Y1731 profiles, and other network settings. The test then verifies the Ethernet CFM peer status, clears Ethernet SLA statistics, and checks the details of Ethernet SLA profiles. It also measures Ethernet SLA statistics for all configured performance metrics before updating the test case status in a JSON results file.\n\nThe rewritten trigger sentence is: This test is triggered by configuring Ethernet SLA profiles, interfaces with Y1731 profiles, and other network settings.",
                "Pass/Fail Criteria": "Cfm peer meps verification is performed.\nEthernet sla detail verification is performed.\nEthernet sla statistics verification is performed.\nEthernet CFM peer status verification is performed.\nEthernet SLA profile detail (If Y1731 profile is mapped) verification is performed.\nEthernet SLA statistics for all configured performace stats (If Y1731 profile is mapped) verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm domain level",
                "Procedure": "This test is triggered by a modification to the domain-level configuration. The test verifies that the domain level change on Ethernet Connectivity Fault Management (CFM) is functioning correctly by configuring the change, verifying its effect, reverting the change, and then verifying that features continue to work as expected. This involves testing with various configurations including CFM, L2VPN, MPLS, Interior Gateway Protocol (IGP), and interfaces, which are set up prior to running this test case.",
                "Pass/Fail Criteria": "CFM Peer MEPS verification is performed.\nCFM AIS if applicable verification is performed.\nEFD if applicable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cfm domain service maid",
                "Procedure": "The purpose of this test is to verify that changes to a service maid on an Ethernet CFM domain can be made correctly. To accomplish this, we configure the domain and service maid change, check that the features work as expected, undo the changes, and then check again. The configurations necessary for this test include CFM, L2VPN, MPLS, IGP, and interface settings, which are all set up beforehand. Additionally, during the test case itself, we modify the Maintenance Domain ID (MDID) and Short Maintenance Association (MA) Name (SMAN) configurations. This test is triggered by a change to the service maid on an Ethernet CFM domain.",
                "Pass/Fail Criteria": "CFM Peer MEPS verification is performed.\nCFM AIS if applicable verification is performed.\nEFD if applicable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Up mep cfm fault scenarios",
                "Procedure": "The test case is designed to verify different types of faults on Ethernet CFM. The configuration involves setting up a fault scenario as described in the trigger section, which requires configuring CFM.\n\nThis test is triggered by the specific fault scenario configured according to the given requirements and specified in the trigger section.",
                "Pass/Fail Criteria": "Trigger and recover fault verification is performed.\nCFM Peer MEPS verification is performed.\nCFM AIS if applicable verification is performed.\nEFD if applicable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Down mep cfm fault scenarios",
                "Procedure": "The test case tests the CFM (Connectionless-Oriented Operations, Administration, and Maintenance) faults for a Down MEP (Maintenance Entity Group End Point). It is designed to verify different types of faults on Ethernet CFM. The process involves configuring the fault scenario as described in the trigger section.\n\nThis test is triggered by selecting a Fault scenario from the list of options that includes specific settings for testing different types of faults on an Ethernet CFM, such as \"Fault type\", \"MEP ID\", and other relevant parameters.",
                "Pass/Fail Criteria": "Trigger and recover fault verification is performed.\nCFM Peer MEPS verification is performed.\nCFM AIS if applicable verification is performed.\nEFD if applicable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bfd multipath unconfig config",
                "Procedure": "The purpose of this test is to verify a Border Gateway Protocol Fast Detection (BFD) scenario that includes Multipath and Connection-Oriented Forwarding with IP Multicast (CFM), specifically for configuration and unconfiguration of the BFD multipath include command. This process involves verifying the CFM and BFD sessions before testing, then unconfiguring and reconfiguring the BFD multipath include command while running the test scenario and finally verifying the CFM and BFD sessions after these operations.\n\nThis test is triggered by a series of specific configuration settings, including CFM, Layer 2 Virtual Private Network (L2VPN), Multiprotocol Label Switching (MPLS), Interior Gateway Protocol (IGP) routing, interface configurations, and BFD.",
                "Pass/Fail Criteria": "Bfd session verification is performed.\nAll features verification is performed.\nCFM Peer MEPS verification is performed.\nBFD session verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bfd igp unconfig config",
                "Procedure": "The test case is designed to verify a BFD scenario with CFM, specifically focusing on the unconfiguration and reconfiguration of BFD under IGP protocols such as ISIS and OSPF. To set up this testing, BFD multipath include command and BFD under IGPs are configured before the start of the test case, while CFM and BFD sessions are verified beforehand for a baseline comparison. The steps involved in this test case include unconfiguring and then reconfiguring BFD under IGP, followed by running the BFD test scenario and verifying both CFM and BFD sessions after these operations.\n\nThis test is triggered by unconfiguring and configuring BFD under IGP (ISIS & OSPF).",
                "Pass/Fail Criteria": "Bfd session verification is performed.\nAll features verification is performed.\nCFM Peer MEPS verification is performed.\nBFD session verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bfd flap interfaces",
                "Procedure": "To verify a BFD scenario with CFM, flap the BFD interfaces on a device that has been configured with BFD multipath include command and BFD under IGPs. The configuration should also include CFM, L2VPN, MPLS, IGP, interface, and BFD. Prior to testing, verify that CFM and BFD sessions are established. Flap the BFD interfaces, run the BFD test scenario, flap the BFD interfaces again, and then verify that CFM and BFD sessions remain established.\n\nThis test is triggered by flapping the BFD interfaces on a device configured with BFD multipath include command and BFD under IGPs.",
                "Pass/Fail Criteria": "Bfd session verification is performed.\nAll features verification is performed.\nCFM Peer MEPS verification is performed.\nBFD session verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles with cfm",
                "Procedure": "The testcase is designed to verify a SADT scenario with CFM. To configure the testing environment, SADT profiles are set up and service-activation is attached to interfaces on the Device Under Test (DUT), while ethernet loopback is configured on interfaces on a peer device in the setup class. Before running the test, verification of CFM and related features ensures proper functionality. The test scenario for SADT is then executed, followed by starting ethernet loopback on the peer and ethernet service-activation on the DUT. The CFM and SADT session are verified after these actions.\n\nThis test is triggered by verifying that all necessary configurations are in place, including CFM, L2VPN, MPLS, IGP, interface, and SADT settings, which are configured beforehand.",
                "Pass/Fail Criteria": "All features verification is performed.\nSadt session verification is performed.\nCFM Peer MEPS verification is performed.\nEthernet Service-Activation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Functional trigger",
                "Procedure": "The test case verifies the functional triggers on both Ethernet Connectivity Fault Management (CFM) and Service Level Agreements (SLA). It involves configuring, verifying, reverting, and re-verifying the features, which include connectivity fault management, Layer 2 VPNs, Multiprotocol Label Switching, Interior Gateway Protocols, and interfaces. This test is triggered by the need to validate the operational triggers of CFM and SLA on a device that supports Ethernet-based services.",
                "Pass/Fail Criteria": "CFM Peer MEPS verification is performed.\nEthernet SLA profile detail if applicable verification is performed.\nEthernet SLA statistics for all configured performace stats if applicable verification is performed.\nEthernet SLA statistic history detail if applicable verification is performed.\nCFM AIS if applicable verification is performed.\nEFD if applicable verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "System triggers with l2oam",
                "Procedure": "To test a High Availability (HA) event on the Device Under Test (DUT), we need to ensure that Layer 2 Operations, Administration, and Maintenance (L2OAM) configurations are in place. This trigger is intended for Tests the System, which involves performing a HA event on the DUT with L2OAM configurations already set up. The test case aims to validate the HA trigger scenarios on L2OAM by verifying several conditions before and after triggering the HA event. Specifically, we need to check that traffic streams are good and running, and that all necessary features and configurations for L2OAM are correct, both initially and after the HA event has been triggered. Furthermore, the test requires that CFM and Y1731 profiles are configured beforehand.\n\nThis test is intended to be triggered by Tests the System, when L2OAM configurations are already set up on the DUT.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTGEN Traffic streams are running verification is performed.\nCFM peer meps are up verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "l2_sadt_edpl_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Sadt cit profiles external",
                "Procedure": "Profiles generated through CIT on L2VPN Services and stats on default interface type are tested by verifying SADT statistics, loss, delay, and other metrics after configuring SADT on the DUT interface and EDPL on the peer device interface.\n\nThis test is triggered by the configuration of SADT on the DUT's default interface type and EDPL on the peer device's interface.",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt cit profiles internal",
                "Procedure": "Profiles for Y1564 are generated through CIT on L2VPN Services with Internal and External Switched Access Device Test (SADT) on default interface type. The test involves starting the Service Activation Test on interfaces, verifying SADT statistics such as loss and delay, stopping SADT on interfaces, and then halting EDPL on the peer device's interface. Configuration includes setting up SADT on the DUT interface and EDPL on the peer device interface.\n\nThis test is triggered by the configuration of Switched Access Device (SADT) on the Device Under Test (DUT) interface, External Dynamic Peer Discovery Link (EDPL) on the peer device's interface.",
                "Pass/Fail Criteria": "Profile supported verification is performed.\nSadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Traffic flow",
                "Procedure": "The traffic flow for Up MEPs (Maintenance Entity Protect) on Pseudowire Services is tested to verify its functionality. This test stops the current traffic, verifies that it is indeed stopped, then enables the streams and starts the traffic again for those that are enabled.",
                "Pass/Fail Criteria": "Traffic verification is performed.\nTGEN Traffic streams are running verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l2vpn xconnect l2 bundle sub",
                "Procedure": "The test for L2VPN Xconnect service with L2 sub-interface involves creating a test profile for SADT (Service Activation Detection and Test). This process is triggered by the need to verify specific parameters such as loss, delay, etc. in the SADT statistics. To perform this test, start Ethernet Data Plane Loopback on the peer device and initiate Service Activation Testing on the interfaces. Verify that the SADT stats are accurate, then stop SADT on the interfaces and shut down EDPL (Ethernet Data Plane Loopback) on the peer device. Finally, update the testcase status to the results JSON.\n\nThis test is triggered by the need to verify specific parameters such as loss, delay, etc. in the SADT statistics.",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l2vpn xconnect l2 physical sub",
                "Procedure": "The test for L2VPN Xconnect service with a sub-interface checks the Service Availability and Data Terminal (SADT) profiles. The steps involve starting an Ethernet data plane loopback on the peer device, activating the service on the interfaces, verifying SADT statistics such as loss and delay, stopping SADT on the interfaces, shutting down the Ethernet data plane loopback on the peer device, and updating the test case status to a JSON results file. To run this test, SADT is configured on the DUT interface and Ethernet data plane loopback is enabled on the peer device interface. This test is triggered by the configuration of SADT on the device under test (DUT) interface and EDPL on the peer device interface.",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l2vpn vpws l2 bundle sub",
                "Procedure": "The test for L2VPN Xconnect service with L2 sub-interface involves creating a common SADT profile. The steps include starting Ethernet Data Plane Loopback on the Peer device and Service Activation Test on interfaces, verifying SADT statistics such as loss and delay, stopping SADT on interfaces, halting EDPL on the Peer device, and updating the testcase status to results json. Configuration includes setting up SADT on DUT interface, and EDPL on peer device interface.\n\nThis test is triggered by configuring a common fixture for L2 sub-interface services with L2VPN Xconnect service parameters.",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l2vpn vpws l2 physical sub",
                "Procedure": "To test SADT profiles for L2VPN Xconnect service with a Layer 2 sub-interface, start by setting up the Ethernet Data Plane Loopback on the Peer device and activating the Service Activation Test on its interfaces. Then verify the SADT statistics, latency, and packet loss. After that, stop SADT on those interfaces, shut down the EDPL on the Peer device's interface, and update the testcase status in the results JSON file. To configure this test, you need to set up SADT on the Device Under Test (DUT) interface and EDPL on the peer device's interface.\n\nThis test is triggered by configuring SADT on the DUT interface and EDPL on the peer device's interface.",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l3 main",
                "Procedure": "The test for L3 service with main interface involves starting the Ethernet Data Plane Loopback on a peer device and the Service Activation Test on interfaces. The test then verifies statistics such as loss and delay from the SADT stats, stops SADT on the interfaces, and EDPL on the peer device. After this, it updates the testcase status to results json. This test is triggered by configuring SADT on a DUT interface and EDPL on a peer device interface.",
                "Pass/Fail Criteria": "Profile supported verification is performed.\nSadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l3 sub",
                "Procedure": "To test Service Activation Data Transmission (SADT) profiles on the Layer 3 sub-interface, follow these steps. Start by starting an Ethernet Data Plane Loopback on a Peer device and then start the Service Activation Test on interfaces. Next, verify that SADT statistics such as loss, delay, etc., are correct. After that, stop SADT on the interfaces, followed by stopping the EDPL on the Peer device. Finally, update the testcase status to the results in the JSON file. Configure SADT on the Device Under Test's interface and EDPL on the peer device's interface.\n\nThis test is triggered by configuring Service Activation Data Transmission (SADT) on the DUT interface and Ethernet Data Plane Loopback (EDPL) on the peer device's interface.",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l2vpn xconnect l2 bundle sub multicast",
                "Procedure": "The test for L2VPN Xconnect service with a Layer 2 sub-interface checks the SADT profiles. This involves configuring the Service Activation Test and measuring its performance, including statistics like loss and delay, while also setting up an Ethernet Data Plane Loopback on the peer device and updating the test case status.\n\nThis test is triggered by configuring SADT on the DUT interface and EDPL on the peer device interface.",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l2vpn vpws l2 physical sub multicast",
                "Procedure": "Test SADT profiles for L2VPN Xconnect service with L2 sub-interface. To trigger this test, it is necessary that a Service Activation Test be triggered by starting Ethernet Data Plane Loopback on the Peer device.\n\nConfiguration: \n- Configure SADT on DUT interface \n- Configure EDPL on peer device interface \n\nSteps:\n- Start Service Activation Test on interfaces\n- Verify SADT Stats, loss, delay etc.\n- Stop SADT on interfaces\n- Stop EDPL on Peer device\n- Update the testcase status to results json",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2vpn local xconnect l2 bundle sub",
                "Procedure": "The test case is used to verify the EDPL filters on L2 subinterfaces. It involves starting Ethernet Data Plane Loopback on L2 subinterfaces for various services, initiating and terminating appropriate EDPL streams on TGN, verifying TGEN streams for received traffic, stopping EDPL on the DUT, and updating the testcase status to results json. The test is configured with EDPL enabled on the DUT interface. This test is triggered by starting Ethernet Data Plane Loopback on L2 subinterfaces for various services.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2vpn local xconnect l2 physical sub",
                "Procedure": "To test EDPL filters on L2 Subinterfaces, start Ethernet Data Plane Loopback on L2 subinterfaces for various services and activate EDPL Streams on TGN. Then verify that TGEN streams show Rx traffic, deactivate the EDPL on the device under test, and update the testcase status to reflect the results in a json file.\n\nThis test is triggered by configuring EDPL on the DUT interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2vpn local bridgedomain l2 bundle sub",
                "Procedure": "The test case is used to evaluate the effectiveness of EDPL filters on L2 Subinterfaces, specifically for various services. It involves starting Ethernet Data Plane Loopback on these subinterfaces, activating and deactivating relevant EDPL Streams on TGN, checking TGEN streams for incoming traffic, disabling EDPL on the DUT, and updating the test case status in the results JSON file. To trigger this test, This test is triggered by configuring EDPL on the DUT interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2vpn local bridgedomain l2 physical sub",
                "Procedure": "To test the EDPL filters on L2 Subinterfaces, start Ethernet Data Plane Loopback on these subinterfaces for various services. Start and stop appropriate EDPL Streams on TGN, then verify that TGEN streams show Rx traffic. Next, stop EDPL on the Device Under Test and update the testcase status to reflect the results in a json file. The DUT interface must be configured with EDPL.\n\nThis test is triggered by configuration of EDPL on the DUT interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2vpn vpws l2 bundle sub",
                "Procedure": "The test case is used to evaluate the effectiveness of EDPL filters on L2 Subinterfaces. The process involves starting Ethernet Data Plane Loopback on L2 subinterfaces for various services, initiating and terminating EDPL streams on TGN, verifying traffic reception through TGEN streams, halting EDPL on DUT, and updating the test case status in a results JSON. EDPL must be configured on the DUT interface as part of this evaluation. This test is triggered by the need to verify that L2 Subinterfaces with EDPL filters function correctly under various service conditions.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2vpn vpws l2 physical sub",
                "Procedure": "To test the EDPL filters on L2 Subinterfaces, start Ethernet Data Plane Loopback on various services' L2 subinterfaces. Start and stop appropriate EDPL Streams on TGN, verify TGEN streams for Rx traffic, then stop EDPL on the Device Under Test (DUT). Finally, update the testcase status to results json. This test is triggered by configuring EDPL on DUT interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2vpn vpls l2 bundle sub",
                "Procedure": "The test case is used to verify the functionality of the EDPL filters on L2 subinterfaces. The test involves starting Ethernet Data Plane Loopback on L2 subinterfaces for various services, initiating and stopping appropriate EDPL Streams on TGN, verifying TGEN streams for received traffic, stopping EDPL on DUT, updating the testcase status in results json, and configuring EDPL on DUT interface.\n\nThis test is triggered by the need to validate the operation of EDPL filters under various conditions.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2vpn vpls l2 physical sub",
                "Procedure": "To test the EDPL filters on L2 Subinterfaces, start Ethernet Data Plane Loopback on L2 subinterfaces for various services and initiate EDPL Streams on TGN. Verify that TGEN streams show received traffic. Next, stop EDPL on the DUT and update the testcase status to results json.\n\nThis test is triggered by configuration of EDPL on the DUT interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale filters l2vpn services single intf l2 bundle",
                "Procedure": "The test case is used to verify the EDPL filters on L2 Subinterfaces. The process involves starting Ethernet Data Plane Loopback on various services, enabling and disabling appropriate EDPL Streams on TGN, checking for Rx traffic in TGEN streams, stopping EDPL on the Device Under Test, updating the testcase status, and configuring EDPL on the DUT interface.\n\nThis test is triggered by the presence of a common fixture that includes EDPL services for L2 Subinterfaces.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale filters l2vpn services single intf l2 physical",
                "Procedure": "The test case is used to evaluate the effectiveness of the EDPL filters on L2 Subinterfaces. This involves starting Ethernet Data Plane Loopback on L2 subinterfaces for various services, initiating and terminating appropriate EDPL Streams on TGN, verifying the TGEN streams for received traffic, stopping EDPL on DUT, and updating the testcase status in a results JSON file. To trigger this test, it is activated when specific conditions are met, which involves configuring EDPL on the DUT interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l3",
                "Procedure": "To test the EDPL filters, start Ethernet Data Plane Loopback on L3 interfaces, then initiate and terminate appropriate EDPL Streams on TGN. Next, verify that TGEN streams are receiving traffic correctly. After this, stop EDPL on the Device Under Test (DUT), and update the testcase status to reflect the results in a JSON file. The configuration for this test case involves setting up EDPL on the DUT interface.\n\nThis test is triggered by the start of Ethernet Data Plane Loopback on L3 interfaces.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale filters l2vpn services single intf l3 bundle",
                "Procedure": "This test case is used to verify how the EDPL filters perform on L2 Subinterfaces. It involves starting Ethernet Data Plane Loopback on subinterfaces for various services, then initiating and stopping EDPL Streams on TGN as needed. Next, TGEN streams are checked for Rx traffic before stopping EDPL on the DUT. Finally, the testcase status is updated to a results json. The test setup includes configuring EDPL on the DUT interface.\n\nThis test is triggered by configuration of EDPL on the DUT interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl scale filters l2vpn services single intf l3 physical",
                "Procedure": "The test case is used to test the Enhanced Discovery Protocol Learning (EDPL) filters on Layer 3 Subinterfaces. To do this, Ethernet Data Plane Loopback must be started on L2 subinterfaces for various services, and EDPL Streams must be initiated and terminated on TGN according to the appropriate configuration. The TGEN streams are then verified to ensure that Rx traffic is being received correctly. Once completed, EDPL is stopped on the DUT interface, and the testcase status is updated in the results json file.\n\nThis test is triggered by configuring Enhanced Discovery Protocol Learning (EDPL) on the Data Under Test (DUT) interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2 physical sub multicast",
                "Procedure": "The test case is used to verify the functionality of EDPL filters by testing Ethernet Data Plane Loopback on L3 interfaces, with appropriate EDPL Streams started and stopped on TGN. The process involves starting Ethernet Data Plane Loopback on L3 interfaces, initiating and terminating relevant EDPL Streams on TGN, checking TGEN streams for received traffic, stopping EDPL on the DUT (Device Under Test), and updating the testcase status to include the results in a JSON format.\n\nThis test is triggered by configuring EDPL on the DUT interface.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2 bundle sub multicast",
                "Procedure": "The test case is used to evaluate the Ethernet Data Plane Loopback (EDPL) filters. The process begins with starting Ethernet Data Plane Loopback on L3 interfaces, followed by initiating and terminating appropriate EDPL Streams on TGN. Next, it involves verifying TGEN streams for received traffic, halting EDPL on the DUT, and updating the testcase status to the results json. Configuration of EDPL on the DUT interface is also required. This test is triggered by common_fixture_edpl_l3.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l3 physical sub multicast",
                "Procedure": "The test case is used to test the EDPL filters. The process involves starting Ethernet Data Plane Loopback on L3 interfaces, then initiating and stopping appropriate EDPL Streams on TGN, followed by verifying TGEN streams for Rx traffic, stopping EDPL on the DUT, and updating the testcase status in the results json. To configure the test, EDPL must be configured on the DUT interface.\n\nThis test is triggered by a configuration where EDPL is set up on a device under test (DUT) interface.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l3 bundle sub multicast",
                "Procedure": "The test case is used to test the EDPL filters with a common fixture EDPL L3. To perform this test, start Ethernet Data Plane Loopback on L3 interfaces and initiate appropriate EDPL streams on TGN. Verify that the TGEN streams are receiving traffic, then stop the EDPL on the DUT. After completing these steps, update the testcase status to results json.\n\nThis test is triggered by a common fixture EDPL L3.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles l2 services main interfaces",
                "Procedure": "To test Service Activation Data Transfer (SADT) profiles for L2 Services on L2 Main interfaces, start by configuring SADT on the Device Under Test's interface and Ethernet Data Plane Loopback on the peer device. Next, activate the service on the specified interfaces using the Service Activation Test. Once activated, verify that the SADT statistics, loss, delay, etc., are as expected. After that, deactivate the SADT on the interfaces and stop the Ethernet Data Plane Loopback on the peer device. Finally, update the testcase status to reflect the results in a JSON file.\n\nThis test is triggered by configuring Service Activation Data Transfer (SADT) on the Device Under Test's interface and Ethernet Data Plane Loopback on the peer device interface.",
                "Pass/Fail Criteria": "Profile supported verification is performed.\nSadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Edpl filters l2 main interfaces",
                "Procedure": "The test case is used to test the EDPL filters on L2 Main interfaces, with parameters common_fixture_edpl_services_l2_main. The process involves starting Ethernet Data Plane Loopback on L2 subinterfaces for various services and initiating and terminating appropriate EDPL Streams on TGN. Verification includes checking TGEN streams for received traffic. Once complete, EDPL is stopped on the DUT, and the testcase status is updated to results in a JSON format. EDPL must be configured on the DUT interface beforehand.\n\nThis test is triggered by the configuration of EDPL on the DUT interface.",
                "Pass/Fail Criteria": "Edpl filters verification is performed.\nTGEN streams traffic looped back. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt clis",
                "Procedure": "To run the Service Activation Test using the SADT CLI options 'abort' and 'clear', start by starting Ethernet Data Plane Loopback on a Peer device and then initiate Service Activation Test on interfaces, but abort the test immediately. Next, verify the status of the SADT test. After that, stop the SADT service on those interfaces and also shut down the Ethernet Data Plane Loopback on the Peer device. Finally, update the testcase status to reflect the results in JSON format. To do all this, you need to configure SADT on the DUT interface and EDPL on the peer device interface.\n\nThis test is triggered by configuring Service Activation Test on a Device Under Test's interface and Ethernet Data Plane Loopback on a Peer device's interface.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt ir rates",
                "Procedure": "The test for SADT IR Rates Modification involves starting the Ethernet Data Plane Loopback on the peer device, activating a Service Activation Test on interfaces with modified interest rates, and verifying statistics such as loss and delay. The SADT is then stopped on the interfaces, followed by stopping the EDPL on the peer device. After completing these steps, the testcase status is updated to the results json. To perform this test, it is necessary to configure SADT on the DUT interface and EDPL on the peer device interface.\n\nThis test is triggered by modification of IR rates through a common fixture.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt duration",
                "Procedure": "To run this test, several steps must be followed. The Ethernet Data Plane Loopback should first be started on a peer device, and then the Service Activation Test initiated on interfaces with modified durations as specified in profiles. Once the modified duration wait time has passed, verify that SADT statistics such as loss and delay are accurate. After this verification is complete, stop the SADT test and the EDPL loopback, and update the testcase status to a results json.\n\nThis test is triggered by starting Ethernet Data Plane Loopback on Peer device.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt modifier interface mtu",
                "Procedure": "The test for SADT Profiles with Interface MTU modifier is triggered by enabling Ethernet Data Plane Loopback on a peer device. It starts Service Activation Test with specific profiles on interfaces that have been modified to adjust the MTU (Maximum Transmission Unit). The test then verifies various statistics, including loss and delay, while the SADT Stats are being run. After stopping the SADT on the interfaces and the Ethernet Data Plane Loopback on the peer device, it updates the testcase status in a results json.\n\nThis test is triggered by enabling Ethernet Data Plane Loopback on a peer device.",
                "Pass/Fail Criteria": "Sadt verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt profiles with cfm",
                "Procedure": "To test a Layer 2 VPN Xconnect service with a Layer 2 sub-interface, configure SADT on the DUT's interface and EDPL on the peer device's interface. The test then proceeds as follows: it starts Ethernet Data Plane Loopback on the peer device, starts Service Activation Test on interfaces, verifies SADT statistics, loss, delay, etc., stops SADT on interfaces, stops EDPL on the peer device, and finally updates the testcase status to a results JSON file. This test is triggered by configuring SADT on a DUT interface and EDPL on a peer device interface.",
                "Pass/Fail Criteria": "Cfm verification is performed.\nSadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sadt encap rewrite",
                "Procedure": "The test for Service Activation Data Transfer (SADT) profiles involves testing encapsulations and rewrite types. This is done by configuring SADT on the Device Under Test (DUT) interface and Ethernet Data Plane Loopback (EDPL) on the peer device interface with different encapsulations and rewrites, then verifying statistics, loss, and delay metrics while the tests are running.\n\nThis test is triggered by configuration that involves testing encapsulations and rewrite types.",
                "Pass/Fail Criteria": "Sadt profiles verification is performed.\nSADT profile details verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "l2pt_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Cdp basic verification",
                "Procedure": "The test for basic OSPF, LDP, and CDP verification over L2pT on the main interface and untagged EVC includes verifying OSPF, MPLS LDP, and CDP. \n\nThis test is triggered by the configuration of OSPF, L2PT, LDP, and CDP.",
                "Pass/Fail Criteria": "Ospf neighbor verification is performed.\nMpls ldp verification is performed.\nCdp neighbor verification is performed.\nOSPF: Verify OSPF session is established verification is performed.\nMPLS LDP: Verify MPLS session is established verification is performed.\nCDP : Verify CDP session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cdp verification over l2pt",
                "Procedure": "The test verifies the basic functionality of Layer 2 Provider Tunneling (L2PT) in a network environment that includes Open Shortest Path First (OSPF), L2PT, Link Data Protocol (LDP), and Cisco Discovery Protocol (CDP). This test is triggered by the verification of OSPF and CDP.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT: Verify ENCAP/DECAP on LPTS punt. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Cdp verification over l2pt with traffic",
                "Procedure": "The test for verifying Layer 2 Protocol Tunneling (L2PT) over Cisco Discovery Protocol (CDP) with traffic involves verifying the basic functionality of L2PT. This test verifies that L2PT is working correctly and as expected. The test configuration includes OSPF, L2PT, LDP, and CDP.\n\nThis test is triggered by the presence of L2PT on a network.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT: Verify ENCAP/DECAP on LPTS punt with traffic . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Add remove l2pt with cdp with traffic",
                "Procedure": "The configuration for this test includes OSPF, L2PT, LDP, and CDP. The goal is to verify that Layer 2 Protocol Tunneling (L2PT) works properly over CDP with traffic present after the removal and re-addition of L2pt settings.\n\nThis test is triggered by verification of basic L2PT functionality.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT: Verify ENCAP/DECAP on LPTS punt with traffic . verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle basic verification",
                "Procedure": "Verification of fundamental OSPF, LDP, and CDP functionality over a bundle is performed in this test. The basic operations of these protocols are verified on the bundle. This test verifies basic OSPF, ldp, cdp verification over bundle - Verify OSPF - Verify MPLS LDP - Verify CDP Configuration: OSPF, L2PT, LDP, CDP. \n\nThis test is triggered by a configuration that includes OSPF, L2PT, LDP, and CDP protocols.",
                "Pass/Fail Criteria": "Ospf neighbor verification is performed.\nMpls ldp verification is performed.\nCdp neighbor verification is performed.\nOSPF: Verify OSPF session is established verification is performed.\nMPLS LDP: Verify MPLS session is established verification is performed.\nCDP: Verify CDP session is established over bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt bundle verification",
                "Procedure": "The test for verifying a bundle of Layer 2 Packet Transport (L2PT) over Cisco Discovery Protocol (CDP) is triggered by when the bundle's configuration includes OSPF, L2PT, LDP, and CDP. \n\nTrigger sentence: This test verifies bundle L2PT over cdp when the bundle's configuration includes OSPF, L2PT, LDP, and CDP.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT: Verify ENCAP/DECAP on LPTS punt over bundle. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Bundle process triggers cdp",
                "Procedure": "When the process bundle is restarted or crashes, it should restart automatically and traffic should continue to flow. The test also verifies that interfaces statistics are accurate and configurations for CDP (Cisco Discovery Protocol) and L2PT (Layer 2 Protocol Tunneling) are in place.\n\nThis test is triggered by restarting or crashing the processes involved in the process bundle.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"l2pt_ap_base.process_names('test_process_triggers/processes', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT\" verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp basic verification",
                "Procedure": "The test for basic MSTP verification checks the operation of OSPF, LDP, and MSTP protocols over Layer 2 Path Trunking. It verifies that these protocols are working as expected in a bundle environment by confirming the correct operation of OSPF, MPLS LDP, and MSTP.\n\nThis test is triggered by verifying OSPF, LDP, mstp verification over l2pt, which involves checking the configuration for OSPF, L2PT, LDP, and MSTP.",
                "Pass/Fail Criteria": "Ospf neighbor verification is performed.\nMpls ldp verification is performed.\nOSPF: Verify OSPF session is established verification is performed.\nMPLS LDP: Verify MPLS session is established verification is performed.\nMSTP: Verify MSTP session is established over bundle verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Mstp l2pt verification",
                "Procedure": "The test for MSTP L2PT verification is triggered by the configuration of OSPF, L2PT, LDP, and MSTP. It verifies that L2PT verification works as expected.\n\nThis test is triggered by the configuration of OSPF, L2PT, LDP, and mstp.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT: Verify ENCAP/DECAP on LPTS punt. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt verification mstp with traffic",
                "Procedure": "The test for L2PT verification with traffic over MSTP is used to check the basic functionality of this feature. It involves verifying the configuration which includes OSPF, L2PT, LDP, and MSTP.\n\nThis test is triggered by a request to verify the basic L2PT verification process in an environment where traffic is being transmitted over MSTP.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT: Verify ENCAP/DECAP on LPTS punt. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Pvrst verification",
                "Procedure": "Verification of OSPF, LDP, and PVRST functionality occurs through a series of tests that verify basic operations. These tests include verifying the operation of OSPF, MPLS LDP, and PVRST protocols over the PVRST protocol. This test is triggered by configuration changes involving OSPF, L2PT, LDP, and PVRST.",
                "Pass/Fail Criteria": "Ospf neighbor verification is performed.\nMpls ldp verification is performed.\nOSPF: Verify OSPF session is established verification is performed.\nMPLS LDP: Verify MPLS session is established verification is performed.\nPVRST: Verify PVRST session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt verification pvrst",
                "Procedure": "L2PT verification is tested over CDP. The test verifies the bundle's L2PT functionality by verifying L2PT. The configuration used in this test includes OSPF, L2PT, LDP, and CDP.\n\nThis test is triggered by verifying that a device successfully sends and receives L2PT data packets over a CDP connection.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT: Verify ENCAP/DECAP on LPTS punt. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt verification pvrst with traffic",
                "Procedure": "Basic L2PT verification is tested by verifying the configuration of OSPF, L2PT, LDP, and CDP protocols.\n\nThis test is triggered by verifying the presence of traffic.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT: Verify ENCAP/DECAP on LPTS punt. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Process triggers pvrst",
                "Procedure": "When the system crashes or is restarted, it's essential to verify that the processes are properly restarted and that network traffic resumes. This involves checking interface statistics to ensure they're functioning correctly. The test process also includes verifying the configuration of PVRST (PortFast, BackboneFast, Unidirectional Link Detection) and L2PT (Link Layer Protocol Tunneling), as specified in the system's Configuration.\n\nThis test is triggered by a system restart or crash event.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"l2pt_ap_base.process_names('test_process_triggers/processes', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nL2PT\" verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2cp lldp vpws verification",
                "Procedure": "The test for verifying LLDP verification over L2CP and VPWS checks the operation of the LLDP protocol. It consists of three main components, with the first one configuring LLDP. The second component triggers a test to verify LLDP protocol functionality on an L2CP network segment. This test is triggered by a specific event occurring in a VPWS environment that causes the LLDP packets to be transmitted over both L2CP and VPWS networks.",
                "Pass/Fail Criteria": "Lldp neighbor verification is performed.\nLldp punt verification is performed.\nLLDP: Verify LLDP session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt lldp vpws verification phymain",
                "Procedure": "The test verifies the LLDP verification over L2PT and VPWS on a physical main interface. It checks that the LLDP protocol is functioning correctly.\n\nThis test is triggered by verifying LLDP configuration including setting up the LLDP protocol for testing.",
                "Pass/Fail Criteria": "Lldp neighbor verification is performed.\nLldp punt verification is performed.\nLLDP: Verify LLDP session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt lldp vpws verification physub",
                "Procedure": "The test for verifying LLDP (Link Layer Discovery Protocol) verification over layer two point-to-point (L2pt) and Virtual Private Wire Service (VPWS) is performed on a physical subinterface. It checks the LLDP protocol configuration.\n\nThis test verifies that the LLDP protocol functions correctly when used in conjunction with L2pt and VPWS, and this test is triggered by the LLDP configuration.",
                "Pass/Fail Criteria": "Neighbors verification is performed.\nLLDP: Verify LLDP session is established over a subinterface and after encap updates verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt udld vpws phymain verification",
                "Procedure": "The test for verifying Universal Doubler Detection (UDLD) protocol is run over Layer-2 point-to-point (L2pt) and Virtual Private Wire Service (VPWS) on the primary interface. The test confirms that the UDLD protocol is functioning correctly over L2pt, with UDLD configuration in place.\n\nThis test is triggered by the need to confirm that UDLD protocol functionality is accurate when set up for use over L2pt.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nUDLD: Verify UDLD session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt udld vpws physub verification",
                "Procedure": "The test verifies UDLD protocol over L2PT on an untagged EVC, checking UDLD verification over both L2PT and VPWS. It involves verifying the UDLD protocol operating over L2PT. This test is triggered by a configuration of UDLD.",
                "Pass/Fail Criteria": "Ethernet udld interfaces verification is performed.\nUDLD: Verify UDLD session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2cp eoam vpws verification",
                "Procedure": "The test verifies the End-to-End OAM (Operations, Administration, and Maintenance) functionality over Layer 2 Circuit Protocol (L2CP). It checks if the OAM protocol is correctly configured. \n\nThis test is triggered by a configuration that includes an OAM setup for L2CP.",
                "Pass/Fail Criteria": "Oam punt verification is performed.\nOam discovery interface verification is performed.\nOam discovery brief verification is performed.\nOAM: Verify OAM session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt eoam vpws verification",
                "Procedure": "The test_l2pt_eoam_vpws_verification test is designed to verify the end-to-end OAM (Operations, Administration, and Maintenance) functionality over a Layer 2 Path Tunnel (L2PT). It specifically checks the OAM protocol for L2PT. The configuration involves setting up an OAM environment.\n\nThis test is triggered by verifying that an EOAM (End-to-End Operations, Administration, and Management) verification mechanism exists on both ends of an L2PT connection.",
                "Pass/Fail Criteria": "Oam punt verification is performed.\nOam discovery interface verification is performed.\nOam discovery brief verification is performed.\nOAM: Verify OAM session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2cp lldp vpls verification",
                "Procedure": "The test for verifying LLDP over L2CP with VPLS includes a reload trigger. It tests the LLDP protocol with VPLS in place. The configuration for this test is set up to include LLDP.\n\nThis test is triggered by including a reload in its procedure.",
                "Pass/Fail Criteria": "Lldp neighbor verification is performed.\nLldp punt verification is performed.\nLLDP: Verify LLDP session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2cp eoam vpls verification",
                "Procedure": "The L2CP with VPLS EOAM Verification test is used to verify the operation of the OAM protocol over L2CP connections using VPLS. This configuration utilizes OAM to ensure the proper functioning of data transmission between devices.\n\nThis test verifies that the EAOM verification functionality triggers when using L2CP with VPLS and OAM is enabled.",
                "Pass/Fail Criteria": "Oam punt verification is performed.\nOam discovery interface verification is performed.\nOam discovery brief verification is performed.\nOAM: Verify OAM session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt lldp vpls verification",
                "Procedure": "The test for LLDP verification over L2pt with VPLS and reload trigger is used to verify the LLDP protocol with Virtual Private LAN Service (VPLS) configuration. It checks if LLDP is functioning correctly in a network setup where Layer 2 point-to-point connections are established over Virtual Private LAN Services.\n\nThis test is triggered by the user's command to reload after configuring LLDP on a VPLS network.",
                "Pass/Fail Criteria": "Lldp neighbor verification is performed.\nLldp punt verification is performed.\nLLDP: Verify LLDP session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt eoam vpls verification",
                "Procedure": "The test is designed to verify the EAOM verification process in conjunction with VPLS and Layer 2 Protocol Tunneling. It checks the operation of the OAM protocol specifically for Layer 2 Circuit Protocol with VPLS, a configuration that includes OAM.\n\nThis test is triggered by the presence of an L2CP enabled with OAM and running on top of a VPLS infrastructure.",
                "Pass/Fail Criteria": "Oam punt verification is performed.\nOam discovery interface verification is performed.\nOam discovery brief verification is performed.\nOAM: Verify OAM session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2cp lldp bd verification",
                "Procedure": "The test verifies the operation of LLDP in a network with Bridge-Domain, BVI, and Split Horizon configurations over Layer 2 Control Plane (L2CP). The test environment includes LLDP enabled.\n\nThis test is triggered by configuration of LLDP.",
                "Pass/Fail Criteria": "Neighbors verification is performed.\nLLDP: Verify LLDP session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt lldp bd verification",
                "Procedure": "LLDP verification is tested over L2PT with Bridge-Domain, BVI, and Split Horizon configured. The test verifies the LLDP protocol with Bridge-Domain forwarding enabled. This test is triggered by a configuration of LLDP and Layer 2 Protocol Tunneling (L2PT).",
                "Pass/Fail Criteria": "Neighbors verification is performed.\nL2pt punt verification is performed.\nLLDP: Verify LLDP session is established verification is performed.\nL2PT: Verify L2PT punt is happening for ctrl protocols verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt cdp bd verification",
                "Procedure": "The CDP verification over L2PT with Bridge-Domain and Split Horizon configured involves verifying the operation of the CDP protocol when using Bridge-Domain forwarding. This test is triggered by a configuration that includes CDP, L2PT.\n\nNote: I removed the unnecessary \"Test\" prefix and rephrased some words to make it sound more natural.",
                "Pass/Fail Criteria": "Cdp neighbor verification is performed.\nL2pt punt verification is performed.\nCDP: Verify CDP session is established verification is performed.\nL2PT: Verify L2PT punt for ctrl protocols verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2cp cdp bd verification",
                "Procedure": "CDP protocol is verified with Bridge-Domain Forwarding in a configuration that includes the features of L2CP, Bridge-Domain, and Split Horizon. The test checks for successful CDP verification over L2CP, taking into account the forwarding behavior provided by Bridge-Domain, as well as the effects of Split Horizon on this process. This test is triggered by CDP.",
                "Pass/Fail Criteria": "Cdp neighbor verification is performed.\nCDP: Verify CDP session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt scale verification",
                "Procedure": "Verification is performed to ensure that scaled L2PT sessions are successfully established across a VPWS network. The test involves verifying LLDP and L2PT scaling configurations.\n\nThis test is triggered by the verification of scaled L2PT sessions over VPWS configuration with both LLDP and L2PT scaling enabled.",
                "Pass/Fail Criteria": "Lldp neighbors verification is performed.\nSpp node counters verification is performed.\nLLDP: Verify scaled LLDP sessions are established verification is performed.\nL2PT: Verify L2PT punt at a higher rate verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt scale commit replace",
                "Procedure": "The test for verifying a commit replace trigger in a scaled L2PT setup over VPWS involves configuring an L2PT scale and LLDP scale. \n\nThis test is triggered by the configuration of an L2PT scale and LLDP scale within a VPWS setup.",
                "Pass/Fail Criteria": "Lldp neighbors verification is performed.\nSpp node counters verification is performed.\nLLDP: Verify sclaed LLDP session is established verification is performed.\nL2PT: Verify higher L2PT punt rate for scaled sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt span srcintf",
                "Procedure": "This paragraph describes a series of tests for verifying the functionality of LLDP (Link Layer Discovery Protocol) and L2PT (Layer 2 Point-to-Point) on a device with multiple interfaces, including a physical subinterface that serves as a SPAN source interface. The test setup involves configuring LLDP, L2PT, and SPAN protocols to verify their interaction and operation over the specified interfaces.\n\nThis test is triggered by verifying LLDP protocol over L2PT and L2PT enabled interface as SPAN source interface with configurations of LLDP, L2PT, and SPAN.",
                "Pass/Fail Criteria": "Span status verification is performed.\nNeighbors verification is performed.\nL2pt punt verification is performed.\nLLDP: Verify LLDP session is established over L2PT on subintf verification is performed.\nSPAN: Verify Rx and Tx SPAN works on L2PT enabled interface verification is performed.\nL2PT: Verify L2PT punt for the ctrl packets verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt mtu",
                "Procedure": "The L2 point-to-point (L2pt) test for verifying the Link Layer Discovery Protocol (LLDP) over modified Layer 2 Maximum Transmission Unit (MTU) settings is a functional verification process. It confirms that LLDP functions as expected when the L2 MTU has been altered.\n\nThis test is triggered by the need to verify LLDP protocol functionality after modifying L2 MTU settings in a network configuration with LLDP enabled.",
                "Pass/Fail Criteria": "Neighbors verification is performed.\nL2pt punt verification is performed.\nLLDP: Verify LLDP session is established over L2PT verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt evpn lldp physcial sub",
                "Procedure": "LLDP verification is tested over a physical sub-L2PT network that has EVPN configured. The test checks the operation of the LLDP protocol in conjunction with EVPN. LLDP, L2PT, and EVPN are all enabled as part of this test.\n\nThis test is triggered by verifying LLDP protocol functionality when using EVPN and L2PT in a physical sub-L2PT network configuration.",
                "Pass/Fail Criteria": "Neighbors verification is performed.\nL2pt punt verification is performed.\nLLDP: Verify LLDP session is established verification is performed.\nL2PT: Verify L2PT punt is happening for ctrl protocols verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt evpn cdp physical sub",
                "Procedure": "The CDP verification over physical sub L2PT with EVPN configuration is verified. This test is triggered by verifying the CDP protocol with Bridge-Domain Forwarding, using a configuration of CDP, L2PT, and EVPN.",
                "Pass/Fail Criteria": "Cdp neighbor verification is performed.\nL2pt punt verification is performed.\nCDP: Verify CDP session is established verification is performed.\nL2PT: Verify L2PT punt for ctrl protocols verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt evpn eoam physical main",
                "Procedure": "The test is designed to verify EAOM verification on physical main EVPN and L2PT. The configuration for this test includes OAM, L2PT, and EVPN.\n\nThis test is triggered by the user selecting a physical interface as the EVPN main interface, while enabling OAM and configuring an L2PT endpoint.",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nOam discovery interface verification is performed.\nOam discovery brief verification is performed.\nOAM: Verify OAM session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt evpn cdp bundle",
                "Procedure": "The test is designed to verify end-to-end OAM verification on a bundle interface using EVPN and L2PT. This test is triggered by the configuration of OAM, L2PT, and EVPN.\n\nRewritten trigger sentence:\n\nThis test is triggered by the configuration of OAM, L2PT, and EVPN.",
                "Pass/Fail Criteria": "Cdp neighbor verification is performed.\nL2pt punt verification is performed.\nOAM: Verify OAM session is established verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "L2pt evpn bundle process triggers cdp",
                "Procedure": "The test for testing bundle process triggers in CDP, EVPN, and L2PT restarts or crashes the processes involved to verify how they respond. It checks several key things, including verifying interface statistics. The configuration includes settings for CDP, L2PT, and EVPN. This test is triggered by verifying the configuration of CDP, L2PT, and EVPN.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nproc_action, proc_name: \"l2pt_ap_base.process_names('test_process_triggers/processes', Zap(test_input_file=CafyLog.test_input_file, topo_file=CafyLog.topology_file))\"",
                "Pass/Fail Criteria": "L2pt punt verification is performed.\nCdp neighbor verification is performed.\nL2PT verification is performed.\ncdp neighbor after process restart/crash verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "pm_thresholds_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Upmep stateless pm thres max val dmm",
                "Procedure": "To verify Ethernet SLA (Service Level Agreement) stateless thresholds and actions, you use a Delay Measurement Message (DMM). The one-way-delay-sd, one-way-delay-ds, one-way-jitter-sd, one-way-jitter-ds, round-trip-jitter, and round-trip-delay metrics are covered. To perform the test: configure an Ethernet SLA profile globally with specific thresholds and actions using a max-value; apply this configuration to interfaces; verify that configured parameters display correctly using the \"show ethernet sla operations\" CLI command; check for Syslog generation when the specified thresholds are breached; then unconfigure the Ethernet SLA from both the interface and globally.\n\nThis test is triggered by a Delay Measurement Message (DMM) covering one-way-delay-sd, one-way-delay-ds, one-way-jitter-sd, one-way-jitter-ds, round-trip-jitter, and round-trip-delay metrics.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateful pm thres max val dmm",
                "Procedure": "Ethernet SLA stateful thresholds and actions can be verified using Delay Measurement Messages (DMM) for one-way delay, jitter, and round-trip metrics. To perform the verification, follow these steps: Configure an Ethernet SLA profile globally with stateful thresholds and actions that trigger when the maximum value is exceeded; apply this configuration under each interface; verify that the configured parameters are displayed correctly using the \"show ethernet sla operations\" CLI command; check that a syslog message is generated when the threshold is breached; confirm that the breached information is shown accurately in the \"show ethernet sla statistics\" CLI display. Also, test with high thresholds values and ensure the system clears the syslog when they are exceeded, then unconfigure the Ethernet SLA from both interface and global levels. This test is triggered by the requirement to configure Ethernet SLA with stateful thresholds using DMM's maximum value at both the global and interface levels.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateless pm thres max val lbm",
                "Procedure": "Ethernet SLA configurations can be tested for various parameters, including round-trip jitter and delay, using a Loopback Message (LBM). This test is triggered by verifying the generation of a syslog message when specific threshold values are exceeded in an Ethernet SLA profile that has been configured at both the global and interface levels.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateful pm thres max val lbm",
                "Procedure": "To test the PM thresholds, we need to configure stateful maximum values with Loopback Message (LBM) for round-trip jitter and delay. This test is triggered by verifying that Ethernet SLA stateful thresholds and actions are correctly configured with LBM, covering the following parameters: round-trip jitter and round-trip delay.\n\nRewritten trigger sentence:\nThis test is triggered by configuring a Loopback Message (LBM) to verify that Ethernet SLA stateful thresholds and actions are set up correctly.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateless pm thres mean val dmm",
                "Procedure": "To configure Ethernet SLA with stateless thresholds, a profile must be set up globally with specified delay and jitter values, along with a configured action when these thresholds are breached. The steps to follow include configuring the profile with mean-value using Delay Measurement Message (DMM) coving one-way-delay-sd, one-way-delay-ds, one-way-jitter-sd, one-way-jitter-ds, round-trip-jitter, and round-trip-delay values; applying the configuration under specific interfaces; verifying that the configured parameters are displayed correctly with a show ethernet sla operations CLI command; verifying that a Syslog is generated when the configured SLA thresholds are breached; and finally unconfiguring the Ethernet SLA from both the interface and globally. This test is triggered by configuring an Ethernet SLA profile with stateless thresholds using DMM mean-value and interface-level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_mean_val_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateful pm thres mean val dmm",
                "Procedure": "When configuring Ethernet SLA (Service Level Agreement) with stateful thresholds, the process involves several steps. The first step is to configure an Ethernet SLA profile globally with stateful thresholds and actions using the mean value. Next, apply this configuration under each interface. After that, verify that the configured parameters are displayed correctly in the show ethernet sla operations CLI output. It's also essential to ensure that a syslog message is generated when the configured SLA thresholds are breached. Furthermore, check that the Ethernet SLA breach information displays correctly under the show ethernet sla statistics CLI. Additionally, try setting high threshold values and verify that a \"threshold clear\" syslog is generated. Finally, unconfigure the Ethernet SLA from both the interface and globally.\n\nThis test is triggered by configuring an Ethernet SLA with stateful thresholds using DMM's mean-value and interface-level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_mean_val_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateless pm thres mean val lbm",
                "Procedure": "The Ethernet SLA configuration involves setting up a profile with stateless thresholds and actions, which can be tested using the Loopback Message (LBM) to measure round-trip jitter and delay. To configure this setup, you need to follow these steps: Configure an Ethernet SLA profile globally with the specified thresholds and action settings; apply this configuration to specific interfaces along with their respective threshold values set as mean-value; verify that the configured parameters are correctly displayed using the \"show ethernet sla operations\" CLI command; ensure that Syslog is generated when the thresholds are breached; finally, unconfigure the Ethernet SLA from both the interface and globally. This test is triggered by configuring an Ethernet SLA with stateless thresholds using LBM with mean-value at the interface level.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateful pm thres mean val lbm",
                "Procedure": "Ethernet SLA with stateful thresholds uses the Loopback Message (LBM) to test performance metrics such as round-trip jitter and round-trip delay.\n\nThis test is triggered by a configured SLA profile that includes specific thresholds for these metrics. The configuration involves setting global Ethernet SLA parameters, applying them to individual interfaces, verifying correct display of these settings via the CLI, checking for Syslog generation when thresholds are breached, ensuring proper display of breach information under 'show ethernet sla statistics', testing high threshold values with corresponding syslog, and finally unconfiguring the SLA.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateless pm thres upmep negative max val dmm",
                "Procedure": "When verifying Ethernet SLA stateful thresholds and actions, configure the profile globally with stateful thresholds and action set to max-value using the Delay Measurement Message (DMM) round-trip-delay. This test is triggered by performing a series of steps: configuring ethernet sla under interfaces, verifying configured parameters with show commands, generating syslog messages when thresholds are breached, displaying breached information in show statistics CLI, removing and rolling back sla config, cfm from interface, shutting/unshutting interfaces, re-verifying configured parameters after trigger, and generating threshold clear syslog.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nThreshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nCfm peer meps verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateful pm thres upmep negative max val dmm",
                "Procedure": "The test for PM thresholds using stateful maximum values with Delay Measurement Message (DMM) covers one-way-delay-sd, one-way-delay-ds, one-way-jitter-sd, one-way-jitter-ds, round-trip-jitter, and round-trip-delay. The configuration involves setting up an Ethernet SLA profile globally with stateful thresholds and action based on maximum value, applying this to interfaces, verifying display of configured parameters in the \"show ethernet sla operations\" CLI command, and checking that syslog messages are generated when thresholds are breached. Additionally, the test includes verifying correct display of Ethernet SLA breach information after triggering a rollback of the configuration, configuring high threshold values, and verifying that EFD status is cleared.\n\nThis test is triggered by performing the steps involved in removing, rolling back, and re-applying the SLA configurations on interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nThreshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nCfm peer meps verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateless pm thres upmep proc trigger max val dmm",
                "Procedure": "To perform Ethernet SLA testing, configure an SLA profile globally with stateful thresholds and actions using the maximum value setting, then apply this configuration under the relevant interfaces. Next, verify that the configured parameters are displayed correctly via the show ethernet sla operations CLI command, check for Syslog generation when threshold breaches occur, and confirm that breached information is shown under the show ethernet sla statistics CLI command. Following these steps, restart the system trigger process. Once restarted, re-check the SLA configuration to ensure it remains correct via the show ethernet sla operations CLI command, and verify that Syslog continues to be generated at threshold breaches. Additionally, test with high thresholds values to confirm that a Threshold clear syslog is generated when these are breached. Finally, unconfigure Ethernet SLA from both interfaces and globally.\n\nThis test is triggered by restarting the system's trigger process.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"PmApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nStateless cleared syslog generation verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateful pm thres upmep proc trigger max val dmm",
                "Procedure": "Ethernet SLA profiles with stateful thresholds and actions, including maximum values, are configured globally and applied to specific interfaces using Delay Measurement Message (DMM) round-trip-delay. The configuration is verified through the show ethernet sla operations CLI command, which displays the configured parameters correctly. System logs are generated when the configured SLA thresholds are exceeded. After a process restart, the same verification steps confirm that the configuration remains intact and system logs continue to be generated as expected when thresholds are breached. Additionally, high threshold values are tested and verified to ensure threshold-clear syslog messages are generated accordingly. Finally, the Ethernet SLA configuration is removed from both interface and global levels. This test is triggered by performing a process restart.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"PmApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla statistics interface verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nStateless cleared syslog generation verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateless pm thres rpfo max val dmm",
                "Procedure": "Ethernet SLA stateful thresholds and actions can be verified using Delay Measurement Messages (DMM) for round-trip delay measurement. This test is triggered by performing a Resource Pool Failure Operation (RPFO). The steps to verify the configuration include configuring an Ethernet SLA profile globally with stateful thresholds and action, applying the configuration under interfaces, verifying displayed parameters, checking for Syslog generation when configured thresholds are breached, displaying breached information in show Ethernet SLA statistics CLI, repeating these verification steps after the trigger, setting high threshold values and verifying a \"threshold clear\" syslog is generated, and finally unconfiguring Ethernet SLA from interfaces and globally.",
                "Pass/Fail Criteria": "Ha verification is performed.\nThreshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nCfm peer meps verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateful pm thres rpfo max val dmm",
                "Procedure": "To verify Ethernet SLA stateful thresholds and action, the following steps are performed. The Ethernet SLA profile is configured globally with stateful thresholds and action using a maximum value of DMM round-trip-delay, and then applied under an interface. The configured parameters are verified to be displayed correctly in the show ethernet sla operations CLI output. Additionally, verification is done to confirm that syslog messages are generated when the configured SLA thresholds are breached, and that the Ethernet SLA breach information is shown properly under the show ethernet sla statistics CLI output. After performing the trigger - RPFO, the same verifications as before are performed again. Finally, high threshold values are set, and it's verified that a threshold clear syslog message is generated when they're cleared. Once done, the Ethernet SLA configuration is unconfigured from both the interface and globally. This test is triggered by the Remote Performance Fault (RPFO) event.",
                "Pass/Fail Criteria": "Ha verification is performed.\nThreshold log verification is performed.\nCfm peer meps verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateless pm thres sample count dmm",
                "Procedure": "Ethernet SLA profiles can be configured globally to test various metrics, including one-way-delay-sd, one-way-delay-ds, round-trip-jitter, round-trip-delay, one-way-jitter-sd, and one-way-jitter-ds. This test is triggered by configuring an Ethernet SLA profile with stateless thresholds and actions, applying it to an interface with specific threshold values as the mean value, and verifying that the configured parameters are displayed correctly using the 'show ethernet sla operations' CLI command. Note that in this configuration, the maximum delay is 0.030ms, but even with minimal settings, the sample count can be aggregated into bins of width 1ms or more, with a minimum sample count of 2 and bin count of 2, which prevents the SLA actions from being triggered.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_measures\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep stateful pm thres sample count dmm",
                "Procedure": "The PM thresholds are used to configure the DMM (Delay Measurement Method) over upmep, which involves verifying Ethernet SLA (Service-Level Agreement) stateful thresholds and actions. The configuration includes setting one-way-delay-sd, one-way-delay-ds, round-trip-jitter, round-trip-delay, one-way-jitter-sd, and one-way-jitter-ds values for the DMM. To verify this configuration, follow these steps: configure Ethernet SLA profiles globally with stateless thresholds and actions, apply the configuration to interfaces with threshold values as mean-value, and check that the configured parameters are displayed correctly using the show ethernet sla operations CLI command.\n\nThis test is triggered by verifying that even with a minimal configuration, the DMM can aggregate bins with a width of 1 ms and sample count set to minimum (2) and bin count also set to 2.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_measures\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres max val dmm",
                "Procedure": "To test the stateless thresholds for a Delay Measurement Message (DMM) on an Ethernet connection, you need to configure the DMM with maximum values in its operation parameters. This test is triggered by configuring an Ethernet Service Level Agreements (SLA) profile globally with stateful thresholds and actions, applying it under an interface, verifying that the configured parameters are displayed correctly, and checking that a syslog is generated when the SLA thresholds are breached. The test also checks that breached information is displayed correctly in the show ethernet sla statistics CLI, applies EFD actions, configures high threshold values to generate a Threshold clear syslog, clears the EFD status, and finally unconfigures the Ethernet SLA from both the interface and globally.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_dmm_measures\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres max val dmm",
                "Procedure": "To test the stateful thresholds for Ethernet SLA with Delay Measurement Message (DMM), the following configuration is required to verify the correct operation of one-way-delay-sd, one-way-delay-ds, one-way-jitter-sd, one-way-jitter-ds, round-trip-jitter, and round-trip-delay measurements. This test is triggered by a threshold breach that generates an EFD action, which can be verified with the \"show efd interface\" command.\n\n(Note: I rewrote the trigger sentence as described)\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_dmm_measures\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres max val lbm",
                "Procedure": "To verify Ethernet SLA stateless thresholds and action using Loopback Message (LBM), covering round-trip jitter and round-trip delay, the following steps are performed. First, configure an Ethernet SLA profile globally with stateless thresholds and action. Next, apply the configuration with maximum value to the interface level. Then, verify that the configured parameters display correctly using the show ethernet sla operations command-line interface (CLI). After that, confirm that a syslog message is generated when the SLA thresholds are breached. Finally, unconfigure Ethernet SLA from both the interface and globally.\n\nThis test is triggered by configuring an Ethernet SLA profile with stateless thresholds and action covering round-trip jitter and round-trip delay, using Loopback Message (LBM), maximum value, and interface-level SLA configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres max val lbm",
                "Procedure": "Here is the rewritten paragraph:\n\nThe configuration for Ethernet SLA with stateful thresholds involves several steps. First, configure an Ethernet SLA profile globally with the stateful thresholds and action, then apply this configuration to specific interfaces using a maximum value threshold. Next, verify that the configured parameters are displayed correctly using the \"show ethernet sla operations\" CLI command. After that, check if a syslog message is generated when the configured SLA thresholds are breached. The following steps involve verifying that Ethernet SLA breach information is displayed correctly under the \"show ethernet sla statistics\" CLI command, and also checking to see if an EFD action has been applied using the \"show efd interface\" CLI command. Additionally, configure high thresholds and verify that a threshold clear syslog message is generated. Then, check if the EFD status is cleared by displaying the output of the \"show efd interface\" CLI command. Finally, unconfigure Ethernet SLA from the interface and globally.\n\nThis test is triggered by configuring an Ethernet SLA with stateful thresholds, including Loopback Messages (LBM) covering round-trip-jitter and round-trip-delay.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nEfd interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres max val slm",
                "Procedure": "To configure and verify Ethernet SLA (Service-Level Agreement) functionality, several steps must be performed. First, an Ethernet SLA profile is configured globally with specific stateless thresholds and actions, using a Synthetic Loss Measurement Message that covers one-way loss in both forward (sd) and reverse (ds) directions. The profile's configuration is then applied to interfaces at the network device, where the thresholds are set as the maximum allowed value. It is also necessary to verify that the configured parameters display correctly when checked with the 'show ethernet sla operations' command-line interface command. Additionally, the system must be tested to ensure it generates a syslog message when the defined SLA thresholds are exceeded. Finally, the Ethernet SLA configuration must be removed from both the interfaces and the global level.\n\nThis test is triggered by verifying that syslog messages are generated according to the specified thresholds for one-way loss in forward (sd) and reverse (ds) directions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.slm_measure_types\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres max val slm",
                "Procedure": "Ethernet sla with stateful thresholds, including LBM (Link Bundle Member) and a maximum value, can be configured at both the global and interface levels. The process involves configuring an ethernet sla profile globally with specific stateful thresholds and actions, then applying this configuration to an interface with a maximum threshold value. Next, verify that the configured parameters are correctly displayed using the show ethernet sla operations CLI command. Also check that a syslog message is generated when the sla thresholds are breached, and that the breached information is properly displayed in the show ethernet sla statistics CLI output. The Ethernet Flow Discovery (EFD) action should be applied as expected according to the configuration. Furthermore, test the scenario with high thresholds, verifying that a threshold clear syslog is generated and that the EFD status is cleared accordingly. Finally, unconfigure the ethernet sla from both the interface and globally. This test is triggered by an Ethernet SLM (Synthetic Loss Measurement) covering one-way loss measurement.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.slm_measure_types\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nEfd interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres mean val slm",
                "Procedure": "When verifying Ethernet SLA (Service Level Agreement) settings, measure one-way loss in both the forward and reverse directions using Synthetic Los measurement Message (LSM). This test is triggered by the need to configure and verify Ethernet SLA stateless thresholds and actions for specific interfaces. To set up this verification process, follow these steps: configure an Ethernet SLA profile globally with stateless thresholds and actions, then apply this configuration to a specified interface using a maximum value threshold. Next, use the show ethernet sla operations command in the CLI (Command Line Interface) to verify that all configured parameters are displayed correctly. Additionally, check that Syslog messages are generated when the configured SLA thresholds are exceeded. Finally, unconfigure Ethernet SLA settings from both the interface and globally.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.slm_measure_types\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres mean val slm",
                "Procedure": "To configure and test the Ethernet SLA feature, you first need to set up a profile with stateful thresholds and actions using Synthetic Loss Measurement (SLM) on one-way loss. This involves configuring the SLA profile globally and applying it to specific interfaces, then verifying that the parameters are displayed correctly in the CLI and that syslog messages are generated when the thresholds are breached. You should also verify that EFD actions are taken as expected and that threshold clear syslog is generated for high thresholds. Finally, unconfigure the SLA from the interface and globally to reset the configuration.\n\nThis test is triggered by configuring an Ethernet SLA profile with stateful thresholds using SLM and max-value, applying it at the interface level, and verifying its parameters are displayed correctly in the CLI and that syslog messages are generated when the thresholds are breached.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.slm_measure_types\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nEfd interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres mean val dmm",
                "Procedure": "Ethernet SLA stateless thresholds can be tested using Delay Measurement Message (DMM) coving one-way-delay-sd, one-way-delay-ds, one-way-jitter-sd, one-way-jitter-ds, round-trip-jitter, and round-trip-delay metrics. To perform the test, configure an Ethernet SLA profile globally with stateless thresholds and action with mean-value, apply this configuration under each interface, verify that the configured parameters are displayed correctly using the 'show ethernet sla operations' CLI command, check that a Syslog message is generated when the configured SLA thresholds are breached, and finally unconfigure the Ethernet SLA from both the interface and globally.\n\nThis test is triggered by setting up an Ethernet SLA profile with stateless thresholds and action with mean-value.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_mean_val_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres mean val dmm",
                "Procedure": "The configuration of Ethernet SLA with stateful thresholds involves several steps, including configuring the profile globally with mean-value DMM and applying it under interfaces, verifying that the configured parameters are displayed correctly, generating Syslog when thresholds are breached, triggering EFD, displaying breached information in statistics CLI, clearing threshold syslogs and EFD status, and finally unconfiguring SLA from interface and globally. This test is triggered by verifying that an Ethernet SLA with stateful thresholds is properly configured on a device.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_mean_val_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEfd interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres mean val lbm",
                "Procedure": "To configure and verify the Ethernet SLA (Service Level Agreement) with stateless thresholds, first create an Ethernet SLA profile globally with the desired stateless thresholds and action. Then apply this configuration to a specific interface by setting the threshold value as the mean value. Next, use the show ethernet sla operations command-line interface to confirm that the parameters have been correctly displayed. When the configured SLA thresholds are exceeded, verify that syslog is generated accordingly. Finally, remove the Ethernet SLA from both the interface and globally.\n\nThis test is triggered by verifying that Syslog is generated when the configured SLA thresholds are breached, using an Ethernet SLA with stateless thresholds, Loopback Message (LBM), and mean-value, at both interface and global configuration levels.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres mean val lbm",
                "Procedure": "Ethernet SLA configurations with stateful thresholds can be tested by following these steps. First, an Ethernet SLA profile is configured globally with the desired stateful thresholds and action. Then, this configuration is applied to specific interfaces, where it uses a \"mean value\" under its parameters. To verify that everything is set up correctly, administrators should check the display of configured operations using the CLI command \"show ethernet sla operations.\" They must also confirm that syslog messages are generated when the specified thresholds are exceeded and that the EFD action is triggered accordingly. Furthermore, they need to ensure that breached information is properly displayed on the show ethernet sla statistics CLI page. Additionally, a higher threshold value should be configured to test for \"threshold clear\" syslog generation. After verifying these conditions, the administrator must unconfigure the Ethernet SLA from both the interface and globally. This test is triggered by performing round-trip-jitter and round-trip-delay measurements using the Loopback Message (LBM).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nEfd interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres sample count lbm",
                "Procedure": "The procedure to configure and test Ethernet SLA with stateless thresholds involves verifying the functionality of loopback messages in a network. To do this, one must first configure an Ethernet SLA profile globally with specified stateless thresholds and actions, then apply the configuration to an interface while setting threshold values as mean values. After that, one should verify that the configured parameters are displayed correctly using the show ethernet sla operations command line interface. The test also includes verifying that a syslog message is generated when the configured SLA thresholds are breached. Additionally, high threshold values can be set and their corresponding clear syslog messages verified. Finally, Ethernet SLA should be unconfigured from both the interface and globally.\n\nThis test is triggered by configuring an Ethernet SLA with stateless thresholds and a sample count.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres sample count lbm",
                "Procedure": "To test the stateful Ethernet SLA (Service Level Agreements) configuration, verify that the round-trip jitter and round-trip delay thresholds are set correctly in a Loopback Message (LBM). This test is triggered by verifying that a syslog message is generated when the configured SLA thresholds are breached. The verification process involves configuring an Ethernet SLA profile globally with stateful thresholds and action, applying it to an interface with specific threshold values, checking that the parameters are displayed correctly in the \"show ethernet sla operations\" command output, and ensuring that Syslog messages are generated when the thresholds are exceeded. Additionally, verify that the EFD (Enhanced Fast Debug) action is triggered as expected, check that the Ethernet SLA breached information is displayed correctly under the \"show ethernet sla statistics\" command output, configure high threshold values to trigger a Threshold clear syslog message, and finally unconfigure the Ethernet SLA from both the interface and globally.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep clear eth sla clear stateful action max val lbm",
                "Procedure": "The test is designed to verify the functionality of Ethernet SLA (Service Level Agreement) stateful operation by configuring an LBM (Link Budget Monitor) Ethernet SLA profile with stateful thresholds and actions. It then applies this configuration to an interface, verifies that the configured threshold and action are displayed under the show ethernet sla operations detail command, and checks for the generation of syslog messages when the thresholds are breached. The test also ensures that the EFD (Enhanced Feature Discovery) action is triggered as expected. After clearing the Ethernet SLA statistics with the clear ethernet sla statistics all command, the test verifies that stateful SLA thresholds are cleared, a corresponding syslog message is generated, and the information is updated in show ethernet sla operations detail. Finally, the test confirms that EFD status is cleared after unconfiguring the Ethernet SLA profile from both interface and global levels.\n\nThis test is triggered by configuration: Ethernet SLA with thresholds and interface level SLA configs.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.lbm_measures\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nEfd interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared with clear ethernet sla statistics all verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres negative max val dmm",
                "Procedure": "This test involves verifying the behavior of Ethernet SLA (Service Level Agreements) with stateful thresholds and actions using Delay Measurement Message (DMM), specifically covering one-way delay, jitter, and round-trip metrics. The following steps are performed: the Ethernet SLA profile is configured globally with stateful thresholds and action with maximum value; applied under interfaces; verified for correct display on the show ethernet sla operations CLI; checked for Syslog generation when thresholds are breached; displayed correctly on the show ethernet sla statistics CLI; EFD (Enterprise Forwarding Detection) action applied. Then, a trigger is performed: SLA config, cfm from interface, and interface configs are removed and rolled back, interfaces shut and unshut, and verified that configured parameters display correctly on the show ethernet sla operations CLI afterwards. Syslog generation when thresholds are breached is also verified after the trigger.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"shut_unshut_interface\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nThreshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nCfm peer meps verification is performed.\nEfd interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nEFD action is triggered with show efd interface verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nEFD action is cleared when measured value goes below configured threshold verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres negative max val dmm",
                "Procedure": "Here's a natural-sounding paragraph that describes the scenario:\n\nThis test verifies Ethernet Service Level Agreements (SLA) with stateful thresholds and actions using Delay Measurement Messages (DMM) by covering various delay and jitter metrics. The following steps are performed: an Ethernet SLA profile is configured globally with max-value stateful thresholds and action, applied under interfaces, and verified to display correctly in the CLI. Syslog generation is also tested when configured SLA thresholds are breached, as well as the display of breached information under show Ethernet SLA statistics CLI. The trigger is performed by removing and rolling back the SLA configuration, interface configurations, and CFM from the interface, followed by shutting and unshutting the interfaces. Post-trigger verification includes checking that configured parameters still display correctly in the CLI and that Syslog generation occurs when thresholds are breached again. Additionally, high threshold values are set to test for Threshold clear syslog generation before finally removing Ethernet SLA configurations globally and from interfaces.\n\nThis test is triggered by simulating a network fault, such as shutting down an interface or removing a configuration, to verify how the system responds to such events.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\ntrigger: \"ApData.triggers\"",
                "Pass/Fail Criteria": "Verify verification is performed.\nThreshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nCfm peer meps verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless downmep pm thres proc trigger max val dmm",
                "Procedure": "Here's the rewritten paragraph:\nEthernet SLA configurations use stateful thresholds to monitor one-way delay, jitter, round-trip delay, and round-trip jitter. To set up these thresholds, first configure a global Ethernet SLA profile with stateful thresholds and an action based on the maximum value allowed. Next, apply this configuration to individual interfaces. Verify that the configured parameters are displayed correctly using the \"show ethernet sla operations\" CLI command. Then, test the process by triggering a breach of the thresholds, which should generate a syslog message. After the trigger, recheck that the configured parameters are still correct and that a new syslog is generated if the thresholds are breached again. Finally, configure high threshold values to test for threshold clear syslog generation.\n\nThis test is triggered by configuring high thresholds in order to see whether a threshold clear syslog message is generated.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprocess_action, process_name: \"PmApBase.get_process_action_list(ApData.process_action, ApData.processes)\"",
                "Pass/Fail Criteria": "Threshold log verification is performed.\nEthernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nSla action is updated under show ethernet sla statistics verification is performed.\nStateleful cleared syslog generation verification is performed.\nRepeat above verification after trigger verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateless pm thres sample count dmm",
                "Procedure": "Ethernet SLA profiles can be configured globally to test stateless thresholds and actions using Delay Measurement (DMM). The following parameters are tested: one-way-delay-sd, one-way-delay-ds, round-trip-jitter, round-trip-delay, one-way-jitter-sd, and one-way-jitter-ds. To configure an Ethernet SLA profile, follow these steps: configure the profile globally with the desired stateless thresholds and action, apply the configuration to a specific interface, and verify that the parameters are displayed correctly using the show ethernet sla operations CLI command. The maximum delay is 0.030ms, but even with minimal configuration, aggregating bins with a width of 1ms and a sample count as low as 2 can prevent the sample count from breaching its limit. As a result, SLA actions may not be triggered in this scenario. This test is triggered by configuring an Ethernet SLA profile with stateless thresholds using LBM (Link Bundle Management) at both the interface level and globally, along with specific configuration options for sample count.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_measures\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Downmep stateful pm thres sample count dmm",
                "Procedure": "Ethernet SLA tests verify the network's one-way-delay-sd, one-way-delay-ds, round-trip-jitter, round-trip-delay, one-way-jitter-sd, and one-way-jitter-ds. This test is triggered by a configuration that aggregates bins with a width of 1 ms and a sample count minimum of 2 at the interface level, which can result in a sample count never being breached and thus preventing SLA actions from occurring. The configuration involves setting up an Ethernet SLA profile globally with stateless thresholds and action, then applying it to interfaces with specific threshold values as mean-values. After this, verify that the configured parameters are displayed correctly using the show ethernet sla operations CLI command.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.dmm_measures\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale stateless pm thres max val dmm",
                "Procedure": "When verifying Ethernet SLA stateless thresholds and action with Delay Measurement Message (DMM) in a Scaled configuration, the following steps are performed. First, configure an Ethernet SLA profile globally with specified thresholds and action, including a maximum value. Next, apply this configuration under each interface. After that, use the 'show ethernet sla operations' CLI command to verify that the configured parameters are displayed correctly, although it's noted that verifying through syslog is not recommended due to potential delays and time-outs. Finally, unconfigure the Ethernet SLA from both the interface and globally.\n\nThis test is triggered by configuring an Ethernet SLA profile with stateless thresholds using DMM, a maximum value, and interface-level configurations.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_dmm_measures\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Upmep scale stateful pm thres max val dmm",
                "Procedure": "To configure and test Ethernet Service Level Agreements (SLAs) with stateful thresholds and action, a scaled configuration is used covering one-way delay in both directions, one-way jitter in both directions, round-trip jitter, and round-trip delay. The process involves configuring an Ethernet SLA profile globally with specific thresholds and actions using the maximum value option, then applying this configuration to each interface. Verification of the parameters can be done through the show ethernet sla operations command, although syslog verification is not currently performed due to its long response time. Finally, the SLA configuration is unapplied from both the interface and globally.\n\nThis test is triggered by the configuration of an Ethernet SLA profile with stateless thresholds using a Delay Measurement Message (DMM) with maximum value and interface-level SLA configurations enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nmeasure_type: \"ApData.scale_dmm_measures\"",
                "Pass/Fail Criteria": "Ethernet sla operations detail interface verification is performed.\nEthernet sla statistics interface verification is performed.\nsla configuration verification with show ethernet sla operations detail verification is performed.\nStateless syslog is generated with threshold breach verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    },
    "upgrade_downgrade_l2_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Upgrade downgrade",
                "Procedure": "When attempting to install an upgrade or a downgrade, the system runs an \"install upgrade downgrade\" test, which is repeated. The configuration for this test has not been specified.\n\nThis test is triggered by any installation attempt involving upgrades or downgrades.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nupgrade_info: \"get_matrix.get_matrix_data(tc_name='test_upgrade_downgrade')\"\niteration: \"get_iterations()\"",
                "Pass/Fail Criteria": "Test case is passed if all verifications are successful."
            }
        ]
    },
    "Y1564_ap.py": {
        "test_cases": [
            {
                "Test Case Name": "Y1564 internal bundle dot1q doubleinner any l2vpn subinterface",
                "Procedure": "The configuration of y1564 is tested in the Internal direction on a Bundle with a dot1q doubleinner_any l2vpn interface, specifically to configure and verify its internal behavior.\n\nThis test is triggered by configuring y1564 profile parameters for internal use.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal stopall action cscvv34907 l2vpn subinterface",
                "Procedure": "The stop all configuration for device y1564 is tested when sending traffic internally through the bundle interface. This test triggers when the system needs to configure and verify the stop all action's internal behavior on a y1564 device, specifically checking that all relevant parameters are correctly set in the internal direction, as per case CSCvv34907.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1q doubleinner range l2vpn subinterface",
                "Procedure": "The configuration of y1564 in the Internal direction on the Bundle dot1q doubleinner_range L2VPN interface is tested by testing the configuration. This test is triggered by a configuration that includes configuring and verifying all Y1564 parameters in the internal direction, which involves a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1ad doubleinner range l2vpn subinterface",
                "Procedure": "The configuration of y1564 is tested for a bundle with double inner range on the L2VPN interface in the internal direction, where it configures and verifies all internal Y1564 parameters.\n\nThis test is triggered by a y1564 profile configured in the Internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1ad doubleinner any l2vpn subinterface",
                "Procedure": "The test is performed to configure the y1564 on a Bundle dot1ad doubleinner_any l2vpn interface with an Internal direction. The y1564 configuration is then verified to ensure that all its parameters are properly set up.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1q l2vpn subinterface",
                "Procedure": "The configuration of y1564 is tested in the internal direction on the bundle dot1q l2vpn interface, where it is configured and verified to operate as expected. This test configures and verifies all Y1564 parameters in the internal direction. The necessary configuration for this test includes setting up a y1564 profile.\n\nThis test is triggered by the configuration of a y1564 profile on the bundle dot1q l2vpn interface in Internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1ad l2vpn subinterface",
                "Procedure": "The configuration of y1564 in Internal direction on Bundle dot1ad l2vpn interface is to be tested. This test configures and verifies the internal y1564 behavior by configuring and verifying all Y1564 parameters in internal direction, including those found within a y1564 profile.\n\nThis test is triggered by the configuration of a y1564 profile for an internal direction on a Bundle dot1ad l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle qinq l2vpn subinterface",
                "Procedure": "The configuration of y1564 in the Internal direction on Bundle qinq l2vpn interface is tested by testing the configuration. This test is triggered by configuring and verifying all Y1564 parameters in the internal direction, including the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle 1ad1q l2vpn subinterface",
                "Procedure": "To test the configuration of y1564, configure it to run internally on a bundle with both dot1ad and dot1q L2VPN interfaces. This test is triggered by the configuration command \"y1564 profile\".\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1q range l2vpn subinterface",
                "Procedure": "The configuration for y1564 in the Internal direction on a Bundle dot1q range l2vpn interface is tested by testing its internal behavior, specifically by configuring and verifying all Y1564 parameters to ensure correct operation. This test configures and verifies internal y1564 behavior - Configure and verify all Y1564 parameters in internal direction.\n\nThis test is triggered by the configuration of a 'y1564 profile'\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1ad range l2vpn subinterface",
                "Procedure": "The configuration of y1564 is tested in the Internal direction on the Bundle dot1ad range for an L2VPN interface. The test configures and verifies the internal y1564 behavior by setting up all Y1564 parameters in the internal direction.\n\nThis test is triggered by a y1564 profile configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1q priority tagged l2vpn subinterface",
                "Procedure": "The configuration for y1564 on a bundle with an L2VPN interface is tested. The internal direction of this setup uses dot1q priority tagging. This test configures and verifies the behavior of y1564 within the network, including all relevant parameters in the internal direction. Configuration involves setting up a profile for y1564.\n\nThis test is triggered by configuring a Y1564 profile with specified settings on an L2VPN interface with a bundle using dot1q priority tagging in the internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1ad priority tagged l2vpn subinterface",
                "Procedure": "The configuration of y1564 in the internal direction on a Bundle dot1ad priority tagged L2VPN interface is tested by testing the configuration of y1564 in Internal direction on Bundle dot1ad priority tagged l2vpn interface.\n\nThis test configures and verifies all Y1564 parameters in the internal direction, which includes configuring and verifying all internal Y1564 behavior. It also involves setting up a specific configuration: a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal packet size 1024 bundle dot1q doubleinner any l2vpn subinterface",
                "Procedure": "To test the configuration, configure and verify all Y1564 parameters for a bundle-dot1q doubleinner-any L2VPN interface facing internally, specifically in the direction of y1564.\n\nThis test is triggered by configuring a y1564 profile in an internal direction on a Bundle dot1q doubleinner-any l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal packet size 1500 bundle dot1q doubleinner any l2vpn subinterface",
                "Procedure": "To test the configuration of y1564 in Internal direction on a Bundle dot1q doubleinner-any L2VPN interface, the test configures and verifies the internal y1564 behavior by setting up and checking all Y1564 parameters.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle eir dot1q doubleinner any l2vpn subinterface",
                "Procedure": "The configuration of y1564 in the internal direction is tested on a bundle with a dot1q doubleinner-any l2vpn interface. The test involves configuring and verifying all Y1564 parameters within the internal direction, specifically the y1564 profile.\n\nThis test is triggered by configuring and verifying all Y1564 parameters in internal direction, particularly the y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 dot1q l2vpn subinterface",
                "Procedure": "The configuration of y1564 in an internal direction on a physical dot1q L2vpn sub-interface is tested, which involves configuring and verifying the internal y1564 behavior. All Y1564 parameters are set up and verified in this internal direction.\n\nThis test configures and verifies all Y1564 parameters by setting up a y1564 profile for the internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 dot1ad l2vpn subinterface",
                "Procedure": "The configuration of y1564 in internal direction on a physical dot1ad L2vpn subinterface is tested by verifying the y1564 parameters. This test configures and verifies all Y1564 parameters in internal direction, including those set within a y1564 profile.\n\nThis test is triggered by configuring a y1564 profile for internal direction on a physical dot1ad L2vpn subinterface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 qinq l2vpn subinterface",
                "Procedure": "The configuration of y1564 in internal direction on a physical Q-in-Q L2VPN sub-interface is tested by verifying that the y1564 parameters are configured and functioning correctly. This test configures and verifies internal y1564 behavior - Configure and verify all Y1564 parameters in internal direction. The test is triggered when configuring a y1564 profile to manage internal traffic on a specific Q-in-Q L2VPN sub-interface in an internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 1ad1q l2vpn subinterface",
                "Procedure": "The configuration of y1564 is tested in the internal direction for both physical dot1ad and dot1q L2vpn sub-interfaces. This test configures and verifies internal y1564 behavior - Configure and verify all Y1564 parameters in internal direction. The configuration involves a y1564 profile.\n\nThis test is triggered by configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 dot1q range l2vpn subinterface",
                "Procedure": "The configuration of y1564 in internal direction on a physical interface with a default VLAN ID set to 1q on the L2VPN Sub-interface is tested. This test configures and verifies the internal y1564 behavior by setting all Y1564 parameters in the internal direction, including those found within a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 dot1ad range l2vpn subinterface",
                "Procedure": "The configuration of y1564 in internal direction on a physical default dot1ad range L2vpn sub-interface should be tested, specifically the L2vpn Sub-interface option. This test is triggered by the need to configure and verify all Y1564 parameters in internal direction, which involves setting up and checking the Y1564 profile configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 dot1q priority tagged l2vpn subinterface",
                "Procedure": "The test checks the configuration of y1564 in an internal direction on a physical subinterface with dot1q priority tagging for L2VPN. This test configures and verifies the internal behavior of y1564, which includes configuring and verifying all Y1564 parameters in the internal direction, using a y1564 profile in its configuration.\n\nThis test is triggered by the need to verify the internal operation of y1564 on a specific type of physical subinterface with L2VPN and dot1q priority tagging.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 dot1ad priority tagged l2vpn subinterface",
                "Procedure": "The configuration for the y1564 interface is tested with a specific setting in an internal direction on a physical dot1ad priority tagged L2vpn sub-interface. This includes configuring and verifying all the parameters of the y1564 profile in the same direction.\n\nThis test is triggered by the need to configure and verify Y1564 parameters in internal direction, including all aspects of its profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle l2 dot1ad subinterface service policy process restart",
                "Procedure": "The configuration of interface y1564 in internal direction on Bundle L2 Dot 1ad Sub-interface with service policy is tested, and the process is restarted afterwards. This test configures and verifies the internal behavior of y1564 - it configures and verifies all Y1564 parameters in internal direction; Configuration: y1564 profile.\n\nTriggered by this test configuring and verifying all Y1564 parameters in internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nShow policy map interface verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sat maximum sessions bundle interfaces internal",
                "Procedure": "The test sets up the Verify SAT to create a maximum number of sessions on the EFP under bundle subinterfaces in the internal direction, while also configuring and verifying all Y1564 parameters in this same direction with the maximum session count.\n\nThis test is triggered by the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nEthernet sadt interface summary verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions physical interface internal",
                "Procedure": "The SAT is verified by configuring a large number of sessions on the Equal Forwarding Path (EFP) under the same physical interface, which then triggers this test to configure and verify all Y1564 parameters in the internal direction with maximum sessions. This test is triggered by verifying the SAT.\n\nThis line: \"This test is triggered by\" would be rewritten as: \n\n\"This test is triggered by verifying the SAT.\"\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nEthernet sadt interface summary verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 qinq l2vpn subinterface efp unconfigure",
                "Procedure": "The configuration of y1564 in internal direction on physical qinq L2vpn Sub-interface with efp unconfigured is tested. This involves configuring and verifying how y1564 behaves internally, including setting Y1564 parameters in the internal direction, verifying the y1564 profile on a physical L2 qinq L2vpn Sub-interface set up for internal use, disabling efp at the interface level, re-configuring service activation on the interface, and then verifying the y1564 profile again. The configuration used is that of a y1564 profile. This test is triggered by configuring y1564 parameters in internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature working with efp unconfigure verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle dot1ad l2vpn subinterface interface flap",
                "Procedure": "To test the configuration, the system is set up to configure and verify all Y1564 parameters in internal direction on a Bundle dot1ad L2VPN interface with an interface flap. The configuration includes a y1564 profile.\n\nThis test is triggered by configuring a y1564 profile for testing in the specified network environment.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working after interface flap verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal packet size 1500 bundle dot1q doubleinner any activerp reload",
                "Procedure": "The configuration of y1564 is tested for the Internal direction on a Bundle dot1q double inner L2VPN interface by configuring and verifying all Y1564 parameters in that direction. This test is triggered by checking the configuration of y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal packet size 1500 bundle dot1q doubleinner any standbyrp reload",
                "Procedure": "The configuration of y1564 in the internal direction on a Bundle dot1q double inner any L2VPN interface is tested by testing the configuration. This test is triggered when configuring and verifying all Y1564 parameters in internal direction, specifically the y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 dot1q l2vpn subinterface im reload",
                "Procedure": "The configuration of y1564 in internal direction on a physical dot1q L2vpn sub-interface is tested. All Y1564 parameters are configured and verified in the internal direction, including those specified by the y1564 profile.\n\nThis test is triggered by configuring a y1564 profile for internal direction on a physical dot1q L2vpn sub-interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal packet size 1024 bundle dot1q doubleinner any l2vpn rpfo trigger",
                "Procedure": "The configuration of y1564 is tested in the internal direction on a Bundle dot1q doubleinner-any L2VPN interface, with specific focus on verifying the setup and operation of all relevant parameters.\n\nThis test is triggered by configuring the y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sat maximum sessions with diff mtu bundle interfaces internal with h value without fdr",
                "Procedure": "The SAT with H-value is verified, maximum sessions on EFP under bundle subinterface are created with different MTUs in the internal direction. This test configures and verifies the behavior of internal y1564 with maximum sessions by configuring and verifying all Y1564 parameters in the internal direction with maximum sessions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sat maximum sessions with diff mtu physical interface internal with h value without fdr",
                "Procedure": "The SAT is verified using an H-value, while creating the maximum number of sessions on the Ethernet Forwarding Plane (EFP) under a physical subinterface with different Maximum Transmission Unit (MTU) settings in the internal direction. The test configures and verifies all Y1564 parameters in the internal direction when the maximum number of sessions are established. This test is triggered by configuring a y1564 profile, which requires creating a maximum number of sessions on EFP under physical subinterface with different MTU in internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sat maximum sessions with diff mtu bundle interfaces internal with h value with fdr",
                "Procedure": "The SAT is verified along with H-value and FDR, while creating maximum sessions on EFP under a bundle subinterface with different MTUs in the internal direction. This test configures and verifies the behavior of Y1564 in internal direction with maximum sessions by configuring all Y1564 parameters.\n\nThis test is triggered by verifying the SAT with H-value and FDR, and then creating maximum sessions on EFP under a bundle subinterface with different MTUs in the internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sat maximum sessions with diff mtu physical interface internal with h value with fdr",
                "Procedure": "The test involves verifying the SAT with H-value and FDR, creating maximum sessions on EFP under physical subintf with different MTU in an internal direction. This is done to configure and verify internal Y1564 behavior with a maximum number of sessions. The configuration includes all Y1564 parameters in the internal direction with maximum sessions.\n\nThis test is triggered by the need to verify SAT with H-value and FDR, create maximum sessions on EFP under physical subintf with different MTU in an internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sat maximum sessions with fdr bundle interfaces internal",
                "Procedure": "The configuration involves verifying the SAT with FDR, creating maximum sessions on EFP under bundle subinterfaces in the internal direction, and configuring all Y1564 parameters for this setup with a focus on maximum sessions.\n\nThis test is triggered by verifying that all necessary configurations are in place.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Sat maximum sessions with fdr physical interface internal",
                "Procedure": "The test configuration involves verifying the SAT with FDR and creating a maximum number of sessions on EFP under the same physical interface. The test configures and verifies all Y1564 parameters in the internal direction, ensuring they function as expected when handling the maximum number of sessions.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle eir with fdr dot1q doubleinner any l2vpn subinterface",
                "Procedure": "To test the configuration of y1564 on an Internal network with FDR on a Bundle dot1q doubleinner_any l2vpn interface, configure and verify all Y1564 parameters in the internal direction. The configuration includes setting up a y1564 profile.\n\nThis test is triggered by: Configure and verify all Y1564 parameters in internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal bundle encap default subinterface",
                "Procedure": "The configuration for the y1564 is tested on an L2VPN interface with a bundle encapsulation in the internal direction, where it is configured and verified to function correctly.\n\nThis test is triggered by configuring a Y1564 profile in internal direction on the L2VPN interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy encap default subinterface",
                "Procedure": "The configuration of y1564 is tested in the direction of Internal, with a physical encapsulation of default L2VPN on an interface. The test configures and verifies the internal behavior of y1564 by setting up all its parameters for internal use. This test is triggered by configuring a Y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal bundle dot1q l2vpn subinterface",
                "Procedure": "To test the configuration of the y1564 on a Bundle dot1q l2vpn interface in the Internal direction, configure and verify all Y1564 parameters using a y1564 profile that includes POP1 rewriting.\n\nThis test is triggered by configuring a y1564 profile with POP1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle dot1q l2vpn subinterface",
                "Procedure": "The configuration for the y1564 protocol is tested on an interface that supports Bundle dot1q l2vpn, specifically with a push1 rewrite setup. All parameters related to Y1564 are configured and verified, taking into account internal direction considerations.\n\nThis test is triggered by configuring a y1564 profile with push1 rewrite in the internal direction of traffic flow.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal bundle dot1q l2vpn subinterface",
                "Procedure": "The configuration for the y1564 in the Internal direction on a Bundle dot1q l2vpn interface needs to be tested with translation enabled. This test is triggered by configuring a y1564 profile with push1 rewrite. The test configures and verifies all Y1564 parameters, ensuring they are set correctly for internal direction operation.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal bundle dot1ad l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on the Bundle dot1ad l2vpn interface tests internal direction settings with pop1 rewrite enabled. It configures and verifies all relevant y1564 parameters, ensuring correct operation in this scenario. \n\nThis test is triggered by configuring a y1564 profile with pop1 rewrite on a dot1ad interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle dot1ad l2vpn subinterface",
                "Procedure": "The configuration is tested for the rewrite push1 setup on an L2VPN bundle dot1ad interface directed internally to y1564. The test configures and verifies internal behavior with push1 rewriting enabled, including all Y1564 parameters in the internal direction. Configuration involves setting up a y1564 profile with push1 rewrite.\n\nThis test is triggered by a configuration of a y1564 profile with push1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal bundle dot1ad l2vpn subinterface",
                "Procedure": "The configuration tests the rewrite of a y1564 translator in the internal direction on a Bundle dot1ad l2vpn interface. It configures and verifies all y1564 parameters, including those related to the Translate 1_1 rewrite.\n\nThis test is triggered by configuring a y1564 profile with Translate rewrite functionality.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal bundle qinq l2vpn subinterface",
                "Procedure": "The configuration for testing the rewrite pop1 feature of y1564 on Internal interfaces in the qinq l2vpn bundle involves configuring and verifying the Y1564 parameters, including a profile with pop1 rewrite.\n\nThis test is triggered by the need to verify that all Y1564 parameters are correctly configured and functioning as expected in an internal direction configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop2 internal bundle qinq l2vpn subinterface",
                "Procedure": "The y1564 configuration is tested for the Internal direction on Bundle qinq l2vpn interface, where it configures and verifies internal behavior with a POP2 rewrite. The test involves configuring and verifying all Y1564 parameters in this direction. This test is triggered by a configuration that includes a y1564 profile with a POP2 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle qinq l2vpn subinterface",
                "Procedure": "The test for the y1564 configuration of the bundle qinq l2vpn interface, specifically in the Internal direction, involves configuring and verifying internal y1564 behavior with a push1 rewrite setup. All Y1564 parameters are to be configured and verified within this internal direction setting. This test is triggered by configuring a y1564 profile with a push1 rewrite configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal bundle qinq l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on the bundle qinq l2vpn interface is tested by translating it in an Internal direction. This test configures and verifies the internal behavior of y1564, utilizing the Translate 1_1 rewrite. It involves configuring all Y1564 parameters internally and verifying their settings.\n\nThis test is triggered by a configuration that includes a y1564 profile with the Translate rewrite feature enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 2 internal bundle qinq l2vpn subinterface",
                "Procedure": "The test checks the configuration of y1564 in the internal direction on a Bundle qinq l2vpn interface, specifically verifying its behavior with Translate 1_2 rewrite enabled. It involves configuring and testing all Y1564 parameters in this direction, including a y1564 profile that uses Translate rewrite.\n\nThis test is triggered by the requirement to configure and verify internal y1564 behavior with Translate 1_2 rewrite configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 2 2 internal bundle qinq l2vpn subinterface",
                "Procedure": "The configuration for the y1564 protocol on the Bundle qinq l2vpn interface is tested and verified in the Internal direction, with a focus on the Translate 2_2 rewriting feature. This test is triggered by configuring all Y1564 parameters internally.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal bundle 1ad1q l2vpn subinterface",
                "Procedure": "The configuration for the y1564 on the L2VPN interface in Bundle 1ad1q should be tested in the Internal direction to check its pop1 behavior.\n\nThis test is triggered by configuring a y1564 profile with a pop1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop2 internal bundle 1ad1q l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on Bundle 1ad1q's L2VPN interface is being tested for pop2 rewriting in an Internal direction. This test configures and verifies all relevant Y1564 parameters, including those set within a y1564 profile that enables pop2 rewrite. This test is triggered by configuring a y1564 profile with pop2 rewrite functionality.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle 1ad1q l2vpn subinterface",
                "Procedure": "To test the configuration of a bundle on an L2VPN interface, configure all the parameters for Y1564 in the internal direction with a specific profile that uses push1 rewrites and ensure it functions as expected.\n\nThis test is triggered by configuring a y1564 profile with 1ad1q rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal bundle 1ad1q l2vpn subinterface",
                "Procedure": "The configuration for a y1564 interface on Bundle 1ad1q l2vpn is tested internally with the Rewrite 1_1 translation enabled. The test configures and verifies all Y1564 parameters, including those within a y1564 profile that uses Rewrite.\n\nThis test is triggered by configuring a y1564 profile with Translate rewrite in the internal direction on Bundle 1ad1q l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 2 internal bundle 1ad1q l2vpn subinterface",
                "Procedure": "The test involves configuring and verifying the internal behavior of a y1564 translation, specifically with a Translate 1_2 configuration on an L2VPN interface located on Bundle 1ad1q in the Internal direction. This is triggered by a test that configures a y1564 profile with a Translate rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 2 2 internal bundle 1ad1q l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on the internal direction of the l2vpn interface is tested for Translate 2_2 behavior. This test configures and verifies all Y1564 parameters, including the y1564 profile with Translate 2_2 rewrite enabled. \n\nThis test is triggered by the requirement to test the functionality of the y1564 in the specified configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle dot1q priority tagged l2vpn subinterface",
                "Procedure": "The configuration is tested for the y1564 push1 setup on a Bundle interface with an L2VPN connection, specifically checking the Internal direction's handling of tagged frames using dot1q priority tags. This test configures and verifies all Y1564 parameters in internal direction, which includes configuring a y1564 profile to use dot1q_priority_tagged rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle dot1ad priority tagged l2vpn subinterface",
                "Procedure": "To test the functionality of the y1564 configuration, configure all y1564 parameters for an interface using bundle dot1ad_priority_tagged l2vpn, specifying a y1564 profile with push1 rewrite.\n\nThis test is triggered by configuring a Y1564 profile with dot1ad_priority_tagged rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle dot1q doubleinner range l2vpn subinterface",
                "Procedure": "To test the y1564 configuration, configure a profile that uses the dot1q_doubleinner_range rewrite for push1 on an L2VPN interface in the Internal direction. This test is triggered by configuring and verifying all Y1564 parameters in internal direction. Configuration includes setting up a y1564 profile with the specified dot1q_doubleinner_range rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle dot1ad doubleinner range l2vpn subinterface",
                "Procedure": "The configuration for the y1564 rewrite push1 is tested on a Bundle l2vpn interface in Internal direction, specifically targeting the dot1ad_doubleinner_range bundle. This test configures and verifies all Y1564 parameters in internal direction.\n\nThis test is triggered by configuring a y1564 profile with a dot1ad_doubleinner_range rewrite configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle dot1q doubleinner any l2vpn subinterface",
                "Procedure": "The configuration tests the y1564 settings for a bundle of L2VPN interfaces, specifically in an Internal direction on Bundle dot1q_doubleinner_any. It configures and verifies all Y1564 parameters to ensure proper internal behavior with push1 rewrite enabled.\n\nThis test is triggered by the configuration of a y1564 profile with dot1q_doubleinner_any rewrite in the internal direction on the specified L2VPN interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal bundle dot1ad doubleinner any l2vpn subinterface",
                "Procedure": "The test is designed to configure and verify the internal behavior of the y1564 system when push1 rewriting is enabled. This test configures and verifies all Y1564 parameters in the internal direction.\n\nThis test is triggered by a configuration that sets up a y1564 profile with dot1q_doubleinner_any rewrite on an L2VPN interface in the Bundle dot1ad_doubleinner_any directory.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal phy dot1q l2vpn subinterface",
                "Procedure": "The test involves configuring and verifying the internal behavior of Y1564 when it encounters a pop1 configuration for rewriting on an interface that supports phy dot1q l2vpn.\n\nThis test is triggered by configuring a y1564 profile with pop1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal phy 1ad1q l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on the phy 1ad1q l2vpn interface is tested by sending traffic in the Internal direction. This test configures and verifies all Y1564 parameters, specifically those related to internal behavior with push1 rewrite enabled.\n\nThis test is triggered by configuring a y1564 profile with the specific setting of 1ad1q rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 2 2 internal phy 1ad1q l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on the phy 1ad1q l2vpn interface is tested for its performance in an Internal direction, specifically when using the Translate 2_2 configuration. This test configures and verifies all Y1564 parameters with a focus on the internal behavior enabled by the Translate 2_2 rewrite functionality.\n\nThis test is triggered by configuring a y1564 profile that utilizes the Translate rewrite feature.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1q subinterface",
                "Procedure": "The configuration of y1564 in external direction on Bundle L2 Dot 1q Sub-interface should be tested by verifying that all relevant settings are properly configured to ensure the desired behavior.\n\nThis test is triggered by configuring and verifying all Y1564 parameters in external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1ad subinterface",
                "Procedure": "The test for configuring the y1564 settings in an external direction on the L2 Dot 1ad Sub-interface is performed by configuring and verifying all relevant y1564 parameters. This test is triggered by the configuration of a y1564 profile with specific settings for external behavior.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 qinq subinterface",
                "Procedure": "The configuration of y1564 in external direction on Bundle L2 qinq Sub-interface is tested, specifically the external y1564 behavior. All Y1564 parameters are configured and verified in this direction, utilizing a y1564 profile.\n\nThis test is triggered by configuring a y1564 profile for use with external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 1ad 1q subinterface",
                "Procedure": "The configuration for y1564 in the external direction is tested on Bundle L2, specifically on both Dot1ad and Dot1q Sub-interfaces. This test configures and verifies the external behavior of y1564 - it sets up and confirms all Y1564 parameters in the external direction by using a y1564 profile.\n\nThis test is triggered by configuring a y1564 profile to test the configuration of y1564 in the external direction on Bundle L2 Dot1ad and Dot1q Sub-interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1q range subinterface",
                "Procedure": "The configuration of y1564 is tested in the external direction on a Bundle Sub-interface with encapsulation dot1q range, which involves configuring and verifying external y1564 behavior by setting all relevant parameters.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1ad range subinterface",
                "Procedure": "The configuration of y1564 in the external direction should be tested on a Bundle Sub-interface with encapsulation dot1ad range, which involves configuring and verifying all Y1564 parameters in this direction. This test configures and verifies external y1564 behavior by setting up a y1564 profile with specific configuration settings.\n\nThis test is triggered by the need to verify that the external y1564 parameters are correctly configured on a Bundle Sub-interface with encapsulation dot1ad range, requiring a y1564 profile to be set up accordingly.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1q priority tagged subinterface",
                "Procedure": "The configuration of y1564 is tested for its operation in the external direction on a Bundle Sub-interface with dot1q priority tagging enabled. This test triggers when the configuration configures and verifies the behavior of y1564 in the external direction, including all relevant parameters such as those found within the y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1ad priority tagged subinterface",
                "Procedure": "The configuration of the y1564 interface is tested in an external direction on a Bundle Sub-interface with encapsulation dot1ad priority Tagged. This test configures and verifies all external y1564 behavior, including all relevant Y1564 parameters. The test configuration includes a y1564 profile.\n\nThis test is triggered by configuring y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1q subinterface",
                "Procedure": "The configuration of y1564 in external direction on the physical L2 dot1q sub-interface is tested by testing its setup and operation, including configuring and verifying all relevant parameters.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1ad subinterface",
                "Procedure": "The configuration of device y1564 should be tested in an external direction on a physical sub-interface that supports Layer 2 access (dot1ad). This test is triggered by the condition that it configures and verifies the external behavior of the y1564 feature. The y1564 parameters need to be configured and verified for operation in the external direction, with all settings correctly set according to the specified y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 qinq subinterface",
                "Procedure": "The configuration of y1564 is tested in an external direction on a physical L2 qinq Sub-interface, specifically by configuring and verifying all Y1564 parameters in this direction. This test is triggered by the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 1ad1q subinterface",
                "Procedure": "The configuration of y1564 in external direction is tested on a physical L2 interface, specifically the Dot1ad and Dot1q sub-interfaces. This test configures and verifies the external behavior of y1564 by setting all Y1564 parameters in external direction. The configuration for this test includes the y1564 profile. \n\nThis test is triggered by the need to configure and verify all Y1564 parameters in external direction on a physical L2 interface, specifically the Dot1ad and Dot1q sub-interfaces.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1q range subinterface",
                "Procedure": "To test the configuration, configure the y1564 in external direction on a physical subinterface with encapsulation set to dot1q range, then verify that all y1564 parameters are correctly configured for external operation.\n\nThis test is triggered by the need to validate the setup of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1ad range subinterface",
                "Procedure": "The configuration of the y1564 interface is tested for its operation in an external direction on a physical sub-interface with encapsulation dot1ad range. This test configures and verifies the external behavior of y1564, ensuring that all relevant parameters are correctly set. The specific parameters to be configured are those related to the y1564 profile.\n\nThis test is triggered by configuring the y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1q priority tagged subinterface",
                "Procedure": "The configuration of port y1564 is tested when transmitting data outwards through a physical sub-interface with dot1q encapsulation, where the priority is tagged. This test configures and verifies the behavior of y1564 in the external direction, including all its parameters. Configuration: y1564 profile.\n\nThis test is triggered by the need to configure and verify all Y1564 parameters in an external direction configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1ad priority tagged subinterface",
                "Procedure": "The configuration of interface y1564 is tested in the external direction, specifically on a physical sub-interface with encapsulation dot1ad priority tagged. This test configures and verifies the external behavior of the y1564 parameter set, which includes configuring and verifying all relevant Y1564 parameters in the external direction.\n\nThis test is triggered by the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions physical interface external",
                "Procedure": "The system is configured to create the maximum number of sessions for External Forwarding Plane (EFP) under a single physical interface, verifying SAT and configuring external Y1564 behavior with four maximum sessions. The test configures all Y1564 parameters in the external direction.\n\nThis test is triggered by the creation of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nEthernet sadt interface summary verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions bundle interfaces external",
                "Procedure": "The configuration sets up the Y1564 profile, which includes verifying external Y1564 behavior with maximum sessions enabled. The test configures and verifies all relevant Y1564 parameters in the external direction when working at maximum session capacity.\n\nThis test is triggered by a requirement to verify SAT configurations that establish maximum sessions under bundle subinterfaces in an external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nSadt verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Max session check external",
                "Procedure": "To verify SAT, configure y1564 in an external direction with a maximum of Y1564 sessions.\n\nThis test is triggered by verifying that the configuration of y1564 in an external direction allows for up to the maximum number of Y1564 sessions specified in the y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working after max sessions. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1q subinterface interface flap",
                "Procedure": "The test checks the configuration of y1564 in an external direction on a physical sub-interface with dot1q encapsulation, including interface flapping. It configures and verifies the external behavior of y1564. All Y1564 parameters are set up to function correctly in this scenario.\n\nThis test is triggered by: The presence of a specific y1564 profile configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working after interface flap. verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1q subinterface im reload",
                "Procedure": "To test the configuration of y1564 in an external direction on a physical L2 dot1q Sub-interface with IM Reload, you must have a platform that supports IM's and tag accordingly. This involves configuring and verifying all Y1564 parameters in external direction.\n\nThis test is triggered by the need to configure a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working after IM Reload verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1q subinterface activerpreload",
                "Procedure": "The test checks the configuration of y1564 for an interface that's facing outwards on Bundle L2 Dot 1q Sub-interface with Active RP Reload configured. This test is triggered by a specific setup, where it configures and verifies all Y1564 parameters in external direction using a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nVerifyplatform verification is performed.\nVerifyshowredundancy verification is performed.\nOspf neighbors verification is performed.\ny1564: verify y1564 feature is working after ActiveRP Reload verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 1ad1q subinterface process restart rp",
                "Procedure": "The configuration of y1564 is tested in the external direction on a physical L2 Untagged Sub-interface, specifically with RP (Rapid Per-VLAN Spanning Tree) process restart enabled. This test configures and verifies all Y1564 parameters to function correctly in external mode. Configuration settings include enabling the y1564 profile.\n\nThis test is triggered by configuring a y1564 profile on a physical L2 Untagged Sub-interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working after process restart verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 qinq subinterface rpfo trigger",
                "Procedure": "The y1564 configuration is tested in the external direction on a physical Layer 2 QinQ subinterface with an RPFO trigger. To do this, all relevant Y1564 parameters are configured and verified for proper function, specifically in terms of external behavior.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nVerifyplatform verification is performed.\nVerifyshowredundancy verification is performed.\ny1564: verify y1564 feature is working after RPFO verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 1ad1q subinterface process restart rp lc",
                "Procedure": "The configuration of y1564 on the physical L2 Untagged Sub-interface needs to be tested in external direction, but only after a process restart on both RP (Route Processor) and LC (Line Card). However, for platforms with an LC, tagging is required. This test will not work on RSP4. To configure and verify external y1564 behavior with process restart, all Y1564 parameters must be configured in external direction.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working after process restart verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1q priority tagged subinterface mpa reload",
                "Procedure": "On platforms that support Multi-Protocol Aggregation (MPA) such as Fretta, the configuration of y1564 in external direction on Bundle Sub-interface with dot1q priority tagged should be tested with encapsulation MPA reload.\n\nThis test is triggered by the need to verify and configure all Y1564 parameters in external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working after IM Reload Fretta verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1ad subinterface standbyrp reload",
                "Procedure": "The configuration of y1564 is tested in an external direction on a physical L2 dot1ad sub-interface during a Standby RP Reload scenario, where the test configures and verifies the external behavior of y1564 by setting all relevant parameters.\n\nThis test is triggered by a Standby RP Reload.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nVerifyplatform verification is performed.\nVerifyshowredundancy verification is performed.\ny1564: verify y1564 feature is working after StandBy RP Reload verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 phy l2 dot1q subinterface sat admin reload",
                "Procedure": "The configuration of the device y1564 is tested when it's directed externally on a physical sub-interface that uses dot1q encapsulation, requiring an administrator to reload. This test configures and verifies external y1564 behavior, including all Y1564 parameters in external direction triggered by admin reload.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working after admin reload verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1q doubleinner range subinterface",
                "Procedure": "The configuration of y1564 in external direction is tested on the physical L2 sub-interface named dot1q_doubleinner_range. The test involves configuring and verifying all aspects of Y1564's behavior when working externally, including all necessary parameters. This test is triggered by configuring a y1564 profile to control its external operation.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1ad doubleinner range subinterface",
                "Procedure": "The configuration of y1564 in external direction on the physical L2 dot1ad_doubleinner_range sub-interface is tested. This test triggers when configuring and verifying external y1564 behavior, including all Y1564 parameters, with a configuration that utilizes a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1q doubleinner any subinterface",
                "Procedure": "The configuration of y1564 is tested in an external direction on the physical L2 dot1q_doubleinner_any sub-interface, specifically to configure and verify its behavior in this context. This test configures and verifies all Y1564 parameters in the external direction. The configuration involves a y1564 profile.\n\nThis test is triggered by configuring and verifying all Y1564 parameters in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 dot1ad doubleinner any subinterface",
                "Procedure": "The configuration of y1564 in external direction on the physical L2 sub-interface with the ID dot1ad_doubleinner_any is tested by testing the configuration and verifying its behavior.\n\nThis test is triggered when configuring and verifying all Y1564 parameters in external direction, which involves a configuration that includes setting up a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1q doubleinner range subinterface",
                "Procedure": "To test the configuration of y1564, configure and verify it in an external direction on a physical bundle with dot1q_doubleinner_range Sub-interface. This test configures and verifies the external behavior of y1564 by setting up all necessary parameters in the external direction.\n\nThis test is triggered by configuring a 'y1564 profile'.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1ad doubleinner range subinterface",
                "Procedure": "The configuration of y1564 in external direction on the L2 dot1ad_doubleinner_range sub-interface needs to be tested. The test configures and verifies external y1564 behavior by setting up all relevant Y1564 parameters, including those that are part of a specific y1564 profile.\n\nThis test is triggered by configuring y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1q doubleinner any subinterface",
                "Procedure": "The configuration of device y1564 in the external direction on sub-interface L2 dot1q_doubleinner_any needs to be tested. This includes configuring and verifying the external behavior of y1564, as well as all relevant Y1564 parameters in the external direction. A y1564 profile is required for this configuration.\n\nThis test is triggered by the need to configure a device that supports Y1564 functionality with specific parameters on a sub-interface configured for dot1q_doubleinner_any in an external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 dot1ad doubleinner any subinterface",
                "Procedure": "To test the configuration of y1564 in an external direction on a sub-interface, bundle L2 dot1ad_doubleinner_any must be tested. This includes configuring and verifying all Y1564 parameters in the external direction, specifically to ensure that the y1564 profile is properly configured.\n\nThis test is triggered by a y1564 profile configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions diff mtu bundle interfaces external with h value without fdr",
                "Procedure": "The SAT is verified with an H-value, and the maximum number of sessions is differentiated by MTU on EFP under a bundle subinterface in the external direction. This test configures and verifies all Y1564 parameters in the external direction with maximum sessions when configuring an external Y1564 profile with maximum sessions.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions diff mtu physical interface external with h value without fdr",
                "Procedure": "The test verifies the operation of a system that handles multiple sessions over an Ethernet connection, specifically focusing on the settings for maximum transmission unit (MTU) on External Forwarding Proxy (EFP). To accomplish this, the test configures and tests all parameters related to Y.1564 behavior in both internal and external directions with a maximum of 4 sessions enabled. This test is triggered by configuring a Y.1564 profile.\n\nTrigger sentence: \nThis test is triggered by configuring a Y.1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions diff mtu physical interface external with h value with fdr",
                "Procedure": "The SAT is verified using its h-value and FDR, while the maximum number of sessions for EFP under a shared physical interface is configured and tested. The configuration includes setting up and verifying all Y1564 parameters for external operation with a maximum of four sessions.\n\nThis test is triggered by a configuration that involves creating a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions diff mtu bundle interfaces external with h value with fdr",
                "Procedure": "The configuration involves verifying the SAT with an h-value and FDR, creating a maximum number of sessions with different MTU on EFP under bundle subinterface in the external direction. This test is triggered by configuring a Y1564 profile to examine all Y1564 parameters in the external direction with a maximum number of sessions enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions with fdr physical interface external",
                "Procedure": "The SAT is verified using the FDR, and a maximum of sessions are created on EFP under the same physical interface. To configure and verify the external Y1564 behavior with a maximum number of sessions, all relevant parameters must be configured in the external direction. This test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Verify sat maximum sessions with fdr bundle interfaces external",
                "Procedure": "The configuration of external Y1564 behavior is tested, with a focus on verifying that the system can handle maximum sessions under a bundle subinterface. The test also configures and verifies various Y1564 parameters in the external direction when operating at maximum session capacity.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working with max sessions verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle eir with fdr dot1q doubleinner any subinterface",
                "Procedure": "The configuration of y1564 is tested in the Internal environment with FDR on Bundle dot1q doubleinner_any l2vpn interface. The test configures and verifies internal y1564 behavior, specifically by configuring and verifying all Y1564 parameters in the internal direction.\n\nThis test is triggered by a change to the y1564 profile configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external phy l2 encap default subinterface",
                "Procedure": "The configuration of y1564 should be tested in the external direction on a physical L2 encapsulation sub-interface, where it is configured and verified to behave as expected in that direction. This test configures and verifies external y1564 behavior by setting all Y1564 parameters correctly in the specified scenario - specifically, with a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 external bundle l2 encap default subinterface",
                "Procedure": "The configuration of y1564 is tested in the external direction on Bundle L2 encap default Sub-interface, where it is configured and its behavior verified. This test configures and verifies all Y1564 parameters in the external direction.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with ipv4 ipv6 and dual",
                "Procedure": "The L3 Physical_main interface is tested for its functionality with external y1564 and edpl settings in both ipv4/ipv6/dual stack configurations. The test configures and verifies all Y1564 and edpl parameters to ensure proper behavior when accessing the interface from an external direction.\n\nThis test is triggered by configuring the interface first with a dual-stack address, followed by setting ipv4 and then ipv6 addresses.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle main with ipv4 ipv6 and dual address",
                "Procedure": "Y1564 and EdPL are tested in an external direction for the L3 bundle_main interface (IPv4/IPv6/dual stack). The test configures and verifies their behavior by setting all parameters in both directions. Configuration is done first with a dual-stack address, followed by IPv4 and then IPv6 addresses.\n\nThis test is triggered by the necessity to verify the configuration and operation of Y1564 and EdPL in an external direction for the L3 bundle_main interface (IPv4/IPv6/dual stack).\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with ipv4 ipv6 and dual address with shut noshut",
                "Procedure": "The test y1564 and edpl in an external direction for the L3 physical_main interface with shut/noshut (ipv4/ipv6/dual stack) is performed to configure and verify external behavior of these protocols. This includes configuring and verifying all Y1564 and edpl parameters in the external direction, specifically by first setting up a dual stack configuration followed by ipv4 and then ipv6 addresses.\n\nThis test is triggered by: The presence of both ipv4 and ipv6 addresses configured on the interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle main with ipv4 ipv6 and dual address with shut noshut",
                "Procedure": "The test for the L3 bundle_main interface involves configuring and verifying external y1564 and edpl behavior, including all relevant parameters. This test is triggered by a configuration change that toggles the shut/noshut state of the ip addresses (ipv4/ipv6/dual stack) in an external direction, first with dual stack then ipv4 and finally ipv6 addresses.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical sub with ipv4 ipv6 and dual stack",
                "Procedure": "This is the rewritten paragraph:\n\nThe test for L3 physical_sub interfaces (ipv4/ipv6/dual stack) involves testing y1564 and edpl in an external direction, configuring, and verifying all their parameters. This behavior includes setting up a Y1564 profile.\n\nTrigger sentence: This test is triggered by the configuration of a Y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle sub with ipv4 ipv6 and dual stack",
                "Procedure": "When testing the y1564 and EDPL in an external direction for L3 bundle_sub interfaces (IPv4, IPv6, or dual stack), this test configures and verifies their behavior. All relevant parameters are configured and verified in the external direction. This test is triggered by a configuration of the Y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with edpl filter wrong destination mac",
                "Procedure": "The L3 physical main interface is tested with a wrong destination MAC address for the external direction of the y1564 and edpL protocols. This test configures and verifies the behavior of the external y1564 and edpL, which involves configuring and verifying all their parameters in the external direction, specifically using a y1564 profile.\n\nThis test is triggered by an error in the destination MAC address configuration for the L3 physical main interface when testing the external direction of the y1564 and edpl protocols.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle main with edpl filter wrong destination mac",
                "Procedure": "The L3 bundle_main interface with a wrong destination_mac is tested for y1564 and edpl in an external direction. The test configures and verifies the external y1564 and edpl behavior by setting all necessary Y1564 and edpl parameters. This test is triggered when configuring the y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 and l2 physical sub with shut and noshut",
                "Procedure": "The test involves testing the functionality of both L3 and L2 physical_sub interfaces for y1564 and edpl in an external direction, specifically with respect to shut/noshut operations. It configures and verifies all Y1564 and edpl parameters in this context.\n\nThis test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 and l2 bundle sub with shut and noshut",
                "Procedure": "To configure and verify the external behavior of y1564 and edpl on L3 and L2 bundle_sub interfaces, test y1564 and edpl in an external direction with shut/noshut enabled. This test is triggered by a configuration that includes all relevant Y1564 and edpl parameters in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle sub and l2 physical sub with shut and noshut",
                "Procedure": "The test checks the configuration and verification of y1564 and edpl parameters in an external direction for L3 bundle_sub and L2 physical_sub interfaces with shut/noshut settings. This test configures and verifies all Y1564 and edpl parameters in external direction. Configuration: y1564 profile.\n\nThis test is triggered by the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external by converting l2 to l3 physical main interface",
                "Procedure": "This test is triggered by the configuration of a y1564 profile, and it involves testing and verifying the external y1564 and edpl behavior by converting L2 to L3 on the physical main interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external by converting l2 to l3 bundle main interface",
                "Procedure": "The test of Y1564 and EDPL is conducted by converting the L2 to an L3 bundle main interface, which involves configuring and verifying all Y1564 and EDPL parameters in an external direction. This test configures and verifies external Y1564 and EDPL behavior - This test is triggered by a y1564 profile configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with different mtu values and color blind",
                "Procedure": "To test the y1564 and edpl interfaces, configure them for an L3 physical_main interface with color blind and different MTU values, then verify that they behave correctly. The test involves configuring and verifying all Y1564 and edpl parameters in external direction. This test is triggered by a configuration consisting of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle main with different mtu values and color blind",
                "Procedure": "The test involves configuring the y1564 and edpl interfaces on an L3 bundle_main with color blindness and different MTU values, then verifying their behavior. This test configures and verifies all Y1564 and edpl parameters in external direction. This test is triggered by the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical sub with different mtu values and color aware",
                "Procedure": "To test the external direction of the Layer 3 physical_sub interface with color-aware capabilities and different MTU values, configure the Y1564 and EDPL parameters on this interface.\n\nThis test is triggered by configuring a Y1564 profile for the Layer 3 physical_sub interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle sub with different mtu values and color aware",
                "Procedure": "The test involves testing the external direction of an L3 bundle_sub with color aware features and different MTU values, specifically the y1564 and edpl configurations. It configures and verifies all relevant parameters for these protocols in this configuration scenario, which includes a y1564 profile.\n\nThis test is triggered by verifying that all Y1564 and edpl parameters are properly configured in external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with different mtu values and ir",
                "Procedure": "The test involves configuring and verifying the behavior of the y1564 and edpl interfaces on the L3 physical_main interface, using different MTU values and information rates. All Y1564 and edpl parameters must be configured and verified in this setup.\n\nThis test is triggered by a configuration that sets up a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle main with different mtu values and ir",
                "Procedure": "The test configures and verifies the external behavior of y1564 and edpl, specifically for the L3 bundle_main interface with different MTU values and information rates. This test is triggered by configuring a y1564 profile in an external direction to configure and verify all Y1564 and edpl parameters.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical sub eir with fdr",
                "Procedure": "The test for the y1564 and edpl is run in an external direction for a physical_sub with color awareness. The test configures and verifies the behavior of the y1564 and edpl in this direction by setting all relevant parameters, including those defined within the y1564 profile.\n\nThis test is triggered by configuring Y1564 and EDPL parameters in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and eir packets are received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle sub eir with fdr",
                "Procedure": "This paragraph is not provided. Please provide the original text so I can assist you.\n\nHowever, based on your request to rewrite a given text into a single, natural-sounding paragraph, I will assume that the following is the original text:\n\nTest y1564 and edpl in external direction for L3 bundle_sub with color aware.\nThis test configures and verifies external y1564 and edpl behavior - Configure and verify all Y1564 and edpl parameters in external direction.\nConfiguration: y1564 profile\n\nHere's a rewritten version of the paragraph:\n\nThe test involves configuring and verifying the external behavior of y1564 and edpl for L3 bundle_sub with color awareness. All Y1564 and edpl parameters are set up and verified in the external direction, using a configuration that includes a y1564 profile.\n\nThis test is triggered by specifying a configuration: y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and eir packets are received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main by changing ip address",
                "Procedure": "To test the L3 Physical_main interface, change the IP address to an external direction and configure and verify the behavior of y1564 and edpl. This test is triggered by running a configuration that sets up both IPv4 and IPv6 addresses in dual-stack mode. Configuration involves setting all parameters for Y1564 and edpl in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical sub with edpl filter cos 1",
                "Procedure": "The test y1564 and edpl is conducted in an external direction for the L3 physical_sub with a cos of 1 for edpl. It configures and verifies the behavior of both y1564 and edpl in this setup, ensuring that all relevant parameters are correctly configured. This test is triggered by the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle sub with edpl filter cos 1",
                "Procedure": "The test case involves configuring and verifying the behavior of external y1564 and edpl components for an L3 bundle_sub with a common service ID of 1 for edpl. This test configures and verifies all Y1564 and edpl parameters in the external direction, with a configuration that includes a y1564 profile.\n\nThis test is triggered by verifying the functionality of the external y1564 component with the specified configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with router reload",
                "Procedure": "The test, referred to as y1564 and edpl in external direction for L3 physical_main with router reload, is designed to configure and verify the external behavior of these components. The process involves configuring all relevant Y1564 and edpl parameters in an external direction and then verifying that they function as expected.\n\nThis test is triggered by the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nVerifyplatform verification is performed.\nVerifyshowredundancy verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle main with router reload",
                "Procedure": "The configuration of a device's external capabilities, including the setup and verification of both Y1564 and EDPL parameters, is tested for a Level 3 bundle_main with router reload.\n\nThis test is triggered by configuring and verifying all necessary parameters within a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nVerifyplatform verification is performed.\nVerifyshowredundancy verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with lc oir mpa reload",
                "Procedure": "The test y1564 and edpl is performed in an external direction on the L3 physical_main for the Ncs560 platform with the specific configuration of Lc_oir_mpa_reload only. It involves configuring and verifying all parameters related to Y1564 and edpl behavior in the external direction, including setting up the correct profile.\n\nThis test is triggered by a configuration that includes the y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle main with lc oir mpa reload",
                "Procedure": "On the NCS560 platform, this test is triggered by configuring the y1564 and edpl in an external direction for the L3 bundle_main with the Lc_oir_mpa_reload, then verifying all Y1564 and edpl parameters in that configuration. This includes the y1564 profile.\n\nThis test is triggered by configuring the y1564 and edpl in an external direction for the L3 bundle_main with the Lc_oir_mpa_reload on the NCS560 platform.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with process restart",
                "Procedure": "The test involves configuring and verifying the external behavior of physical_main with qos_ma, sat_ma, and edpl_ma process restart for L3 traffic using test y1564 and edpl. This test is triggered by a configuration that sets up a y1564 profile for L3 traffic in the external direction.\n\nThis test configures and verifies all Y1564 and edpl parameters in external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle main with process restart",
                "Procedure": "The test involves testing the y1564 and edpl functionality for an L3 bundle_main with qos_ma, sat_ma, and edpl_ma processes when restarted. This test configures and verifies external y1564 and edpl behavior - Configure and verify all Y1564 and edpl parameters in external direction.\n\nThis test is triggered by the configuration of a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working and edpl is looping back the pkts received verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical sub with max sadt profiles",
                "Procedure": "To test the y1564 and edpL functionality in an L3 physical_sub configuration with maximum sadt profiles, configure and verify all relevant parameters in the external direction.\n\nThis test is triggered by the need to confirm that the Y1564 and EDPL configuration meets the specified requirements.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 bundle sub with max sadt profiles",
                "Procedure": "To test y1564 and edpl in the external direction for a level 3 physical_sub with maximum sadt profiles, the system is configured to configure and verify all y1564 and edpl parameters in this direction. This test is triggered by configuring a y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 and edpl external l3 physical main with multicast mac",
                "Procedure": "The test y1564 and edpl in external direction for the L3 Physical main interface with multicast mac is run. This involves configuring and verifying the external behavior of these protocols, including setting up and checking all relevant parameters such as the multicast address.\n\nThis test is triggered by configuration changes made to Y1564 and EDPL parameters in an external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Ethernet loopback active verification is performed.\nY1564 details verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nedpl: verify edpl is looping back the pkts received verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 internal phy l2 dot1q subinterface",
                "Procedure": "The configuration of port y1564 is tested for an external direction on a physical L2 dot1q subinterface. To do this, the configuration configures and verifies how the y1564 behaves externally by setting up all relevant Y1564 parameters in that direction. The required configuration for this test involves the use of a y1564 profile.\n\nThis test is triggered by configuring y1564 profile.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nEthernet loopback active verification is performed.\ny1564: verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 external phy dot1q subinterface",
                "Procedure": "The test is designed to test the rewrite pop1 configuration of device y1564 in External direction on phy dot1q interface, which configures and verifies internal y1564 behavior with pop1 rewrite. It involves configuring and verifying all Y1564 parameters in external direction by utilizing a y1564 profile with pop1 rewrite.\n\nThis test is triggered by a specific scenario involving the configuration of a y1564 device for External direction on a phy dot1q interface, where pop1 rewrite functionality needs to be enabled.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 dot1q external phy dot1q subinterface",
                "Procedure": "The configuration of the y1564 in External direction on phy dot1q subinterface is tested with a specific push1 dot1q configuration. This test configures and verifies internal y1564 behavior using push1 dot1q rewrite.\n\nThis test is triggered by configuring a y1564 profile with dot1q rewrite in order to verify all Y1564 parameters in the external direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal bundle dot1ad doubleinner range l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on an L2VPN interface in the Internal direction involves testing the rewrite capabilities for Bundle dot1ad_doubleinner_range. This test configures and verifies all Y1564 parameters in internal direction, including a y1564 profile with dot1ad_doubleinner_range rewrite.\n\nThis test is triggered by configuring a y1564 profile on an L2VPN interface to use dot1ad_doubleinner_range rewriting for packets transmitted in the Internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal bundle dot1q doubleinner range l2vpn subinterface",
                "Procedure": "The test checks the configuration of y1564 in the Internal direction on a Bundle dot1q_doubleinner_range l2vpn interface, specifically verifying that it configures and displays all Y1564 parameters correctly. This test is triggered by configuring a y1564 profile with a dot1q_doubleinner_range rewrite in the translate_1_1 configuration of y1564.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal bundle dot1ad doubleinner range l2vpn subinterface",
                "Procedure": "The configuration of the y1564 in the Internal direction on the Bundle dot1ad_doubleinner_range l2vpn interface is tested by testing the translate_1_1 rewrite translation_1_1 configuration of y1564 in internal direction on bundle dot1ad_doubleinner_range L2VPN interface. This test configures and verifies all Y1564 parameters in the internal direction, including a y1564 profile with dot1ad_doubleinner_range rewrite.\n\nThis test is triggered by configuring a y1564 profile with dot1ad_doubleinner_range rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal bundle dot1q doubleinner range l2vpn subinterface",
                "Procedure": "To test the y1564 configuration for a pop1 rewrite, we need to configure and verify all of its parameters on an interface that uses the l2vpn bundle protocol. This is done by setting up a y1564 profile with a specific rewrite rule, known as dot1q_doubleinner_range.\n\nThis test is triggered by configuring a y1564 profile with a specific rewrite rule, such as dot1q_doubleinner_range.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal phy dot1q l2vpn subinterface",
                "Procedure": "The configuration of y1564 in Internal direction on phy dot1q l2vpn interface is tested by verifying the internal behavior with push1 rewrite. This test configures and verifies all Y1564 parameters, including a y1564 profile with push1 rewrite. It is triggered when testing the rewrite push1 configuration of y1564 in Internal direction on phy dot1q l2vpn interface.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal phy dot1q l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on the phy dot1q l2vpn interface in the Internal direction should have a translate_1_1 rewrite. All Y1564 parameters should be configured and verified in this internal direction, including a profile with a translate_1_1 rewrite. This test is triggered by configuring a y1564 profile with a specific translation mode of 1.1.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal phy 1ad1q l2vpn subinterface",
                "Procedure": "The test checks the configuration of the y1564 on phy 1ad1q l2vpn interface in Internal direction. It verifies that all Y1564 parameters are properly configured and functions as expected, utilizing a y1564 profile that enables pop1 rewrite for internal behavior.\n\nThis test is triggered by the configuration of a y1564 profile with 1ad1q rewrite on an L2VPN interface in internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal phy 1ad1q l2vpn subinterface",
                "Procedure": "The configuration for testing the y1564 on a phy 1ad1q l2vpn interface involves configuring the internal behavior of y1564 with translate_1_1 rewrite and verifying its operation. The test covers all parameters in internal direction, including a y1564 profile that enables 1ad1q rewrite.\n\nThis test is triggered by the configuration of a y1564 profile with 1ad1q rewrite on an interface configured for internal direction on phy 1ad1q l2vpn.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal phy dot1ad l2vpn subinterface",
                "Procedure": "The configuration of the y1564 protocol is tested on the phy dot1ad l2vpn interface in the Internal direction, specifically in the context of the push1 rewrite feature. This test configures and verifies all Y1564 parameters, including those associated with internal behavior and the use of a y1564 profile that enables push1 rewriting.\n\nThis test is triggered by a y1564 profile with push1 rewrite configured on the phy dot1ad l2vpn interface in Internal direction.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal phy dot1ad l2vpn subinterface",
                "Procedure": "The test configures and verifies the internal translation of y1564 protocol on a phy dot1ad l2vpn interface. It configures and checks all relevant parameters, including those for the y1564 profile which uses the translate_1_1 rewrite configuration.\n\nThis test is triggered by configuration: y1564 profile with translate_1_1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal phy dot1ad l2vpn subinterface",
                "Procedure": "The configuration of the y1564 for internal direction on the phy dot1ad l2vpn interface should be tested by verifying that all y1564 parameters are configured properly with a pop1 rewrite profile. This test is triggered by configuring and verifying Y1564 behavior in internal direction with POP1 rewrite enabled, as part of the configuration which includes setting up a y1564 profile with POP1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal phy dot1q priority tagged l2vpn subinterface",
                "Procedure": "The configuration of the y1564 on an Internal direction phy dot1q_priority_tagged l2vpn interface is tested for the push1 configuration. The test configures and verifies the internal y1564 behavior with push1 rewrite, including all Y1564 parameters in the internal direction.\n\nThis test is triggered by a y1564 profile with push1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal phy dot1ad priority tagged l2vpn subinterface",
                "Procedure": "The configuration for the Internal direction on phy dot1ad_priority_tagged l2vpn interface includes testing the rewrite push1 settings of y1564. The test configures and verifies the internal behavior of y1564 when using a push1 rewrite.\n\nThis test is triggered by configuring a Y1564 profile with push1 rewrite.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite push1 internal phy qinq l2vpn subinterface",
                "Procedure": "The test is used to configure and verify the internal y1564 behavior with a push1 rewrite. It involves configuring and verifying all Y1564 parameters in internal direction on the phy qinq l2vpn interface. The configuration includes setting up a y1564 profile with push1 rewrite enabled.\n\nThis test is triggered by the need to validate the internal operation of y1564 with push1 rewriting activated in the specified L2VPN interface settings.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite pop1 internal phy qinq l2vpn subinterface",
                "Procedure": "The y1564 configuration in the internal direction is tested on a phy-qinq-L2VPN interface, where it configures and verifies the internal behavior of y1564 with pop1 rewriting enabled. All Y1564 parameters are configured and verified to function correctly within this setup.\n\nThis test is triggered by configuring a y1564 profile that uses POP1 rewriting in an internal direction configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            },
            {
                "Test Case Name": "Y1564 rewrite translate 1 1 internal phy qinq l2vpn subinterface",
                "Procedure": "The test configures and verifies the internal direction of the y1564 on a phy qinq l2vpn interface, specifically testing how it handles the translate_1_1 configuration. All Y1564 parameters in the internal direction are configured and verified as part of this test, which involves setting up a y1564 profile with a translate_1_1 rewrite rule in place.\n\nThis test is triggered by a y1564 profile with a translate_1_1 rewrite configuration.\n\nThis test function is parameterized using pytest.mark.parametrize to automatically run all combinations of the following parameter values:\nprofile_config: \"non_packet_measure\" and \"measure_combined\" and \"packet_type\"",
                "Pass/Fail Criteria": "Version verification is performed.\nY1564 details verification is performed.\nY1564: Verify y1564 feature is working verification is performed.\nTest case is passed if above verifications are successful."
            }
        ]
    }
}